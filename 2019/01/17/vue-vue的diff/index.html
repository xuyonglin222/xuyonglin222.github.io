<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="任风雨飘摇 我自怡然不动"><title>vue的diff | 庚庚</title><link rel="stylesheet" type="text/css" href="../../../../css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="../../../../favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="../../../../favicon.ico"><link rel="apple-touch-icon" href="../../../../apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="../../../../apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="../../../../atom.xml"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">vue的diff</h1><a id="logo" href="../../../../.">庚庚</a><p class="description">任风雨飘摇 我自怡然不动</p></div><div id="nav-menu"><a class="current" href="../../../../."><i class="fa fa-home"> 首页</i></a><a href="../../../../archives/"><i class="fa fa-archive"> 归档</i></a><a href="../../../../about/"><i class="fa fa-user"> 关于</i></a><a href="../../../../atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">vue的diff</h1><div class="post-meta">Jan 17, 2019<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2,831</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 12</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><blockquote>
<p>昨天部门做了分享，主题是react，不知道为毛扯到了vue的diff的，之前有看过diff文章和部分源码，时间太久，发现也忘记了，于是重新去瞅了一下源码，做个总结，举了3个🌰，画了12张图，所以本文更侧重于图文，而不是源码子曰：温故而知新，古人诚不我欺。</p>
</blockquote>
<a id="more"></a>
<h2 id="关键源码"><a href="#关键源码" class="headerlink" title="关键源码"></a>关键源码</h2><h3 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h3><p>vue关于diff模块源码地址：<a href="https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js" target="_blank" rel="noopener">https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js</a></p>
<p>其中最关键的就是在404行的updateChildren的函数里，顺便加点注释，PS：最好以后面的图文为主。</p>
<p>规则很简单，循环体内：</p>
<ul>
<li>首先判断newStart和oldEnd是不是undefind，如果是就newStart往后移，oldEnd往前移动。（源码中用的oldStartIdx，oldEndIdx，newStartIdx，oldStartVnode指得是索引，我的描述倾向于指针，指向的是该vNode节点，没啥区别）</li>
<li>oldStart和newStart判断是否值得比较，若true就patch，然后newStart++，oldStart++，否则进入下一步。</li>
<li>oldEnd和newEnd判断是否值得比较，若true就patch，然后newEnd–，oldEnd–，否则进入下一步。</li>
<li>oldStart和newEnd判断是否值得比较，若true就patch，接着将oldStart所指向的真实节点移动到的oldEnd所指向的真实节点的下一个节点的前面（就是移动到oldENd的位置），然后newEnd–，oldStart++，否则进入下一步。</li>
<li><p>oldEnd和newStart判断是否值得比较，若true就patch，接着将oldEnd所指向的真实节点移动到oldStart的前面,然后oldEnd–，newStart++，否则进入下一步。</p>
</li>
<li><p>如果两组指针都不能判断一个newVdom是增加的还是删除，就会创建一个map，存储oldVnode的映射。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;</span><br><span class="line">    <span class="built_in">let</span> oldStartIdx = 0</span><br><span class="line">    <span class="built_in">let</span> newStartIdx = 0</span><br><span class="line">    <span class="built_in">let</span> oldEndIdx = oldCh.length - 1</span><br><span class="line">    <span class="built_in">let</span> oldStartVnode = oldCh[0]</span><br><span class="line">    <span class="built_in">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">    <span class="built_in">let</span> newEndIdx = newCh.length - 1</span><br><span class="line">    <span class="built_in">let</span> newStartVnode = newCh[0]</span><br><span class="line">    <span class="built_in">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">    <span class="built_in">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">    // removeOnly is a special flag used only by &lt;transition-group&gt;</span><br><span class="line">    // to ensure removed elements stay <span class="keyword">in</span> correct relative positions</span><br><span class="line">    // during leaving transitions</span><br><span class="line">    const canMove = !removeOnly</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      checkDuplicateKeys(newCh)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right</span><br><span class="line">        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left</span><br><span class="line">        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       /*</span><br><span class="line">          生成一个key与旧VNode的key对应的哈希表，形如&#123;oldKey0: 0,oldKey1: 1,oldKey2: 2,oldKey3:</span><br><span class="line">          3&#125;，map的KEY(olKeyn)为vnode的key值，map的VALUE(n)为该vnode在oldVnode序列的索引</span><br><span class="line">        */</span><br><span class="line">        <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        idxInOld = isDef(newStartVnode.key)</span><br><span class="line">          ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        <span class="keyword">if</span> (isUndef(idxInOld)) &#123; // New element</span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          vnodeToMove = oldCh[idxInOld]</span><br><span class="line">          <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">            oldCh[idxInOld] = undefined</span><br><span class="line">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            // same key but different element. treat as new element</span><br><span class="line">            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm</span><br><span class="line">      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="keyword">function</span> createKeyToOldIdx (children, beginIdx, endIdx) &#123;</span><br><span class="line">  <span class="built_in">let</span> i, key</span><br><span class="line">  const map = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (i = beginIdx; i &lt;= endIdx; ++i) &#123;</span><br><span class="line">    key = children[i].key</span><br><span class="line">    <span class="keyword">if</span> (isDef(key)) map[key] = i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h3><p>代码在这：<a href="https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js" target="_blank" rel="noopener">https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js</a>   第501行。<br>其实这个函数就是在两个节点值得diff的情况下，去更新差异。<br>规则如下：</p>
<p>1.如果新旧VNode都是静态的，同时它们的key相同（代表同一节点），并且新的VNode是clone或者是标记了once（标记v-once属性，只渲染一次），那么只需要替换elm以及componentInstance即可。</p>
<p>2.新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren，这个updateChildren也是diff的核心。</p>
<p>3.如果老节点没有子节点而新节点存在子节点，先清空老节点DOM的文本内容，然后为当前DOM节点加入子节点。</p>
<p>4.当新节点没有子节点而老节点有子节点的时候，则移除该DOM节点的所有子节点。</p>
<p>5.当新老节点都无子节点的时候，只是文本的替换。</p>
<h3 id="sameVnode"><a href="#sameVnode" class="headerlink" title="sameVnode"></a>sameVnode</h3><p>代码量很少就贴一下代码，其实功能就是判断两个虚拟dom节点是不是值得patch。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> sameVnode (a, b) &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    a.key === b.key &amp;&amp; (</span><br><span class="line">      (</span><br><span class="line">        a.tag === b.tag &amp;&amp;</span><br><span class="line">        a.isComment === b.isComment &amp;&amp;</span><br><span class="line">        isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class="line">        sameInputType(a, b)</span><br><span class="line">      ) || (</span><br><span class="line">        isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class="line">        a.asyncFactory === b.asyncFactory &amp;&amp;</span><br><span class="line">        isUndef(b.asyncFactory.error)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="开始BB"><a href="#开始BB" class="headerlink" title="开始BB"></a>开始BB</h2><p>首先diff是对新的和老的vNode节点进行比对，比对依赖于两个东西：</p>
<ul>
<li><p>两组指针，newStart，newEnd以及oldStart，oldEnd，通过对比移动，最后比较两组值的大小，来确定删除增加移动，但并不是所有的情况都能覆盖。</p>
</li>
<li><p>一个map，是一个用来建立oldVnode的key和索引的映射关系，形如</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    oldKey0: 0,</span><br><span class="line">    oldKey1: 1,</span><br><span class="line">    oldKey2: 2,</span><br><span class="line">    oldKey3: 3,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h3><p>原来dom节点是这样的，ABCD对应节点的key分别为A，B，C，D，后来在B和C插入了一个元素X，那么在diff的时候，指针的指向如下列图所示。</p>
<p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/1.jpg" alt="1"></p>
<h4 id="第1步"><a href="#第1步" class="headerlink" title="第1步"></a>第1步</h4><p>在满足oldStart&lt;= oldEnd &amp;&amp; newStart &lt;= newEnd时，oldStart和newStart进行对比，sameVnode函数返回true，也就是说值得比较，于是就patchVnode就是讲新产生的变化更新到真实的dom节点上，之后改变指针指向进入下一步，如图所示。</p>
<p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/2.jpg" alt="2"></p>
<h4 id="第2步"><a href="#第2步" class="headerlink" title="第2步"></a>第2步</h4><p>接着发现newB和oldB也是值得比较的就重复上述的步骤</p>
<p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/3.jpg" alt="2"></p>
<h4 id="第3步"><a href="#第3步" class="headerlink" title="第3步"></a>第3步</h4><p>C和X不一样，也就是说sameVnode返回的是false，那么就会比较oldEnd和newEnd，发现是值得比较的，没话说，上去就是一顿patch，然后指针都往前移，👇</p>
<p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/4.jpg" alt="2"></p>
<h4 id="第4步"><a href="#第4步" class="headerlink" title="第4步"></a>第4步</h4><p>这个时候还是满足while的循环条件的嘛，故一顿patch之后，指针前移，👇</p>
<p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/5.jpg" alt="2"></p>
<h4 id="第5步"><a href="#第5步" class="headerlink" title="第5步"></a>第5步</h4><p>这个时候oldEnd&gt;oldStart不满足oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx，这个时候</p>
<p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/fenxi.jpeg" alt=""></p>
<p>oldStart &gt; oldEnd，那么newStart和newEnd所指向的节点就是新增的，反过来</p>
<p>newStart &gt; newEnd，那么oldStart和oldEnd所指向的节点就是被删掉的。判断出该节点的状态之后，就直接在真实的dom上去更新了，就是用的addVnodes或者removeVnodes，看着是穿进去了很多参数，其实最后，就是insert(parentEle, X, C)，其实最终变换形态就是parentEle.insertBefore(X, C)，在C前插入X，我之前一直以为会用队列进行缓存这个插入的状态，然后在Dom引擎一次更新（想到啥，写点啥），顺便说一下，所谓直接操作dom性能差的原因：</p>
<blockquote>
<ol>
<li>js是单线程的，但是Dom操作和js执行是在不同的引擎上的，dom进行操作时，JS引擎就得被挂起，反之亦然。</li>
<li>JS 代码调用 DOM API 必须经过 <em>挂起 JS 引擎、转换传入参数数据、激活 DOM 引擎</em>，DOM 重绘后再转换可能有的返回值，最后激活 JS 引擎并继续执行，再挂起Dom引擎。</li>
<li>若有频繁的 DOM API 调用，且浏览器厂商不做“批量处理”优化，引擎间切换的单位代价将迅速积累。</li>
<li>若其中有强制重绘的 DOM API 调用，不但厂商费尽心机做的“批量处理”优化被中断，<strong>重新计算布局</strong>、<strong>重新绘制图像</strong>会引起更大的性能消耗。</li>
</ol>
</blockquote>
<p>所以，我觉得频繁的更新Dom，频繁的切换引擎，引擎的不断挂起和激活，无疑是在消耗巨大的性能，故用个队列存一下，一次更新，避免开销，然而看源码之后，发现vue并没有做，其实很显然。。。。。。。。。。。。。。。。。。。拿队列去存储更新的dom的状态，然后循环遍历读取状态并更新也是要切换引擎的。。。。。。（竟然把一个错误的理解了这么久）。现在其实只用了头和头尾跟尾的比较，还有头跟尾，尾和头的呢？那就再举个🌰</p>
<h3 id="再举个🌰"><a href="#再举个🌰" class="headerlink" title="再举个🌰"></a>再举个🌰</h3><h4 id="第1步-1"><a href="#第1步-1" class="headerlink" title="第1步"></a>第1步</h4><p>原来的节点是这样的：A B C D，后来的是这样的：D C B A，ok，继续看图作文。</p>
<p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/6.jpg" alt=""></p>
<h4 id="第2步-1"><a href="#第2步-1" class="headerlink" title="第2步"></a>第2步</h4><p>目前真实的dom和oldNodeList是一样，以后<strong><em>移动节点是在真实的dom上移动的</em></strong>。oldStart和newStart以及newEnd和oldEnd都不是值得比较，因此会进行到oldStart和newEnd的比较，patch之后开始移动，<br>根据文章一开始介绍的规则，将oldStart移动到<strong><em>oldEnd</em></strong>所指向的真实节点的下一个，也就是将A移动到D的下一个节点（及文本节点）的前面，那么真实的dom就变成了B C D A，然后移动指针</p>
<p>move的代码如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br></pre></td></tr></table></figure>
<p>nodeOps是vue对weex和web的ui变化进行封装了一些方法，比如insertBefore，removeChild，appendChild等等，在<a href="https://github.com/vuejs/vue/tree/2.6/src/platforms" target="_blank" rel="noopener">这个位置</a> 会看到两个文件夹，web和weex，各有一个runtime/node-ops.js。</p>
<p>如图<br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/7.jpg" alt=""></p>
<h4 id="第3步-1"><a href="#第3步-1" class="headerlink" title="第3步"></a>第3步</h4><p>ok，接下来就是下一次循环，还是进入oldStart与newEnd的比较，和上一步的比较规则一样，这次是把真实domB移动到D的下一个节点（即真实DomA）的前面就变成了C D B A，然后移动指针。<br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/12.jpg" alt=""></p>
<h4 id="第4步-1"><a href="#第4步-1" class="headerlink" title="第4步"></a>第4步</h4><p>最后一步，巧了，还是比较oldStart和newEnd，不同的是这次是domC，按照规则，是把C移动到D的下一个节点（即真实DomB）的前面，就变成了D C B A，是不是就和newVnode的顺序是一样的了。</p>
<p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/8.jpg" alt=""></p>
<h3 id="再再举个例子"><a href="#再再举个例子" class="headerlink" title="再再举个例子"></a>再再举个例子</h3><h4 id="第1步-2"><a href="#第1步-2" class="headerlink" title="第1步"></a>第1步</h4><p>原来的dom节点是A B C D，新的是C D A B，每个节点的key对应的是自己的名称，如下图所示，这时，两组指针相互对比发现，并不能得出某个dom节点的状态，这就是两组指针不能涵盖的情况。</p>
<p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/9.jpg" alt=""></p>
<h4 id="第2步-2"><a href="#第2步-2" class="headerlink" title="第2步"></a>第2步</h4><p>于是key就起到了作用，创建一个map{A: 0,B: 1, C: 2, D: 3}，这是一个oldVnode和key抽出来的映射，然后通过map[newStart.key]就能找到newVnode在原来老节点的位置，在这个🌰中，就是map[C]，然后对比oldVnodeC和newVnodeC，然后将差异更新到真实的dom上，然后<strong><em>将newStart对应的真实dom移动到oldStart的前面</em></strong>，也就是将真实domC放在A的前面，其实用的也是parentEle.insertBefore(C, A)然后newStart往后挪动一位，再把oldVnode中的C置为undefined，如下图所示</p>
<p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/10.jpg" alt=""></p>
<h4 id="第3步-2"><a href="#第3步-2" class="headerlink" title="第3步"></a>第3步</h4><p>至此，本次循环就结束了，进入下一轮循环，然后会进入到oldEnd和newStart，就是oldVnode的D和newVnode的D的对比，更新差异之后，<strong><em>将oldEnd对应的真实dom移动到oldStart的前面</em></strong>，也就是把D放在A的前面，然后将oldEnd前移，newStart后移，变成下面的样子（注：当指针指向undefined时，end会前移，start会后移，所以我把箭头直接指向了B）。<br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/11.jpg" alt=""></p>
<h4 id="第4步-2"><a href="#第4步-2" class="headerlink" title="第4步"></a>第4步</h4><p>接下来的情况就好说了，dom和期望的顺序已经是一致的了，接下来就是运用diff的start之间的比较更新下差异就行了。</p>
</div><div class="tags"><a href="../../../../tags/vue/">vue</a></div><div class="post-nav"><a class="pre" href="../../../07/22/%E5%85%B6%E4%BB%96-%E5%B0%81%E5%9F%B9%E6%80%BB%E7%BB%93/">封培总结</a><a class="next" href="../vue%E7%9A%84diff/">vue的diff</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '9fc19543f349999565e8',
  clientSecret: 'daab664e11d913d9afd26317879e7df79c3bcb8b',
  repo: 'xuyonglin222.github.io',
  owner: 'xuyonglin222',
  admin: ['xuyonglin222'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://yoursite.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://korion.cn/" title="cyy" target="_blank">cyy</a><ul></ul><a href="http://www.mochiko.cn/" title="李年糕" target="_blank">李年糕</a><ul></ul><a href="https://anrans.github.io" title="高鹏" target="_blank">高鹏</a><ul></ul><a href="https://blog.csdn.net/xiaoritai7803" title="书研Sister" target="_blank">书研Sister</a><ul></ul><a href="https://waynewang98.github.io" title="waynewang98" target="_blank">waynewang98</a><ul></ul><a href="https://dymonelewis.github.io" title="傻琪" target="_blank">傻琪</a><ul></ul><a href="https://blog.alan123.xyz/" title="alan" target="_blank">alan</a></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="../../../../categories/%E5%AD%A6%E4%B9%A0/">学习</a></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/%E6%8C%87%E5%BC%B9/">指弹</a></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/%E7%94%9F%E6%B4%BB/">生活</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="../../../../tags/react/" style="font-size: 15px;">react</a> <a href="../../../../tags/javascript/" style="font-size: 15px;">javascript</a> <a href="../../../../tags/React-Native/" style="font-size: 15px;">React Native</a> <a href="../../../../tags/%E6%9D%82%E8%AE%B0/" style="font-size: 15px;">杂记</a> <a href="../../../../tags/%E6%8C%87%E5%BC%B9/" style="font-size: 15px;">指弹</a> <a href="../../../../tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="../../../../tags/%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">学习</a> <a href="../../../../tags/vue/" style="font-size: 15px;">vue</a> <a href="../../../../tags/%E4%B8%8D%E7%9F%A5%E9%81%93%E5%BD%92%E4%B8%BA%E5%93%AA%E4%B8%80%E5%88%97%E7%B3%BB%E5%88%97/" style="font-size: 15px;">不知道归为哪一列系列</a> <a href="../../../../tags/%E5%85%B6%E4%BB%96/" style="font-size: 15px;">其他</a> <a href="../../../../tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 15px;">浏览器</a> <a href="../../../../tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="../../../../tags/koa/" style="font-size: 15px;">koa</a> <a href="../../../../tags/http/" style="font-size: 15px;">http</a> <a href="../../../../tags/%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">网络</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="../../../09/28/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">垃圾回收</a></li><li class="post-list-item"><a class="post-list-link" href="../../../09/17/%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%B8%B2%E6%9F%93/">渲染</a></li><li class="post-list-item"><a class="post-list-link" href="../../../08/07/%E7%BD%91%E7%BB%9C-Quic/">Quic</a></li><li class="post-list-item"><a class="post-list-link" href="../../../07/25/%E6%9D%82%E8%AE%B0-MingJingNote/">明镜小结</a></li><li class="post-list-item"><a class="post-list-link" href="../../../07/22/%E5%B0%81%E5%9F%B9%E6%80%BB%E7%BB%93/">封培总结</a></li><li class="post-list-item"><a class="post-list-link" href="../../../07/22/%E5%85%B6%E4%BB%96-%E5%B0%81%E5%9F%B9%E6%80%BB%E7%BB%93/">封培总结</a></li><li class="post-list-item"><a class="post-list-link" href="">vue的diff</a></li><li class="post-list-item"><a class="post-list-link" href="../vue%E7%9A%84diff/">vue的diff</a></li><li class="post-list-item"><a class="post-list-link" href="../../04/react-react%E7%9A%84setState/">react的setState</a></li><li class="post-list-item"><a class="post-list-link" href="../../04/react%E7%9A%84setState/">react的setState</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="../../../../." rel="nofollow">庚庚.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="../../../../js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="../../../../js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="../../../../js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="../../../../js/smartresize.js?v=0.0.0"></script></div></body></html>