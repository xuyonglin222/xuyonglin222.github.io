<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>庚庚</title>
  
  <subtitle>任风雨飘摇 我自怡然不动</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xuyonglin222.github.io/"/>
  <updated>2019-09-12T05:22:55.000Z</updated>
  <id>http://xuyonglin222.github.io/</id>
  
  <author>
    <name>徐永林</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Quic</title>
    <link href="http://xuyonglin222.github.io/2019/08/07/Quic/"/>
    <id>http://xuyonglin222.github.io/2019/08/07/Quic/</id>
    <published>2019-08-07T08:27:47.000Z</published>
    <updated>2019-09-12T05:22:55.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Google家是真的DIAO啊，掌控了http的发展啊。</p></blockquote><h3 id="Quic简述"><a href="#Quic简述" class="headerlink" title="Quic简述"></a>Quic简述</h3><p>Quic 全称 quick udp internet connection，“快速 UDP 互联网连接”，是由 google 提出的使用 udp 进行多路并发传输的协议。</p><h3 id="为啥需要Quic"><a href="#为啥需要Quic" class="headerlink" title="为啥需要Quic"></a>为啥需要Quic</h3><p>为毛需要Quic，因为http2.0有一些硬伤难以解决，啥硬伤呢？就是TCP。<br><br>经过几十年的经验累积，网络工程师对怎么优化网络访问，降低延迟也有了新的认知，于是就想着更新 TCP 协议，但是 TCP 的更新非常困难，因为网络协议栈的实现本来就依赖系统内核更新，而不管是终端设备，中间设备的系统更新都极其缓慢，一个更新迭代可能需要5-15年的时间去普及，对于现在的互联网发展来说太慢了。</p><p>所以 TCP 的硬伤总结一下就是：TCP的更新优化需要依赖系统内核更新。</p><h4 id="基础环境的不match"><a href="#基础环境的不match" class="headerlink" title="基础环境的不match"></a>基础环境的不match</h4><h5 id="中间设备的僵化"><a href="#中间设备的僵化" class="headerlink" title="中间设备的僵化"></a>中间设备的僵化</h5><p>目前，我们很多中间设备，比如防火墙、NAT网关等出现了一些默认的动作。</p><p>比如防火墙只允许通过80和443，不放通其他端口。NAT 网关在转换网络地址时重写传输层的头部，有可能导致双方无法使用新的传输格式。整流器和中间代理有时候出于安全的需要，会删除一些它们不认识的选项字段。<br>TCP 协议本来是支持端口、选项及特性的增加和修改。但是由于 TCP 协议和知名端口及选项使用的历史太悠久，中间设备已经依赖于这些潜规则，所以对这些内容的修改很容易遭到中间环节的干扰而失败。</p><p>而这些干扰，也导致很多在 TCP 协议上的优化变得小心谨慎，步履维艰。</p><h5 id="依赖于操作系统的实现导致协议僵化"><a href="#依赖于操作系统的实现导致协议僵化" class="headerlink" title="依赖于操作系统的实现导致协议僵化"></a>依赖于操作系统的实现导致协议僵化</h5><p>TCP 是由操作系统在内核西方栈层面实现的，应用程序只能使用，不能直接修改。虽然应用程序的更新迭代非常快速和简单。但是 TCP 的迭代却非常缓慢，原因就是操作系统升级很麻烦。</p><p>现在移动终端更加流行，但是移动端部分用户的操作系统升级依然可能滞后数年时间。PC 端的系统升级滞后得更加严重，windows xp 现在还有大量用户在使用，尽管它已经存在快 20 年。</p><p>服务端系统不依赖用户升级，但是由于操作系统升级涉及到底层软件和运行库的更新，所以也比较保守和缓慢。</p><p>这也就意味着即使 TCP 有比较好的特性更新，也很难快速推广。比如 TCP Fast Open。它虽然 2013 年就被提出了，但是 Windows 很多系统版本依然不支持它。</p><h4 id="连接建立快"><a href="#连接建立快" class="headerlink" title="连接建立快"></a>连接建立快</h4><p>现在，网络建立在TCP之上，因为它作为传输协议的可靠性。要启动TCP连接，将执行3次握手。这意味着每个起始连接的额外往返（网络数据包来回发送）会增加任何新连接的显着延迟。另外，如果还需要TLS创建安全加密的https连接，则需要发送更多的网络数据包。</p><p>当客户端首次发起QUIC连接时，客户端想服务器发送一个client hello消息，服务器回复一个server reject消息。该消息中有包括server config，类似于TLS1.3中的key_share交换。这需要产生1-RTT. 事实上，QUIC加密协议的作者也明确指出当前的QUIC加密协议是「注定要死掉的」(destined to die), 未来将会被TLS1.3代替。只是在QUIC提出来的时候，TLS1.3还没出生😂，这只是一个临时的加密方案。</p><p>当客户端获取到server config以后，就可以直接计算出密钥，发送应用数据了，可以认为是0-RTT。因此，QUIC握手除去首次连接需要产生1-RTT，理论上，后续握手都是0-RTT的。假设1-RTT=100ms, QUIC建立安全连接连接的握手开销为0ms, 功能上等价于TCP+TLS, 但是握手开销比建立普通的TCP连接延迟都低。</p><h4 id="更高效的拥塞控制"><a href="#更高效的拥塞控制" class="headerlink" title="更高效的拥塞控制"></a>更高效的拥塞控制</h4><p>目前的 QUIC 的拥塞控制主要实现了 TCP 的慢启动，拥塞避免，快重传，快恢复。在这些拥塞控制算法的基础上，再进行改进。</p><p>比如单调递增的 Packet Number。TCP 使用了基于字节序号 Sequence Number 和 ACK 来保证消息的有序到达。但是 Sequence Number 在重传的时候有二义性。你不知道下一个 ACK 是上一次请求的响应还是这次重传的响应。而单调递增的 Packet Number 可以避免这个问题，保证采样 RTT 的准确。</p><blockquote><p>具体改进可以参考<a href="https://zhuanlan.zhihu.com/p/32553477" target="_blank" rel="noopener">这篇文章</a></p></blockquote><p>QUIC 拥塞控制算法主要重新实现了一遍 TCP 的算法，毕竟 TCP 的算法是经过几十年的生产验证的。</p><h4 id="可插拔"><a href="#可插拔" class="headerlink" title="可插拔"></a>可插拔</h4><p>什么叫可插拔呢？就是能够非常灵活地生效，变更和停止。体现在如下方面：</p><ol><li>应用程序层面就能实现不同的拥塞控制算法，不需要操作系统，不需要内核支持。这是一个飞跃，因为传统的 TCP 拥塞控制，必须要端到端的网络协议栈支持，才能实现控制效果。而内核和操作系统的部署成本非常高，升级周期很长，这在产品快速迭代，网络爆炸式增长的今天，显然有点满足不了需求。</li><li>即使是单个应用程序的不同连接也能支持配置不同的拥塞控制。就算是一台服务器，接入的用户网络环境也千差万别，结合大数据及人工智能处理，我们能为各个用户提供不同的但又更加精准更加有效的拥塞控制。比如 BBR 适合，Cubic 适合。</li><li>应用程序不需要停机和升级就能实现拥塞控制的变更，我们在服务端只需要修改一下配置，reload 一下，完全不需要停止服务就能实现拥塞控制的切换。<br>STGW 在配置层面进行了优化，我们可以针对不同业务，不同网络制式，甚至不同的 RTT，使用不同的拥塞控制算法。<h4 id="前向纠错"><a href="#前向纠错" class="headerlink" title="前向纠错"></a>前向纠错</h4></li></ol><p>QUIC的一个很好的功能是FEC或前向纠错。发送的每个数据包还包括其他数据包的足够数据，以便可以重建丢失的数据包而无需重新传输。</p><p>这实际上是网络级别的RAID 5。</p><p>因此，需要进行权衡：每个UDP数据包包含的负载超出了严格必要的数量，因为它可以解决丢失数据包的可能性，这种数据包可以更容易地以这种方式重新创建。</p><p>当前比率似乎约为10个数据包。因此，对于每发送10个UDP数据包，有足够的数据来重建丢失的数据包。如果你愿意，可以节省10％的开销。</p><p>将前向纠错视为可以发送的“每UDP数据包数据”的牺牲，但增益不必重新发送丢失的数据包，这将花费更长的时间（收件人必须确认丢失的数据包，请求它再次等待回应）。</p><h4 id="会话恢复和并行下载"><a href="#会话恢复和并行下载" class="headerlink" title="会话恢复和并行下载"></a>会话恢复和并行下载</h4><p>在TCP中，需要四个参数建立连接，源IP、源端口和目的IP、目的端口。如果任何参数（源IP /端口或目标IP /端口）发生更改，则需要进行新的TCP连接。如果任何参数（源IP /端口或目标IP /端口）发生更改，则需要进行新的TCP连接。<br>使用QUIC，因为它现在使用UDP，所以没有四元组。</p><p>QUIC为称为Connection UUID的唯一连接实现了自己的标识符。从WiFi到LTE仍然可以保持连接UUID，因此无需重新协商连接或TLS。之前的连接仍然有效。</p><p>这与Mosh Shell的工作方式相同，通过UDP保持SSH连接，以获得更好的漫游和移动体验。</p><p>这也打开了使用多个来源获取内容的大门。如果可以通过WiFi 和蜂窝连接共享连接UUID ，理论上可以使用两种媒体来下载内容。用户可以使用拥有的每个可用界面并行地有效地流式传输或下载内容。</p><p>虽然仍然是理论上的，但UDP允许这种创新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="学习" scheme="http://xuyonglin222.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>由明镜项目引起的学习记录</title>
    <link href="http://xuyonglin222.github.io/2019/07/25/MingJingNote/"/>
    <id>http://xuyonglin222.github.io/2019/07/25/MingJingNote/</id>
    <published>2019-07-25T15:54:06.000Z</published>
    <updated>2019-09-12T05:22:55.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>将项目里遇到的坑，或者说一些优秀的想法记下来</p></blockquote><a id="more"></a><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>import(‘/src/nav.js’)是import的动态用法，返回值是一个promise，resolve的形如{ default: nav, __esModule: true }</p><h3 id="asyncComponent"><a href="#asyncComponent" class="headerlink" title="asyncComponent"></a>asyncComponent</h3><p>对于加载页面时，并未立即显示的组件，可以采用异步组件的模式按需加载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> loadComponent(getComponent)&#123;</span><br><span class="line">    <span class="built_in">return</span> class AsyncComponent extend PureComponent&#123;</span><br><span class="line">        static AsyComponent = null;</span><br><span class="line">        state = &#123;</span><br><span class="line">            AsyComponent : AsyncComponent.AsyComponent</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function"><span class="title">componentDidMount</span></span>()&#123;</span><br><span class="line">            <span class="keyword">if</span>(!this.state.AsyComponent)&#123;</span><br><span class="line">                getComponent().<span class="keyword">then</span>((&#123; default: Component &#125;) =&gt; &#123;</span><br><span class="line">                    this.setState(&#123;</span><br><span class="line">                        AsyComponent: Component</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">render</span></span>()&#123;</span><br><span class="line">            const &#123; AsyComponent &#125; = this.state;</span><br><span class="line">            <span class="built_in">return</span> (</span><br><span class="line">                <span class="keyword">if</span>(AsyComponent)&#123;</span><br><span class="line">                    &lt;AsyComponent/&gt;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">return</span> &lt;Spin title=<span class="string">'加载中....'</span>/&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps"></a>mapDispatchToProps</h3><ul><li>mapDispatchToProps用于建立组件跟store.dispatch的映射关系</li><li>可以是一个object，也可以传入函数</li><li>如果mapDispatchToProps是一个函数，它可以传入dispatch,ownProps, 定义UI组件如何发出action，实际上就是要调用dispatch这个方法</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* 假设actions是一个import进来的值为actionCreator的object */</span><br><span class="line">action.increase = <span class="keyword">function</span> (info) &#123;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="built_in">type</span>:<span class="string">'INCREASE'</span>，</span><br><span class="line">        info</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mapDispatchToProps = (dispatch, ownProps) =&gt; &#123;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    increase: (...args) =&gt; dispatch(actions.increase(...args)),</span><br><span class="line">    decrease: (...args) =&gt; dispatch(actions.decrease(...args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用actions.increase()只能得到一个 action对象{type:’INCREASE’} ，要触发这个 action必须在store 上调用 dispatch 方法。 diapatch正是 mapDispatchToProps的第一个参数。但是，为了不让 组件感知到 dispatch 的存在，需要将increase 和 decrease 两个函数包装一下，使之成为直接可被调用的函数（即，调用该方法就会触发 dispatch ）。</p><h4 id="bindActionCreator"><a href="#bindActionCreator" class="headerlink" title="bindActionCreator"></a>bindActionCreator</h4><p>bindActionCreator可以将action包装成可以被调用的函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import &#123;bindActionCreators&#125; from <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line">const mapDispatchToProps = &#123;</span><br><span class="line">&#125; = (dispatch, ownProps) =&gt; &#123;</span><br><span class="line">  <span class="built_in">return</span> bindActionCreators(&#123;</span><br><span class="line">    increase: action.increase,</span><br><span class="line">    decrease: action.decrease</span><br><span class="line">  &#125;, dispatch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 返回跟上面一样的object */</span><br><span class="line">&#123;</span><br><span class="line">   increase: (...args) =&gt; dispatch(action.increase(...args)),</span><br><span class="line">   decrease: (...args) =&gt; dispatch(action.decrease(...args)),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>如果mapDispatchToProps是一个函数, 并且传入ownProps, 当组件获取新的props的时候，mapDispatchToProps也会被调用.</li><li>传入一个object，其中这个object所对应的value必须是actionCreator，这样redux里面会自动帮我们调用bindActionCreator，所以上面又可以变成</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const mapDispatchToProps = &#123;</span><br><span class="line">    ...action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h5><p><a href="https://imweb.io/topic/5a426d32a192c3b460fce354" target="_blank" rel="noopener">https://imweb.io/topic/5a426d32a192c3b460fce354</a></p><h3 id="antd"><a href="#antd" class="headerlink" title="antd"></a>antd</h3><h4 id="CheckBox"><a href="#CheckBox" class="headerlink" title="CheckBox"></a>CheckBox</h4><ul><li>描述： form.resetFields时，不能重置checkbox</li><li>解决办法：在getFieldDecorator(key, options)的options里添加{valuePropName: ‘checked’}</li></ul><h4 id="rangePicker"><a href="#rangePicker" class="headerlink" title="rangePicker"></a>rangePicker</h4><ul><li>默认时间不显示</li><li>解决办法：用initialValue而不是defaultValue更不是defaultPickerValue</li></ul><h4 id="小常识"><a href="#小常识" class="headerlink" title="小常识"></a>小常识</h4><p>被form.create()包裹的组件，当form控件的的值方式变化的时候，会触发自定义组件的rerender。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;将项目里遇到的坑，或者说一些优秀的想法记下来&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="About" scheme="http://xuyonglin222.github.io/tags/About/"/>
    
  </entry>
  
  <entry>
    <title>封培总结</title>
    <link href="http://xuyonglin222.github.io/2019/07/22/%E5%B0%81%E5%9F%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://xuyonglin222.github.io/2019/07/22/封培总结/</id>
    <published>2019-07-22T02:44:48.000Z</published>
    <updated>2019-07-29T09:43:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>正式开始接需求之前，公司安排进行了时期5天的封闭培训，真的是收获了满满的感动和‘疲惫’</p></blockquote><a id="more"></a><p>此次参加在弦上项目题目是基于供需预测的热力图方案，前端技术栈主要是react+dva+mapbox，主要实现了对于乘客端热力在历史、现在以及未来不同时间的查询与展示的基础功能，另外添加了调色板，popup，日夜间模式，更换底图以及打点的附加功能，另外因为我们有移动端的同学，因此对前端进行了适配，使之嵌套在安卓端和ios端。</p><ul><li>难点：mapbox的官方文档及其不友好，在开发过程中花费了大量的时间在查询api上。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><ul><li>帮助另外非react技术栈的同学开发。</li><li>能够为遇到的问题提供合适的解决方案。</li><li>开发热情持续高亢，五天中有三四天熬夜熬到了凌晨4点半。</li></ul><h3 id="不足："><a href="#不足：" class="headerlink" title="不足："></a>不足：</h3><ul><li>在拆分产品需求阶段，前端方面的拆分有疏漏，原因是地图相关业务知识的短缺，没有及时了解相关知识。</li><li>功能评定level部分不合理，在前后端未调通之前，主要功能方面只开发了UI部分，忽视了逻辑部分，将精力大量的投入到了换底图，打点，日夜间模式切换的功能上面。</li><li>前后端沟通不充分，因此，在遇到项目bug时，未能及时准确定位出原因，浪费了一些精力。</li><li>部分接口缺少mock。</li></ul><h3 id="收获以及感悟："><a href="#收获以及感悟：" class="headerlink" title="收获以及感悟："></a>收获以及感悟：</h3><ul><li>在项目的产品需求拆分阶段或者开发初期阶段，就应该提前了解该项目的相关业务知识。</li><li>功能拆分后，应当对需求的level进行合理的划分，而不是简单地列一下，就进行分工。</li><li>在我看来，我们小组每一位同学都尽可能地散发出了光和热，每一位同学对技术都有着极大地热情，每个人都想着去完善这个项目，最终收获了一等奖。</li></ul><p>此次在弦上培训让我意识到了什么是团队，虽然只是短暂的五天，却留下了满满的感动和’疲惫’，希望第八组的每个同学在各自的工作团队做出好成绩，也感谢在弦上的每一位教委老师，感谢教练，感谢两位运营管家，以及最后的评委老师，老师们真的提出了对我们职业生涯很重要的意见。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;正式开始接需求之前，公司安排进行了时期5天的封闭培训，真的是收获了满满的感动和‘疲惫’&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue的diff</title>
    <link href="http://xuyonglin222.github.io/2019/01/17/vue%E7%9A%84diff/"/>
    <id>http://xuyonglin222.github.io/2019/01/17/vue的diff/</id>
    <published>2019-01-17T09:41:09.000Z</published>
    <updated>2019-08-26T11:52:28.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>昨天部门做了分享，主题是react，不知道为毛扯到了vue的diff的，之前有看过diff文章和部分源码，时间太久，发现也忘记了，于是重新去瞅了一下源码，做个总结，举了3个🌰，画了12张图，所以本文更侧重于图文，而不是源码子曰：温故而知新，古人诚不我欺。</p></blockquote><a id="more"></a><h2 id="关键源码"><a href="#关键源码" class="headerlink" title="关键源码"></a>关键源码</h2><h3 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h3><p>vue关于diff模块源码地址：<a href="https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js" target="_blank" rel="noopener">https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js</a></p><p>其中最关键的就是在404行的updateChildren的函数里，顺便加点注释，PS：最好以后面的图文为主。</p><p>规则很简单，循环体内：</p><ul><li>首先判断newStart和oldEnd是不是undefind，如果是就newStart往后移，oldEnd往前移动。（源码中用的oldStartIdx，oldEndIdx，newStartIdx，oldStartVnode指得是索引，我的描述倾向于指针，指向的是该vNode节点，没啥区别）</li><li>oldStart和newStart判断是否值得比较，若true就patch，然后newStart++，oldStart++，否则进入下一步。</li><li>oldEnd和newEnd判断是否值得比较，若true就patch，然后newEnd–，oldEnd–，否则进入下一步。</li><li>oldStart和newEnd判断是否值得比较，若true就patch，接着将oldStart所指向的真实节点移动到的oldEnd所指向的真实节点的下一个节点的前面（就是移动到oldENd的位置），然后newEnd–，oldStart++，否则进入下一步。</li><li><p>oldEnd和newStart判断是否值得比较，若true就patch，接着将oldEnd所指向的真实节点移动到oldStart的前面,然后oldEnd–，newStart++，否则进入下一步。</p></li><li><p>如果两组指针都不能判断一个newVdom是增加的还是删除，就会创建一个map，存储oldVnode的映射。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;</span><br><span class="line">    <span class="built_in">let</span> oldStartIdx = 0</span><br><span class="line">    <span class="built_in">let</span> newStartIdx = 0</span><br><span class="line">    <span class="built_in">let</span> oldEndIdx = oldCh.length - 1</span><br><span class="line">    <span class="built_in">let</span> oldStartVnode = oldCh[0]</span><br><span class="line">    <span class="built_in">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">    <span class="built_in">let</span> newEndIdx = newCh.length - 1</span><br><span class="line">    <span class="built_in">let</span> newStartVnode = newCh[0]</span><br><span class="line">    <span class="built_in">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">    <span class="built_in">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">    // removeOnly is a special flag used only by &lt;transition-group&gt;</span><br><span class="line">    // to ensure removed elements stay <span class="keyword">in</span> correct relative positions</span><br><span class="line">    // during leaving transitions</span><br><span class="line">    const canMove = !removeOnly</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      checkDuplicateKeys(newCh)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right</span><br><span class="line">        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left</span><br><span class="line">        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       /*</span><br><span class="line">          生成一个key与旧VNode的key对应的哈希表，形如&#123;oldKey0: 0,oldKey1: 1,oldKey2: 2,oldKey3:</span><br><span class="line">          3&#125;，map的KEY(olKeyn)为vnode的key值，map的VALUE(n)为该vnode在oldVnode序列的索引</span><br><span class="line">        */</span><br><span class="line">        <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        idxInOld = isDef(newStartVnode.key)</span><br><span class="line">          ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        <span class="keyword">if</span> (isUndef(idxInOld)) &#123; // New element</span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          vnodeToMove = oldCh[idxInOld]</span><br><span class="line">          <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">            oldCh[idxInOld] = undefined</span><br><span class="line">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            // same key but different element. treat as new element</span><br><span class="line">            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm</span><br><span class="line">      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="keyword">function</span> createKeyToOldIdx (children, beginIdx, endIdx) &#123;</span><br><span class="line">  <span class="built_in">let</span> i, key</span><br><span class="line">  const map = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (i = beginIdx; i &lt;= endIdx; ++i) &#123;</span><br><span class="line">    key = children[i].key</span><br><span class="line">    <span class="keyword">if</span> (isDef(key)) map[key] = i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h3><p>代码在这：<a href="https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js" target="_blank" rel="noopener">https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js</a>   第501行。<br>其实这个函数就是在两个节点值得diff的情况下，去更新差异。<br>规则如下：</p><p>1.如果新旧VNode都是静态的，同时它们的key相同（代表同一节点），并且新的VNode是clone或者是标记了once（标记v-once属性，只渲染一次），那么只需要替换elm以及componentInstance即可。</p><p>2.新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren，这个updateChildren也是diff的核心。</p><p>3.如果老节点没有子节点而新节点存在子节点，先清空老节点DOM的文本内容，然后为当前DOM节点加入子节点。</p><p>4.当新节点没有子节点而老节点有子节点的时候，则移除该DOM节点的所有子节点。</p><p>5.当新老节点都无子节点的时候，只是文本的替换。</p><h3 id="sameVnode"><a href="#sameVnode" class="headerlink" title="sameVnode"></a>sameVnode</h3><p>代码量很少就贴一下代码，其实功能就是判断两个虚拟dom节点是不是值得patch。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> sameVnode (a, b) &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    a.key === b.key &amp;&amp; (</span><br><span class="line">      (</span><br><span class="line">        a.tag === b.tag &amp;&amp;</span><br><span class="line">        a.isComment === b.isComment &amp;&amp;</span><br><span class="line">        isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class="line">        sameInputType(a, b)</span><br><span class="line">      ) || (</span><br><span class="line">        isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class="line">        a.asyncFactory === b.asyncFactory &amp;&amp;</span><br><span class="line">        isUndef(b.asyncFactory.error)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开始BB"><a href="#开始BB" class="headerlink" title="开始BB"></a>开始BB</h2><p>首先diff是对新的和老的vNode节点进行比对，比对依赖于两个东西：</p><ul><li><p>两组指针，newStart，newEnd以及oldStart，oldEnd，通过对比移动，最后比较两组值的大小，来确定删除增加移动，但并不是所有的情况都能覆盖。</p></li><li><p>一个map，是一个用来建立oldVnode的key和索引的映射关系，形如</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    oldKey0: 0,</span><br><span class="line">    oldKey1: 1,</span><br><span class="line">    oldKey2: 2,</span><br><span class="line">    oldKey3: 3,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h3><p>原来dom节点是这样的，ABCD对应节点的key分别为A，B，C，D，后来在B和C插入了一个元素X，那么在diff的时候，指针的指向如下列图所示。</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/1.jpg" alt="1"></p><h4 id="第1步"><a href="#第1步" class="headerlink" title="第1步"></a>第1步</h4><p>在满足oldStart&lt;= oldEnd &amp;&amp; newStart &lt;= newEnd时，oldStart和newStart进行对比，sameVnode函数返回true，也就是说值得比较，于是就patchVnode就是讲新产生的变化更新到真实的dom节点上，之后改变指针指向进入下一步，如图所示。</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/2.jpg" alt="2"></p><h4 id="第2步"><a href="#第2步" class="headerlink" title="第2步"></a>第2步</h4><p>接着发现newB和oldB也是值得比较的就重复上述的步骤</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/3.jpg" alt="2"></p><h4 id="第3步"><a href="#第3步" class="headerlink" title="第3步"></a>第3步</h4><p>C和X不一样，也就是说sameVnode返回的是false，那么就会比较oldEnd和newEnd，发现是值得比较的，没话说，上去就是一顿patch，然后指针都往前移，👇</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/4.jpg" alt="2"></p><h4 id="第4步"><a href="#第4步" class="headerlink" title="第4步"></a>第4步</h4><p>这个时候还是满足while的循环条件的嘛，故一顿patch之后，指针前移，👇</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/5.jpg" alt="2"></p><h4 id="第5步"><a href="#第5步" class="headerlink" title="第5步"></a>第5步</h4><p>这个时候oldEnd&gt;oldStart不满足oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx，这个时候</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/fenxi.jpeg" alt></p><p>oldStart &gt; oldEnd，那么newStart和newEnd所指向的节点就是新增的，反过来</p><p>newStart &gt; newEnd，那么oldStart和oldEnd所指向的节点就是被删掉的。判断出该节点的状态之后，就直接在真实的dom上去更新了，就是用的addVnodes或者removeVnodes，看着是穿进去了很多参数，其实最后，就是insert(parentEle, X, C)，其实最终变换形态就是parentEle.insertBefore(X, C)，在C前插入X，我之前一直以为会用队列进行缓存这个插入的状态，然后在Dom引擎一次更新（想到啥，写点啥），顺便说一下，所谓直接操作dom性能差的原因：</p><blockquote><ol><li>js是单线程的，但是Dom操作和js执行是在不同的引擎上的，dom进行操作时，JS引擎就得被挂起，反之亦然。</li><li>JS 代码调用 DOM API 必须经过 <em>挂起 JS 引擎、转换传入参数数据、激活 DOM 引擎</em>，DOM 重绘后再转换可能有的返回值，最后激活 JS 引擎并继续执行，再挂起Dom引擎。</li><li>若有频繁的 DOM API 调用，且浏览器厂商不做“批量处理”优化，引擎间切换的单位代价将迅速积累。</li><li>若其中有强制重绘的 DOM API 调用，不但厂商费尽心机做的“批量处理”优化被中断，<strong>重新计算布局</strong>、<strong>重新绘制图像</strong>会引起更大的性能消耗。</li></ol></blockquote><p>所以，我觉得频繁的更新Dom，频繁的切换引擎，引擎的不断挂起和激活，无疑是在消耗巨大的性能，故用个队列存一下，一次更新，避免开销，然而看源码之后，发现vue并没有做，其实很显然。。。。。。。。。。。。。。。。。。。拿队列去存储更新的dom的状态，然后循环遍历读取状态并更新也是要切换引擎的。。。。。。（竟然把一个错误的理解了这么久）。现在其实只用了头和头尾跟尾的比较，还有头跟尾，尾和头的呢？那就再举个🌰</p><h3 id="再举个🌰"><a href="#再举个🌰" class="headerlink" title="再举个🌰"></a>再举个🌰</h3><h4 id="第1步-1"><a href="#第1步-1" class="headerlink" title="第1步"></a>第1步</h4><p>原来的节点是这样的：A B C D，后来的是这样的：D C B A，ok，继续看图作文。</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/6.jpg" alt></p><h4 id="第2步-1"><a href="#第2步-1" class="headerlink" title="第2步"></a>第2步</h4><p>目前真实的dom和oldNodeList是一样，以后<strong><em>移动节点是在真实的dom上移动的</em></strong>。oldStart和newStart以及newEnd和oldEnd都不是值得比较，因此会进行到oldStart和newEnd的比较，patch之后开始移动，<br>根据文章一开始介绍的规则，将oldStart移动到<strong><em>oldEnd</em></strong>所指向的真实节点的下一个，也就是将A移动到D的下一个节点（及文本节点）的前面，那么真实的dom就变成了B C D A，然后移动指针</p><p>move的代码如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br></pre></td></tr></table></figure><p>nodeOps是vue对weex和web的ui变化进行封装了一些方法，比如insertBefore，removeChild，appendChild等等，在<a href="https://github.com/vuejs/vue/tree/2.6/src/platforms" target="_blank" rel="noopener">这个位置</a> 会看到两个文件夹，web和weex，各有一个runtime/node-ops.js。</p><p>如图<br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/7.jpg" alt></p><h4 id="第3步-1"><a href="#第3步-1" class="headerlink" title="第3步"></a>第3步</h4><p>ok，接下来就是下一次循环，还是进入oldStart与newEnd的比较，和上一步的比较规则一样，这次是把真实domB移动到D的下一个节点（即真实DomA）的前面就变成了C D B A，然后移动指针。<br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/12.jpg" alt></p><h4 id="第4步-1"><a href="#第4步-1" class="headerlink" title="第4步"></a>第4步</h4><p>最后一步，巧了，还是比较oldStart和newEnd，不同的是这次是domC，按照规则，是把C移动到D的下一个节点（即真实DomB）的前面，就变成了D C B A，是不是就和newVnode的顺序是一样的了。</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/8.jpg" alt></p><h3 id="再再举个例子"><a href="#再再举个例子" class="headerlink" title="再再举个例子"></a>再再举个例子</h3><h4 id="第1步-2"><a href="#第1步-2" class="headerlink" title="第1步"></a>第1步</h4><p>原来的dom节点是A B C D，新的是C D A B，每个节点的key对应的是自己的名称，如下图所示，这时，两组指针相互对比发现，并不能得出某个dom节点的状态，这就是两组指针不能涵盖的情况。</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/9.jpg" alt></p><h4 id="第2步-2"><a href="#第2步-2" class="headerlink" title="第2步"></a>第2步</h4><p>于是key就起到了作用，创建一个map{A: 0,B: 1, C: 2, D: 3}，这是一个oldVnode和key抽出来的映射，然后通过map[newStart.key]就能找到newVnode在原来老节点的位置，在这个🌰中，就是map[C]，然后对比oldVnodeC和newVnodeC，然后将差异更新到真实的dom上，然后<strong><em>将newStart对应的真实dom移动到oldStart的前面</em></strong>，也就是将真实domC放在A的前面，其实用的也是parentEle.insertBefore(C, A)然后newStart往后挪动一位，再把oldVnode中的C置为undefined，如下图所示</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/10.jpg" alt></p><h4 id="第3步-2"><a href="#第3步-2" class="headerlink" title="第3步"></a>第3步</h4><p>至此，本次循环就结束了，进入下一轮循环，然后会进入到oldEnd和newStart，就是oldVnode的D和newVnode的D的对比，更新差异之后，<strong><em>将oldEnd对应的真实dom移动到oldStart的前面</em></strong>，也就是把D放在A的前面，然后将oldEnd前移，newStart后移，变成下面的样子（注：当指针指向undefined时，end会前移，start会后移，所以我把箭头直接指向了B）。<br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/11.jpg" alt></p><h4 id="第4步-2"><a href="#第4步-2" class="headerlink" title="第4步"></a>第4步</h4><p>接下来的情况就好说了，dom和期望的顺序已经是一致的了，接下来就是运用diff的start之间的比较更新下差异就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;昨天部门做了分享，主题是react，不知道为毛扯到了vue的diff的，之前有看过diff文章和部分源码，时间太久，发现也忘记了，于是重新去瞅了一下源码，做个总结，举了3个🌰，画了12张图，所以本文更侧重于图文，而不是源码子曰：温故而知新，古人诚不我欺。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="vue" scheme="http://xuyonglin222.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>react的setState</title>
    <link href="http://xuyonglin222.github.io/2019/01/04/react%E7%9A%84setState/"/>
    <id>http://xuyonglin222.github.io/2019/01/04/react的setState/</id>
    <published>2019-01-04T10:04:57.000Z</published>
    <updated>2019-07-29T09:43:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>记得当时初学的时候，看的是《深入浅出react与redux》，学到了react与redux的基本用法，异步action的与原理，以及react-redux的原理，收获颇丰，但是对于react本身的原理倒是没有很多的阐述，最近很多人推荐《深入react技术栈》，其实这本书有点老了，但是不算过时，就去瞅了瞅。</p></blockquote><a id="more"></a><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>看书时，抱着疑问去看的，主要是为了解决这两个问题，一直以来都是一知半解，setState是异步的还是同步的？</p><h3 id="setState关键点"><a href="#setState关键点" class="headerlink" title="setState关键点"></a>setState关键点</h3><ul><li>setState不会立刻改变React组件中state的值</li><li>多次setState函数调用产生的效果会合并。</li><li>setState通过引发一次组件的更新过程来引发重新绘制，重绘指的就是引起React的更新生命周期函数4个函数：<ul><li>shouldComponentUpdate（被调用时this.state没有更新；如果返回了false，生命周期被中断，虽然不调用之后的函数了，但是state仍然会被更新）</li><li>componentWillUpdate（被调用时this.state没有更新）</li><li>render（被调用时this.state得到更新）</li><li>componentDidUpdate</li></ul></li></ul><p>首先举个🌰，修改了《深入react技术栈》中的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    num:0</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span></span>()&#123;</span><br><span class="line">    this.setState(&#123; </span><br><span class="line">      num: this.state.num+1</span><br><span class="line">     &#125;);</span><br><span class="line">     console.log(this.state.num);</span><br><span class="line">     this.setState(&#123; </span><br><span class="line">      num: this.state.num+1</span><br><span class="line">     &#125;);</span><br><span class="line">     console.log(this.state.num);</span><br><span class="line"></span><br><span class="line">     setTimeout(() =&gt; &#123;</span><br><span class="line">      this.setState(&#123; </span><br><span class="line">        num:this.state.num+1</span><br><span class="line">       &#125;)</span><br><span class="line">       console.log(<span class="string">'timeout'</span>, this.state.num);</span><br><span class="line">        this.setState(&#123; </span><br><span class="line">          num:this.state.num+1</span><br><span class="line">         &#125;)</span><br><span class="line">         console.log(<span class="string">'timeout'</span>, this.state.num);</span><br><span class="line">        &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidUpdate</span></span>()&#123;</span><br><span class="line">    // console.log(<span class="string">'update'</span>,this.state.num);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'rendering'</span>, this.state.num)</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">        &lt;p&gt;&#123;this.state.num&#125;&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出是这样的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rendering 0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">rendering 1</span><br><span class="line">rendering 2</span><br><span class="line">timeout 2</span><br><span class="line">rendering 3</span><br><span class="line">timeout 3</span><br></pre></td></tr></table></figure><p>看起来setState好像是异步的，state的值并没有立刻发生变化，但是setTimeout里setState却立刻更新了，瞅了一眼源码发现了这样一串代码。</p><figure class="highlight plain"><figcaption><span>enqueueUpdate(component) &#123;</span><a href="//">...  if (!batchingStrategy.isBatchingUpdates) &#123;    batchingStrategy.batchedUpdates(enqueueUpdate, component);    return;  &#125;  dirtyComponents.push(component);&#125;</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function enqueueUpdate(component) &#123;</span><br><span class="line">  ensureInjected();</span><br><span class="line"></span><br><span class="line">  // Various parts of our code (such as ReactCompositeComponent&apos;s</span><br><span class="line">  // _renderValidatedComponent) assume that calls to render aren&apos;t nested;</span><br><span class="line">  // verify that that&apos;s the case. (This is called by each top-level update</span><br><span class="line">  // function, like setProps, setState, forceUpdate, etc.; creation and</span><br><span class="line">  // destruction of top-level components is guarded in ReactMount.)</span><br><span class="line"></span><br><span class="line">  if (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dirtyComponents.push(component);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>react在数据更新时，并不会立刻触发render，而是通过一个队列去缓存，然后通过isBatchingUpdates这个变量判断当前是否立刻更新。isBatchingUpdates默认是false，也就表示setState会同步更新this.state，当React在调用事件处理函数之前就会调用batchedUpdates，这个函数会把isBatchingUpdates修改为true，在componentDidMount时，这个值已经被置为true，所以两次setState并没有立刻改变state的值，而是缓存了起来，而setTimeout的回调函数在执行时，isBatchingUpdates这个值又被重置为false，所以settimeout离得setState是立刻更新state并触发render的，addEventListener也是和setTimeout一样的效果。</p><p><strong>所以，究其根本，setState本身就是同步的，它的实现内部没有用到eventLoop，全都是同步代码，所以在setTimeout里是上述情形</strong>，我们写的每一个组价都是函数，都是跑在react里的，他屏蔽了很多细节，包括setState改变state的机制。</p><h3 id="setState另一个用法"><a href="#setState另一个用法" class="headerlink" title="setState另一个用法"></a>setState另一个用法</h3><p>setState(nextState, callback)，指明callback，nextState会立即与当前state进行合并。</p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>seState会引发视图重新渲染，无论state有没有改变，就算传一个空对象进去，也会引发重绘，所以往往需要shouldComponentUpdate来进行优化，它的参数是nextProps和nextState，可以通过和当前的state，props进行比较，如果一致，就return false，阻止render函数调用。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记得当时初学的时候，看的是《深入浅出react与redux》，学到了react与redux的基本用法，异步action的与原理，以及react-redux的原理，收获颇丰，但是对于react本身的原理倒是没有很多的阐述，最近很多人推荐《深入react技术栈》，其实这本书有点老了，但是不算过时，就去瞅了瞅。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://xuyonglin222.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>selfPromise</title>
    <link href="http://xuyonglin222.github.io/2018/12/31/selfPromise/"/>
    <id>http://xuyonglin222.github.io/2018/12/31/selfPromise/</id>
    <published>2018-12-30T16:34:38.000Z</published>
    <updated>2019-07-29T09:43:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>把之前手写过的promise在梳理一遍</p></blockquote><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">var PENDING = 0;</span><br><span class="line">var FULFILLED = 1;</span><br><span class="line">var REJECTED = 2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> myPromise(fn) &#123;</span><br><span class="line">    var state = PENDING;</span><br><span class="line">    var value = null;</span><br><span class="line">    var handlers = [];</span><br><span class="line">    var e =null;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> resolve(val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val instanceof myPromise) &#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                val.then(resolve);</span><br><span class="line">            &#125;catch(e)&#123;</span><br><span class="line">                reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        state = FULFILLED;</span><br><span class="line">        value = val;</span><br><span class="line">        setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            handlers.map(<span class="keyword">function</span> (handler) &#123;</span><br><span class="line">                handle(handler)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, 0)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> reject(err) &#123;</span><br><span class="line">        state = REJECTED;</span><br><span class="line">        e = err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> handle(handler) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state === PENDING) &#123;</span><br><span class="line">            handlers.push(handler);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            <span class="keyword">if</span> (state === FULFILLED &amp;&amp; typeof handler.onFulfilled === <span class="string">'function'</span>) &#123;</span><br><span class="line">                <span class="built_in">let</span> ret = handler.onFulfilled(value);</span><br><span class="line">                handler.resolve(ret);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(e)&#123;</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//onFulfilled, onRejected是可选参数，如果不是函数可以忽略</span><br><span class="line">    this.then = <span class="keyword">function</span> (onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="built_in">return</span> new myPromise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">            handle(&#123;</span><br><span class="line">                onFulfilled,</span><br><span class="line">                resolve,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn(resolve, reject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：状态切换就不说了，很显然。</p><p>then函数将回调注册到promise内部的队列里，在resolve里遍历调用，要注意的是，resolve执行时，得是异步，要在then注册完之后调用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">new myPromise(<span class="keyword">function</span>(resolve)&#123;</span><br><span class="line">    GET(url, <span class="keyword">function</span>(data1)&#123;</span><br><span class="line">        resolve(data1)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="keyword">function</span>(data1)&#123;</span><br><span class="line">const toChainPoromise = new myPromise(<span class="keyword">function</span>(resolve)&#123;</span><br><span class="line">    POST(url, <span class="keyword">function</span>(data2)&#123;</span><br><span class="line">             resolve(data1+data2)</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">return</span> toChainPoromise;</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="keyword">function</span>(data)&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>为了链式调用，then函数的返回值一定是个promise，但是在第二个then里回调函数接受的数据data应该依赖于toChainPoromise，而不是then函数本身返回的promise，所以then函数既要把toChainPoromise和后面的then衔接起来。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;把之前手写过的promise在梳理一遍&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="学习" scheme="http://xuyonglin222.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>git杂记</title>
    <link href="http://xuyonglin222.github.io/2018/12/07/git%E6%9D%82%E8%AE%B0/"/>
    <id>http://xuyonglin222.github.io/2018/12/07/git杂记/</id>
    <published>2018-12-07T08:33:09.000Z</published>
    <updated>2019-09-12T05:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不会git的程序员啥也不是。ps:作为杂记篇，持续更新，对工作上遇到的问题做个积累。<br><a id="more"></a></p><h3 id="git的三个区域"><a href="#git的三个区域" class="headerlink" title="git的三个区域"></a>git的三个区域</h3><ul><li>工作区，就是在编辑器里看到的那些代码</li><li>缓存区，通过git add将指定文件添加到此区域</li><li>版本库，通过git commit可以将文件存缓存区提交到此区域，其实就是提交记录的集合，可以通过commitId进行回滚，也可以将此次提交push到远程仓库。</li></ul><h3 id="commitID"><a href="#commitID" class="headerlink" title="commitID"></a>commitID</h3><p>形如 1953***6c4ed4的这个东东，就是文件进行改动后，通过git commit命令生成的，可以当做一次提交的唯一标识，之后可以通过git reset/revert/checkout回滚。查看提交记录，可以使用  git log 或者git log  –oneline</p><h3 id="一些常用的命令"><a href="#一些常用的命令" class="headerlink" title="一些常用的命令"></a>一些常用的命令</h3><h4 id="git-status-gst"><a href="#git-status-gst" class="headerlink" title="git status (gst)"></a>git status (gst)</h4><p>当你处于我是谁我在哪我要干嘛的状态时，你可以通过这个命令查看你之前改动了什么，你的工作目录处于一个什么样的工作状态。</p><h4 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h4><p>查看本地分支已经存在的分支，当前分支带*。</p><ul><li>-r 查看远程分支</li><li>dev 加分支名，创建分支dev</li><li>-d dev 删除分支dev</li></ul><h4 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h4><ul><li><p>dev 切换到dev分支上，然后更新工作目录。</p></li><li><p>-b dev 创建dev分支，并切换， <strong>创建分支时，会复制当前分支的代码，多方协作时，最好先切换到master，并且git pull之后在创建并切换分支</strong>。</p></li><li><p>commitID file<br>查看文件之前的版本。它将工作目录中的 file 文件变成 commitID 中那个文件的拷贝，并将它加入缓存区。</p></li><li><p>commitID<br>更新工作目录中的所有文件，使得和某个特定提交中的文件一致。你可以将提交的哈希字串，或是标签作为 commitID参数。这会使指针处于分离HEAD的状态，然后你git log发现，woc，这之后的提交记录都没了，GG了。其实这个时候git checkout加你的分支名，就又回来了，这就是所谓的分支HEAD的意思，他就像一个虚拟的分支，你也可以再次状态下在复制一份创建分支。</p></li><li><p>-b dev origin/dev<br>  将上游dev分支拉取到本地，而且他的commit记录是完全复制自上游dev的，和之前所在的分支没有半毛钱关系。</p></li><li><p>-track origin/dev<br>  创建本地分支并关联</p><h4 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h4><p>如果你在现在的分支做了一半的工作，想切回其他的分支，直接checkout，往往会报错，add+commit的话，自己的提交记录又是一团糟，就可以使用这个命令将更改暂时存储到git的一个堆栈，然后就可以放心地切换到其他分支工作，最后切回来时，使用git  stash pop就可以恢复你的修改继续工作。PS:git stash是将修改提交到本地，并不会随着push推到远程。</p></li></ul><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>将上游更改拉下来与本地合并，相当于git fetch和git  merge，如果该分支尚未与上游关联则要加origin dev。（dev为分支名）</p><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git  revert"></a>git  revert</h3><p>Revert 撤销一个提交的同时会创建一个新的提交。这是一个安全的方法，因为它不会重写提交历史。比如，下面的命令会找出倒数第二个提交，然后创建一个新的提交来撤销这些更改，然后把这个提交加入项目中。</p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git  reset"></a>git  reset</h3><p>这个命令可以消除提交记录，比如git reset HEAD~2，你的最后的两次提交记录就没了，但是你的工作区，并没有改变，可以通过这个命令让你的提交记录整洁起来。<br><br>如果你加上–hard，那么你的工作区就会和你回到reset的那个状态，但是新增的文件依旧存在。</p><table><thead><tr><th>命令</th><th>作用域</th><th>常用场景</th></tr></thead><tbody><tr><td>git reset</td><td>提交层面</td><td>在私有分支上舍弃一些没有提交的更改</td></tr><tr><td>git reset</td><td></td><td>文件层面</td><td>将文件从缓存区中移除</td></tr><tr><td>git checkout</td><td>提交层面</td><td>切换分支或查看旧版本</td></tr><tr><td>git checkout</td><td>文件层面</td><td>舍弃工作目录中的更改</td></tr><tr><td>git revert</td><td>提交层面</td><td>在公共分支上回滚更改</td></tr></tbody></table><ul><li><p><a href="https://github.com/xuyonglin222/git-recipes/blob/master/sources/1-%E6%9E%9C%E5%A3%B3%E4%B8%AD%E7%9A%84Git.md" target="_blank" rel="noopener">git好文</a></p></li><li><p><a href="https://learngitbranching.js.org" target="_blank" rel="noopener">一个有意思的学习git的网站</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不会git的程序员啥也不是。ps:作为杂记篇，持续更新，对工作上遇到的问题做个积累。&lt;br&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="http://xuyonglin222.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>koaMiddleWare</title>
    <link href="http://xuyonglin222.github.io/2018/08/07/koaMiddle/"/>
    <id>http://xuyonglin222.github.io/2018/08/07/koaMiddle/</id>
    <published>2018-08-07T13:09:48.000Z</published>
    <updated>2019-07-29T09:43:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="js的异步解决方案"><a href="#js的异步解决方案" class="headerlink" title="js的异步解决方案"></a>js的异步解决方案</h3><p>在javascript里，异步的解决方案包括以下几种：</p><ul><li>回调</li><li>promise</li><li>generator</li><li>async<br>优雅程度自上而下。<a id="more"></a></li></ul><h3 id="express-koa1-koa2"><a href="#express-koa1-koa2" class="headerlink" title="express koa1 koa2"></a>express koa1 koa2</h3><p>随着社会的不断发展和进步，emmmmm，express团队从一开始陆续搞出了express、koa1和koa2，为毛他们闲着没事干，搞这么多起相同功能的轮子呢？不知道老子学不动了吗?（开玩笑<br></p><p>koa相比express，轻量了不少，看官方文档就能知道，其实之所以重复造轮子，应该是因为异步的解决方案。<br><br></p><p>在express中，处理异步的方式，就是回调，如果回调太深的话，恶心程度可想而知，koa1主要是用generator函数做中间件函数，koa2是用async函数。<br>个人认为async最为优雅。使用方式不同，是因为内部对中间件函数的处理不同，looklook。<br></p><h3 id="application-js"><a href="#application-js" class="headerlink" title="application.js"></a>application.js</h3><p>koa的源码也就4个文件，在下主要看了application.js,代码以及部分注释如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Module dependencies.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">const isGeneratorFunction = require(<span class="string">'is-generator-function'</span>);</span><br><span class="line">const debug = require(<span class="string">'debug'</span>)(<span class="string">'koa:application'</span>);</span><br><span class="line">const onFinished = require(<span class="string">'on-finished'</span>);</span><br><span class="line">const response = require(<span class="string">'./response'</span>);</span><br><span class="line">const compose = require(<span class="string">'koa-compose'</span>);</span><br><span class="line">const isJSON = require(<span class="string">'koa-is-json'</span>);</span><br><span class="line">const context = require(<span class="string">'./context'</span>);</span><br><span class="line">const request = require(<span class="string">'./request'</span>);</span><br><span class="line">const statuses = require(<span class="string">'statuses'</span>);</span><br><span class="line">const Emitter = require(<span class="string">'events'</span>);</span><br><span class="line">const util = require(<span class="string">'util'</span>);</span><br><span class="line">const Stream = require(<span class="string">'stream'</span>);</span><br><span class="line">const http = require(<span class="string">'http'</span>);</span><br><span class="line">const only = require(<span class="string">'only'</span>);</span><br><span class="line">const convert = require(<span class="string">'koa-convert'</span>);</span><br><span class="line">const deprecate = require(<span class="string">'depd'</span>)(<span class="string">'koa'</span>);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Expose `Application` class.</span><br><span class="line"> * Inherits from `Emitter.prototype`.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"> //继承Emitter  因此 koa的实例 this可以调用on</span><br><span class="line">module.exports = class Application extends Emitter &#123;</span><br><span class="line">  /**</span><br><span class="line">   * Initialize a new `Application`.</span><br><span class="line">   *</span><br><span class="line">   * @api public</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    super();</span><br><span class="line"></span><br><span class="line">    this.proxy = <span class="literal">false</span>; //代理设置</span><br><span class="line">    this.middleware = [];</span><br><span class="line">    this.subdomainOffset = 2; //域名偏移</span><br><span class="line">    this.env = process.env.NODE_ENV || <span class="string">'development'</span>;</span><br><span class="line">    this.context = Object.create(context);</span><br><span class="line">    this.request = Object.create(request);</span><br><span class="line">    this.response = Object.create(response);</span><br><span class="line">    <span class="keyword">if</span> (util.inspect.custom) &#123;</span><br><span class="line">      this[util.inspect.custom] = this.inspect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Shorthand <span class="keyword">for</span>:</span><br><span class="line">   *</span><br><span class="line">   *    http.createServer(app.callback()).listen(...)</span><br><span class="line">   *</span><br><span class="line">   * @param &#123;Mixed&#125; ...</span><br><span class="line">   * @<span class="built_in">return</span> &#123;Server&#125;</span><br><span class="line">   * @api public</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  listen(...args) &#123;</span><br><span class="line">    debug(<span class="string">'listen'</span>);</span><br><span class="line">    const server = http.createServer(this.callback());</span><br><span class="line">    <span class="built_in">return</span> server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Return JSON representation.</span><br><span class="line">   * We only bother showing settings.</span><br><span class="line">   *</span><br><span class="line">   * @<span class="built_in">return</span> &#123;Object&#125;</span><br><span class="line">   * @api public</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toJSON</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> only(this, [</span><br><span class="line">      <span class="string">'subdomainOffset'</span>,</span><br><span class="line">      <span class="string">'proxy'</span>,</span><br><span class="line">      <span class="string">'env'</span></span><br><span class="line">    ]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Inspect implementation.</span><br><span class="line">   *</span><br><span class="line">   * @<span class="built_in">return</span> &#123;Object&#125;</span><br><span class="line">   * @api public</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">inspect</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.toJSON();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Use the given middleware `fn`.</span><br><span class="line">   *</span><br><span class="line">   * Old-style middleware will be converted.</span><br><span class="line">   *</span><br><span class="line">   * @param &#123;Function&#125; fn</span><br><span class="line">   * @<span class="built_in">return</span> &#123;Application&#125; self</span><br><span class="line">   * @api public</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  //对 generator 函数利用 koa-convert 库进行转化(将 generator 函数包装成 Promise),</span><br><span class="line">  //如果不是则不转化, 然后将这个中间件函数 push 进实例对象的 middleware 数组中.</span><br><span class="line">  use(fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeof fn !== <span class="string">'function'</span>) throw new TypeError(<span class="string">'middleware must be a function!'</span>);</span><br><span class="line">    <span class="keyword">if</span> (isGeneratorFunction(fn)) &#123;</span><br><span class="line">      deprecate(<span class="string">'Support for generators will be removed in v3. '</span> +</span><br><span class="line">                <span class="string">'See the documentation for examples of how to convert old middleware '</span> +</span><br><span class="line">                <span class="string">'https://github.com/koajs/koa/blob/master/docs/migration.md'</span>);</span><br><span class="line">      fn = convert(fn);</span><br><span class="line">    &#125;</span><br><span class="line">    debug(<span class="string">'use %s'</span>, fn._name || fn.name || <span class="string">'-'</span>);</span><br><span class="line">    this.middleware.push(fn);</span><br><span class="line">    <span class="built_in">return</span> this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Return a request handler callback</span><br><span class="line">   * <span class="keyword">for</span> node<span class="string">'s native http server.</span></span><br><span class="line"><span class="string">   *</span></span><br><span class="line"><span class="string">   * @return &#123;Function&#125;</span></span><br><span class="line"><span class="string">   * @api public</span></span><br><span class="line"><span class="string">   */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  callback() &#123;</span></span><br><span class="line"><span class="string">    //合并中间件</span></span><br><span class="line"><span class="string">    const fn = compose(this.middleware);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (!this.listenerCount('</span>error<span class="string">')) this.on('</span>error<span class="string">', this.onerror);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    const handleRequest = (req, res) =&gt; &#123;</span></span><br><span class="line"><span class="string">      const ctx = this.createContext(req, res);</span></span><br><span class="line"><span class="string">      return this.handleRequest(ctx, fn);</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return handleRequest;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  /**</span></span><br><span class="line"><span class="string">   * Handle request in callback.</span></span><br><span class="line"><span class="string">   *</span></span><br><span class="line"><span class="string">   * @api private</span></span><br><span class="line"><span class="string">   */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  handleRequest(ctx, fnMiddleware) &#123;</span></span><br><span class="line"><span class="string">    const res = ctx.res;</span></span><br><span class="line"><span class="string">    res.statusCode = 404;</span></span><br><span class="line"><span class="string">    const onerror = err =&gt; ctx.onerror(err);</span></span><br><span class="line"><span class="string">    const handleResponse = () =&gt; respond(ctx);</span></span><br><span class="line"><span class="string">    onFinished(res, onerror);</span></span><br><span class="line"><span class="string">    return fnMiddleware(ctx).then(handleResponse).catch(onerror);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  /**</span></span><br><span class="line"><span class="string">   * Initialize a new context.</span></span><br><span class="line"><span class="string">   *</span></span><br><span class="line"><span class="string">   * @api private</span></span><br><span class="line"><span class="string">   */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   //创建cotext request reponse 与http模块的关系</span></span><br><span class="line"><span class="string">  createContext(req, res) &#123;</span></span><br><span class="line"><span class="string">    const context = Object.create(this.context);</span></span><br><span class="line"><span class="string">    const request = context.request = Object.create(this.request);</span></span><br><span class="line"><span class="string">    const response = context.response = Object.create(this.response);</span></span><br><span class="line"><span class="string">    context.app = request.app = response.app = this;</span></span><br><span class="line"><span class="string">    context.req = request.req = response.req = req;</span></span><br><span class="line"><span class="string">    context.res = request.res = response.res = res;</span></span><br><span class="line"><span class="string">    request.ctx = response.ctx = context;</span></span><br><span class="line"><span class="string">    request.response = response;</span></span><br><span class="line"><span class="string">    response.request = request;</span></span><br><span class="line"><span class="string">    context.originalUrl = request.originalUrl = req.url;</span></span><br><span class="line"><span class="string">    context.state = &#123;&#125;;</span></span><br><span class="line"><span class="string">    return context;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  /**</span></span><br><span class="line"><span class="string">   * Default error handler.</span></span><br><span class="line"><span class="string">   *</span></span><br><span class="line"><span class="string">   * @param &#123;Error&#125; err</span></span><br><span class="line"><span class="string">   * @api private</span></span><br><span class="line"><span class="string">   */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  onerror(err) &#123;</span></span><br><span class="line"><span class="string">    if (!(err instanceof Error)) throw new TypeError(util.format('</span>non-error thrown: %j<span class="string">', err));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (404 == err.status || err.expose) return;</span></span><br><span class="line"><span class="string">    if (this.silent) return;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    const msg = err.stack || err.toString();</span></span><br><span class="line"><span class="string">    console.error();</span></span><br><span class="line"><span class="string">    console.error(msg.replace(/^/gm, '</span>  <span class="string">'));</span></span><br><span class="line"><span class="string">    console.error();</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * Response helper.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function respond(ctx) &#123;</span></span><br><span class="line"><span class="string">  // allow bypassing koa</span></span><br><span class="line"><span class="string">  if (false === ctx.respond) return;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  const res = ctx.res;</span></span><br><span class="line"><span class="string">  if (!ctx.writable) return;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  let body = ctx.body;</span></span><br><span class="line"><span class="string">  const code = ctx.status;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // ignore body</span></span><br><span class="line"><span class="string">  if (statuses.empty[code]) &#123;</span></span><br><span class="line"><span class="string">    // strip headers</span></span><br><span class="line"><span class="string">    ctx.body = null;</span></span><br><span class="line"><span class="string">    return res.end();</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  if ('</span>HEAD<span class="string">' == ctx.method) &#123;</span></span><br><span class="line"><span class="string">    if (!res.headersSent &amp;&amp; isJSON(body)) &#123;</span></span><br><span class="line"><span class="string">      ctx.length = Buffer.byteLength(JSON.stringify(body));</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return res.end();</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // status body</span></span><br><span class="line"><span class="string">  if (null == body) &#123;</span></span><br><span class="line"><span class="string">    body = ctx.message || String(code);</span></span><br><span class="line"><span class="string">    if (!res.headersSent) &#123;</span></span><br><span class="line"><span class="string">      ctx.type = '</span>text<span class="string">';</span></span><br><span class="line"><span class="string">      ctx.length = Buffer.byteLength(body);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return res.end(body);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // responses</span></span><br><span class="line"><span class="string">  if (Buffer.isBuffer(body)) return res.end(body);</span></span><br><span class="line"><span class="string">  if ('</span>string<span class="string">' == typeof body) return res.end(body);</span></span><br><span class="line"><span class="string">  if (body instanceof Stream) return body.pipe(res);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // body: json</span></span><br><span class="line"><span class="string">  body = JSON.stringify(body);</span></span><br><span class="line"><span class="string">  if (!res.headersSent) &#123;</span></span><br><span class="line"><span class="string">    ctx.length = Buffer.byteLength(body);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  res.end(body);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><p>其实中间件就是一个函数，koa中有一个middleware去储存中间件函数，是一个数组。<br><br><br>当use的时候，koa1中会把generator函数转化成promise形式，koa2会把async转化成promise形式，用的都是koa-convert模块，然后将函数push到middleware中。<br><br>最后在createServer的callback中，将中间件函数数组进行了合并，用了一个叫koa-compose的中间件。</p><h3 id="compose-js"><a href="#compose-js" class="headerlink" title="compose.js"></a>compose.js</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">use strict<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * Expose compositor.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">module.exports = compose</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * Compose `middleware` returning</span></span><br><span class="line"><span class="string"> * a fully valid middleware comprised</span></span><br><span class="line"><span class="string"> * of all those which are passed.</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * @param &#123;Array&#125; middleware</span></span><br><span class="line"><span class="string"> * @return &#123;Function&#125;</span></span><br><span class="line"><span class="string"> * @api public</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function compose (middleware) &#123;</span></span><br><span class="line"><span class="string">  if (!Array.isArray(middleware)) throw new TypeError('</span>Middleware stack must be an array!<span class="string">')</span></span><br><span class="line"><span class="string">  for (const fn of middleware) &#123;</span></span><br><span class="line"><span class="string">    if (typeof fn !== '</span><span class="keyword">function</span><span class="string">') throw new TypeError('</span>Middleware must be composed of <span class="built_in">functions</span>!<span class="string">')</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  /**</span></span><br><span class="line"><span class="string">   * @param &#123;Object&#125; context</span></span><br><span class="line"><span class="string">   * @return &#123;Promise&#125;</span></span><br><span class="line"><span class="string">   * @api public</span></span><br><span class="line"><span class="string">   */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  return function (context, next) &#123;</span></span><br><span class="line"><span class="string">    // last called middleware #</span></span><br><span class="line"><span class="string">    let index = -1; //当前中间件的索引</span></span><br><span class="line"><span class="string">    return dispatch(0)</span></span><br><span class="line"><span class="string">    function dispatch (i) &#123;</span></span><br><span class="line"><span class="string">      if (i &lt;= index) return Promise.reject(new Error('</span>next() called multiple <span class="built_in">times</span><span class="string">'))</span></span><br><span class="line"><span class="string">      index = i</span></span><br><span class="line"><span class="string">      let fn = middleware[i]</span></span><br><span class="line"><span class="string">      if (i === middleware.length) fn = next</span></span><br><span class="line"><span class="string">      if (!fn) return Promise.resolve()</span></span><br><span class="line"><span class="string">      try &#123;</span></span><br><span class="line"><span class="string">        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));</span></span><br><span class="line"><span class="string">      &#125; catch (err) &#123;</span></span><br><span class="line"><span class="string">        return Promise.reject(err)</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>compose中主要是dispatch，递归调用了这个函数，其实就是在第一个函数里执行第二个函数，在第二个函数里执行第三个。。。。。 就像一个洋葱。<br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/onion.png"><br>其实就是一个调用栈，然后包装成了promise，当next()时，generator函数，对应的就yield，就跳到了下一个中间件函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;js的异步解决方案&quot;&gt;&lt;a href=&quot;#js的异步解决方案&quot; class=&quot;headerlink&quot; title=&quot;js的异步解决方案&quot;&gt;&lt;/a&gt;js的异步解决方案&lt;/h3&gt;&lt;p&gt;在javascript里，异步的解决方案包括以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回调&lt;/li&gt;
&lt;li&gt;promise&lt;/li&gt;
&lt;li&gt;generator&lt;/li&gt;
&lt;li&gt;async&lt;br&gt;优雅程度自上而下。
    
    </summary>
    
      <category term="学习" scheme="http://xuyonglin222.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="koa" scheme="http://xuyonglin222.github.io/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>sort</title>
    <link href="http://xuyonglin222.github.io/2018/07/25/sort/"/>
    <id>http://xuyonglin222.github.io/2018/07/25/sort/</id>
    <published>2018-07-25T03:33:49.000Z</published>
    <updated>2019-07-29T09:43:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>先来张图片<br><img src="http://pdqpny9og.bkt.clouddn.com/paixu.png"><br><a id="more"></a></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li><1>.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</1></li><li><2>.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</2></li><li><3>.针对所有的元素重复以上的步骤，除了最后一个；</3></li><li><4>.重复步骤1~3，直到排序完成。</4></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bubbleSort(arr) &#123;</span><br><span class="line">    var i = arr.length-1;  //初始时,最后位置保持不变</span><br><span class="line">    <span class="keyword">while</span> ( i&gt; 0) &#123;</span><br><span class="line">        var pos= 0; //每趟开始时,无记录交换</span><br><span class="line">        <span class="keyword">for</span> (var j= 0; j&lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j]&gt; arr[j+1]) &#123;</span><br><span class="line">                pos= j; //记录交换的位置</span><br><span class="line">                var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        i= pos; //为下一趟排序作准备</span><br><span class="line">     &#125;</span><br><span class="line">     console.timeEnd(<span class="string">'改进后冒泡排序耗时'</span>);</span><br><span class="line">     <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li><1>.初始状态：无序区为R[1..n]，有序区为空；</1></li><li><2>.第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</2></li><li><3>.n-1趟结束，数组有序化了。</3></li></ul><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> selectionSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    var minIndex, temp;</span><br><span class="line">    <span class="keyword">for</span> (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (var j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     //寻找最小的数</span><br><span class="line">                minIndex = j;                 //将最小数的索引保存</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li><1>.从第一个元素开始，该元素可以认为已经被排序；</1></li><li><2>.取出下一个元素，在已经排序的元素序列中从后向前扫描；</2></li><li><3>.如果该元素（已排序）大于新元素，将该元素移到下一位置；</3></li><li><4>.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</4></li><li><5>.将新元素插入到该位置后；</5></li><li><6>.重复步骤2~5。</6></li></ul><h4 id="代码描述"><a href="#代码描述" class="headerlink" title="代码描述"></a>代码描述</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> insertionSort(array) &#123;</span><br><span class="line">    <span class="keyword">for</span> (var i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">            var key = array[i];</span><br><span class="line">            var j = i - 1;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= 0 &amp;&amp; array[j] &gt; key) &#123;</span><br><span class="line">                array[j + 1] = array[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            array[j + 1] = key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：输入数组按升序排列。T(n) = O(n)</li><li>最坏情况：输入数组按降序排列。T(n) = O(n2)</li><li>平均情况：T(n) = O(n2)</li></ul><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><h4 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li><1>. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</1></li><li><2>.按增量序列个数k，对序列进行k 趟排序；</2></li><li><3>.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</3></li></ul><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> shellSort(arr) &#123;</span><br><span class="line">    var len = arr.length,</span><br><span class="line">        temp,</span><br><span class="line">        gap = 1;</span><br><span class="line">    console.time(<span class="string">'希尔排序耗时:'</span>);</span><br><span class="line">    <span class="keyword">while</span>(gap &lt; len/5) &#123;          //动态定义间隔序列</span><br><span class="line">        gap =gap*5+1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (gap; gap &gt; 0; gap = Math.floor(gap/5)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (var i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123;</span><br><span class="line">                arr[j+gap] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j+gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    console.timeEnd(<span class="string">'希尔排序耗时:'</span>);</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(nlog2 n)</li><li>最坏情况：T(n) = O(nlog2 n)</li><li>平均情况：T(n) =O(nlog n)</li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li><1>把长度为n的输入序列分成两个长度为n/2的子序列；</1></li><li><2>对这两个子序列分别采用归并排序；</2></li><li><3>将两个排序好的子序列合并成一个最终的排序序列。</3></li></ul><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> mergeSort(arr) &#123;  //采用自上而下的递归方法</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; 2) &#123;</span><br><span class="line">        <span class="built_in">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    var middle = Math.floor(len / 2),</span><br><span class="line">        left = arr.slice(0, middle),</span><br><span class="line">        right = arr.slice(middle);</span><br><span class="line">    <span class="built_in">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> merge(left, right)</span><br><span class="line">&#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    console.time(<span class="string">'归并排序耗时'</span>);</span><br><span class="line">    <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[0] &lt;= right[0]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left.length)</span><br><span class="line">        result.push(left.shift());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right.length)</span><br><span class="line">        result.push(right.shift());</span><br><span class="line">    console.timeEnd(<span class="string">'归并排序耗时'</span>);</span><br><span class="line">    <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(n)</li><li>最坏情况：T(n) = O(nlog n)</li><li>平均情况：T(n) =O(nlog n)</li></ul><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li><1>从数列中挑出一个元素，称为 “基准”（pivot）；</1></li><li><2>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</2></li><li><3>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</3></li></ul><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var arr = [12,3,23,5,17,9,15,46];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> quickSort(arr,left, right)&#123;</span><br><span class="line">  var i,j,t,temp;</span><br><span class="line">  <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  i = left;</span><br><span class="line">  j = right;</span><br><span class="line">  temp = arr[left];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(i!==j)&#123;</span><br><span class="line">    <span class="keyword">while</span>(temp&lt;=arr[j]&amp;&amp;i&lt;j)&#123;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(temp&gt;=arr[i]&amp;&amp;i&lt;j)&#123;</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">      [arr[j], arr[i]] = [arr[i], arr[j]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr[left] = arr[i];</span><br><span class="line">  arr[i] = temp;</span><br><span class="line">  quickSort(arr,left,i-1);</span><br><span class="line">  quickSort(arr,i+1,right);</span><br><span class="line">&#125;</span><br><span class="line">quickSort(arr,0, arr.length-1);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><h4 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(nlogn)</li><li>最坏情况：T(n) = O(n2)</li><li>平均情况：T(n) =O(nlog n)</li></ul><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li><1>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</1></li><li><2>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</2></li><li><3>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> heapify(arr, x, len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Object.prototype.toString.call(arr).slice(8, -1) === <span class="string">'Array'</span> &amp;&amp; typeof x === <span class="string">'number'</span>) &#123;</span><br><span class="line">        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != x) &#123;</span><br><span class="line">            temp = arr[x];</span><br><span class="line">            arr[x] = arr[largest];</span><br><span class="line">            arr[largest] = temp;</span><br><span class="line">            heapify(arr, largest, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'arr is not an Array or x is not a number!'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*方法说明：维护堆的性质</span><br><span class="line">@param  arr 数组</span><br><span class="line">@param  x   数组下标</span><br><span class="line">@param  len 堆大小*/</span><br><span class="line"><span class="keyword">function</span> heapify(arr, x, len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Object.prototype.toString.call(arr).slice(8, -1) === <span class="string">'Array'</span> &amp;&amp; typeof x === <span class="string">'number'</span>) &#123;</span><br><span class="line">        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != x) &#123;</span><br><span class="line">            temp = arr[x];</span><br><span class="line">            arr[x] = arr[largest];</span><br><span class="line">            arr[largest] = temp;</span><br><span class="line">            heapify(arr, largest, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'arr is not an Array or x is not a number!'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></3></li></ul><h4 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(nlogn)</li><li>最坏情况：T(n) = O(nlogn)</li><li>平均情况：T(n) =O(nlogn)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先来张图片&lt;br&gt;&lt;img src=&quot;http://pdqpny9og.bkt.clouddn.com/paixu.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="学习" scheme="http://xuyonglin222.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://xuyonglin222.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Ngnix</title>
    <link href="http://xuyonglin222.github.io/2018/07/19/Ngnix/"/>
    <id>http://xuyonglin222.github.io/2018/07/19/Ngnix/</id>
    <published>2018-07-19T04:25:14.000Z</published>
    <updated>2019-07-29T09:43:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Nginx是啥"><a href="#Nginx是啥" class="headerlink" title="Nginx是啥"></a>Nginx是啥</h3><p>Nginx是一个使用c语言开发的高性能http服务器以及反向代理服务器。Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。<br><a id="more"></a></p><h3 id="Nginx可以干什么"><a href="#Nginx可以干什么" class="headerlink" title="Nginx可以干什么"></a>Nginx可以干什么</h3><p>网站资源服务器，反向代理负载均衡。</p><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的，此时大家可能都会用一个操作FQ进行访问，FQ的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！</p><p>上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>多个客户端给服务器发送的请求，Nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx扮演的就是一个反向代理角色，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息！</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>首先明确两个概念：</p><ul><li>负载量：客户端发送的、Nginx反向代理服务器接收到的请求数量。</li><li>均衡规则：请求数量按照一定的规则分配到不同服务器处理的规则。<br>故将服务器接收到的请求按照规则分发的过程，称为负载均衡。<h4 id="HTTP重定向实现"><a href="#HTTP重定向实现" class="headerlink" title="HTTP重定向实现"></a>HTTP重定向实现</h4>当用户发起http请求时，请求先被集群调度者捕获，调度者根据不同的调度算法分配服务器IP，并将其放入response的location字段，status返回302，然后浏览器拿到响应消息后，解析Location字段，并向url发起请求，然后指定的服务器处理该用户的请求，最后将结果返回给用户。<br></li></ul><p>在使用HTTP重定向来实现服务器集群负载均衡的过程中，需要一台服务器作为请求调度者。用户的一项操作需要发起两次HTTP请求，一次向调度服务器发送请求，获取后端服务器的IP，第二次向后端服务器发送请求，获取处理结果。<br></p><p>调度服务器收到用户的请求后，究竟选择哪台后端服务器处理请求，这由调度服务器所使用的调度策略决定。<br></p><ul><li><p>随机分配策略 :当调度服务器收到用户请求后，可以随机决定使用哪台后端服务器，然后将该服务器的IP封装在HTTP响应消息的Location属性中，返回给浏览器即可。</p></li><li><p>轮询策略(RR):调度服务器需要维护一个值，用于记录上次分配的后端服务器的IP。那么当新的请求到来时，调度者将请求依次分配给下一台服务器。</p></li></ul><p>由于轮询策略需要调度者维护一个值用于记录上次分配的服务器IP，因此需要额外的开销；此外，由于这个值属于互斥资源，那么当多个请求同时到来时，为了避免线程的安全问题，因此需要锁定互斥资源，从而降低了性能。而随机分配策略不需要维护额外的值，也就不存在线程安全问题，因此性能比轮询要高。<br></p><h5 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h5><p>采用HTTP重定向来实现服务器集群的负载均衡实现起来较为容易，逻辑比较简单，但缺点也较为明显。<br></p><p>在HTTP重定向方法中，调度服务器只在客户端第一次向网站发起请求的时候起作用。当调度服务器向浏览器返回响应信息后，客户端此后的操作都基于新的URL进行的(也就是后端服务器)，此后浏览器就不会与调度服务器产生关系，进而会产生如下几个问题：<br></p><p>由于不同用户的访问时间、访问页面深度有所不同，从而每个用户对各自的后端服务器所造成的压力也不同。而调度服务器在调度时，无法知道当前用户将会对服务器造成多大的压力，因此这种方式无法实现真正意义上的负载均衡，只不过是把请求次数平均分配给每台服务器罢了。<br></p><p>若分配给该用户的后端服务器出现故障，并且如果页面被浏览器缓存，那么当用户再次访问网站时，请求都会发给出现故障的服务器，从而导致访问失败。<br></p><h4 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h4><p>DNS服务器有一个天然的优势，如果一个域名指向了多个IP地址，那么每次进行域名解析时，DNS只要选一个IP返回给用户，就能够实现服务器集群的负载均衡。</p><h5 id="具体做法"><a href="#具体做法" class="headerlink" title="具体做法"></a>具体做法</h5><p>首先需要将我们的域名指向多个后端服务器(将一个域名解析到多个IP上)，再设置一下调度策略，那么我们的准备工作就完成了，接下来的负载均衡就完全由DNS服务器来实现。</p><p>当用户向我们的域名发起请求时，DNS服务器会自动地根据我们事先设定好的调度策略选一个合适的IP返回给用户，用户再向该IP发起请求。</p><h5 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h5><p>一般DNS提供商会提供一些调度策略供我们选择，如随机分配、轮询、根据请求者的地域分配离他最近的服务器。</p><h5 id="优缺点分析-1"><a href="#优缺点分析-1" class="headerlink" title="优缺点分析"></a>优缺点分析</h5><p>DNS负载均衡最大的优点就是配置简单。服务器集群的调度工作完全由DNS服务器承担，那么我们就可以把精力放在后端服务器上，保证他们的稳定性与吞吐量。而且完全不用担心DNS服务器的性能，即便是使用了轮询策略，它的吞吐率依然卓越。<br>此外，DNS负载均衡具有较强了扩展性，你完全可以为一个域名解析较多的IP，而且不用担心性能问题。<br><br><br>但是，由于把集群调度权交给了DNS服务器，从而我们没办法随心所欲地控制调度者，没办法定制调度策略。<br><br><br>DNS服务器也没办法了解每台服务器的负载情况，因此没办法实现真正意义上的负载均衡。它和HTTP重定向一样，只不过把所有请求平均分配给后端服务器罢了。<br><br><br>此外，当我们发现某一台后端服务器发生故障时，即使我们立即将该服务器从域名解析中去除，但由于DNS服务器会有缓存，该IP仍然会在DNS中保留一段时间，那么就会导致一部分用户无法正常访问网站。这是一个致命的问题！好在这个问题可以用动态DNS来解决。<br><br><br>动态DNS能够让我们通过程序动态修改DNS服务器中的域名解析。从而当我们的监控程序发现某台服务器挂了之后，能立即通知DNS将其删掉。<br><br></p><h4 id="反向代理负载均衡"><a href="#反向代理负载均衡" class="headerlink" title="反向代理负载均衡"></a>反向代理负载均衡</h4><p>反向代理服务器是一个位于实际服务器之前的服务器，所有向我们网站发来的请求都首先要经过反向代理服务器，服务器根据用户的请求要么直接将结果返回给用户，要么将请求交给后端服务器处理，再返回给用户。<br><br><br>之前我们介绍了用反向代理服务器实现静态页面和常用的动态页面的缓存。接下来我们介绍反向代理服务器更常用的功能——实现负载均衡。<br><br><br>我们知道，所有发送给我们网站的请求都首先经过反向代理服务器。那么，反向代理服务器就可以充当服务器集群的调度者，它可以根据当前后端服务器的负载情况，将请求转发给一台合适的服务器，并将处理结果返回给用户。<br><br></p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>隐藏后端服务器。</li><li>与HTTP重定向相比，反向代理能够隐藏后端服务器，所有浏览器都不会与后端服务器直接交互，从而能够确保调度者的控制权，提升集群的整体性能。<br>故障转移</li><li>与DNS负载均衡相比，反向代理能够更快速地移除故障结点。当监控程序发现某一后端服务器出现故障时，能够及时通知反向代理服务器，并立即将其删除。<br>合理分配任务</li><li><p>HTTP重定向和DNS负载均衡都无法实现真正意义上的负载均衡，也就是调度服务器无法根据后端服务器的实际负载情况分配任务。但反向代理服务器支持手动设定每台后端服务器的权重。我们可以根据服务器的配置设置不同的权重，权重的不同会导致被调度者选中的概率的不同。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5></li><li><p>调度者压力过大</p></li><li>由于所有的请求都先由反向代理服务器处理，那么当请求量超过调度服务器的最大负载时，调度服务器的吞吐率降低会直接降低集群的整体性能。<br>制约扩展</li><li>当后端服务器也无法满足巨大的吞吐量时，就需要增加后端服务器的数量，可没办法无限量地增加，因为会受到调度服务器的最大吞吐量的制约。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Nginx是啥&quot;&gt;&lt;a href=&quot;#Nginx是啥&quot; class=&quot;headerlink&quot; title=&quot;Nginx是啥&quot;&gt;&lt;/a&gt;Nginx是啥&lt;/h3&gt;&lt;p&gt;Nginx是一个使用c语言开发的高性能http服务器以及反向代理服务器。Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。&lt;br&gt;
    
    </summary>
    
      <category term="学习" scheme="http://xuyonglin222.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="http://xuyonglin222.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>choppingHand2</title>
    <link href="http://xuyonglin222.github.io/2018/06/15/choppingHand2/"/>
    <id>http://xuyonglin222.github.io/2018/06/15/choppingHand2/</id>
    <published>2018-06-15T05:07:12.000Z</published>
    <updated>2019-07-29T09:43:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这段时间把剩下的界面写完了，界面如下：<br><a id="more"></a><br><br><br>商品详情界面<br><br><br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/good.png" alt><br><br><br>购物车<br><br><br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/cart.png" alt><br><br><br>收藏<br><br></p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/like.png" alt><br><br><br>个人详情界面<br><br><br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/mine.png" alt><br><br><br>订单界面<br><br><br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/order.png" alt></p><p>期间完善了一下首页轮播图以及tab组件图片偶尔不能显示的问题，查了一下资料，原来<br>react-native-swiper还有react-native-scrollable-tab-view，这两个东西需要手动重新渲染界面,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            swipeShow: <span class="literal">false</span>,</span><br><span class="line">            store:[]</span><br><span class="line">        &#125;;</span><br><span class="line">        this.txt = null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillMount</span></span>() &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                swipeShow: <span class="literal">true</span>,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">renderSwiper</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;Swiper style=&#123;styles.swiper&#125; autoplay=&#123;<span class="literal">true</span>&#125; showsButtons&gt;</span><br><span class="line">                &lt;View style=&#123;styles.slideShow&#125;&gt;</span><br><span class="line">                    &lt;Image style=&#123;styles.banner&#125; <span class="built_in">source</span>=&#123;require(<span class="string">'../../images/slide1.jpg'</span>)&#125;/&gt;</span><br><span class="line">                &lt;/View&gt;</span><br><span class="line">                &lt;View style=&#123;styles.slideShow&#125;&gt;</span><br><span class="line">                    &lt;Image style=&#123;styles.banner&#125; <span class="built_in">source</span>=&#123;require(<span class="string">'../../images/slide2.jpg'</span>)&#125;/&gt;</span><br><span class="line">                &lt;/View&gt;</span><br><span class="line">                &lt;View style=&#123;styles.slideShow&#125;&gt;</span><br><span class="line">                    &lt;Image style=&#123;styles.banner&#125; <span class="built_in">source</span>=&#123;require(<span class="string">'../../images/slide3.jpg'</span>)&#125;/&gt;</span><br><span class="line">                &lt;/View&gt;</span><br><span class="line">            &lt;/Swiper&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">//...</span><br><span class="line">              &lt;View style=&#123;&#123;width: width, height: 150,&#125;&#125;&gt;</span><br><span class="line">                  &#123;this.state.swipeShow &amp;&amp; this.renderSwiper()&#125;</span><br><span class="line">                &lt;/View&gt;</span><br></pre></td></tr></table></figure><p>同理react-native-scrollable-tab-view也是同样的解决方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这段时间把剩下的界面写完了，界面如下：&lt;br&gt;
    
    </summary>
    
      <category term="学习" scheme="http://xuyonglin222.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="React Native" scheme="http://xuyonglin222.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>choppingHand1</title>
    <link href="http://xuyonglin222.github.io/2018/06/08/choppingHand1/"/>
    <id>http://xuyonglin222.github.io/2018/06/08/choppingHand1/</id>
    <published>2018-06-08T04:38:50.000Z</published>
    <updated>2019-07-29T09:43:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>每次新学一种框架，实战要么todoList，要么购物应用，哈哈哈哈。</p></blockquote><a id="more"></a><p>今天</p><p>写了几个界面，登录注册啥的。界面如下：<br><br><br>注册界面<br><br><br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/register.png" alt><br><br><br>登录界面<br><br><br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/login.png" alt><br><br><br>首页<br><br><br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/home.png" alt></p><p>顺手把页面逻辑跳转写了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">const Tab = TabNavigator(&#123;</span><br><span class="line">        Home: &#123;</span><br><span class="line">            screen: HomeView,</span><br><span class="line">            navigationOptions: &#123;</span><br><span class="line">                tabBarLabel: <span class="string">'首页'</span>,</span><br><span class="line">                tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; (</span><br><span class="line">                    &lt;TabBarItem</span><br><span class="line">                        tintColor=&#123;tintColor&#125;</span><br><span class="line">                        focused=&#123;focused&#125;</span><br><span class="line">                        selectedImage=&#123;require(<span class="string">'./images/homeSelect.png'</span>)&#125;</span><br><span class="line">                        normalImage=&#123;require(<span class="string">'./images/home.png'</span>)&#125;</span><br><span class="line">                    /&gt;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        Cart: &#123;</span><br><span class="line">            screen: CartView,</span><br><span class="line">            navigationOptions: &#123;</span><br><span class="line">                tabBarLabel: <span class="string">'购物车'</span>,</span><br><span class="line">                tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; (</span><br><span class="line">                    &lt;TabBarItem</span><br><span class="line">                        tintColor=&#123;tintColor&#125;</span><br><span class="line">                        focused=&#123;focused&#125;</span><br><span class="line">                        selectedImage=&#123;require(<span class="string">'./images/cartSelect.png'</span>)&#125;</span><br><span class="line">                        normalImage=&#123;require(<span class="string">'./images/cart.png'</span>)&#125;</span><br><span class="line">                    /&gt;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        Mine: &#123;</span><br><span class="line">            screen: MineView,</span><br><span class="line">            navigationOptions: &#123;</span><br><span class="line">                tabBarLabel: <span class="string">'我'</span>,</span><br><span class="line">                tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; (</span><br><span class="line">                    &lt;TabBarItem</span><br><span class="line">                        tintColor=&#123;tintColor&#125;</span><br><span class="line">                        focused=&#123;focused&#125;</span><br><span class="line">                        selectedImage=&#123;require(<span class="string">'./images/mineSelect.png'</span>)&#125;</span><br><span class="line">                        normalImage=&#123;require(<span class="string">'./images/mine.png'</span>)&#125;</span><br><span class="line">                    /&gt;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // tabScreen配置</span><br><span class="line">    &#123;</span><br><span class="line">        tabBarComponent: TabBarBottom, // 自定义</span><br><span class="line">        tabBarPosition: <span class="string">'bottom'</span>,</span><br><span class="line">        swipeEnabled: <span class="literal">false</span>,</span><br><span class="line">        animationEnabled: <span class="literal">true</span>,</span><br><span class="line">        lazy: <span class="literal">true</span>,</span><br><span class="line">        tabBarOptions: &#123;</span><br><span class="line">            activeTintColor: <span class="string">'#e5779c'</span>,</span><br><span class="line">            inactiveTintColor: <span class="string">'#71777c'</span>,</span><br><span class="line">            labelStyle: &#123;</span><br><span class="line">                fontSize: 12, // 文字大小</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const Stack =StackNavigator(</span><br><span class="line">    &#123;</span><br><span class="line">        Login: &#123;</span><br><span class="line">            screen: LoginView,</span><br><span class="line">            navigationOptions: &#123;</span><br><span class="line">                header: null</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        Tab: &#123;</span><br><span class="line">            screen: Tab,</span><br><span class="line">        &#125;,</span><br><span class="line">        GoodPage:&#123;</span><br><span class="line">            screen: GoodPageView,</span><br><span class="line">        &#125;,</span><br><span class="line">        Register: &#123;</span><br><span class="line">            screen: RegisterView,</span><br><span class="line">            navigationOptions: &#123;</span><br><span class="line">                header: null</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        navigationOptions: &#123;</span><br><span class="line">            // 开启动画</span><br><span class="line">            animationEnabled: <span class="literal">true</span>,</span><br><span class="line">            // 开启边缘触摸返回</span><br><span class="line">            gesturesEnabled: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        mode: <span class="string">'card'</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>刚起了个头，发现用React Native写Android用的还是网站那一套，也不是那么的好玩。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;每次新学一种框架，实战要么todoList，要么购物应用，哈哈哈哈。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习" scheme="http://xuyonglin222.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="React Native" scheme="http://xuyonglin222.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>ReactNativeComponent</title>
    <link href="http://xuyonglin222.github.io/2018/06/01/ReactNativeComponent/"/>
    <id>http://xuyonglin222.github.io/2018/06/01/ReactNativeComponent/</id>
    <published>2018-06-01T03:53:02.000Z</published>
    <updated>2019-07-29T09:43:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>最近在玩React Native，话说React Native的环境真的烂啊，莫名其妙就崩了一次一次又一次。<br>初学了一些东西，做个总结。<br><a id="more"></a></p></blockquote><h3 id="AppRegistry"><a href="#AppRegistry" class="headerlink" title="AppRegistry"></a>AppRegistry</h3><p>AppRegistry是JS运行所有React Native应用的入口。应用的根组件应当通过AppRegistry.registerComponent方法注册自己，然后原生系统才可以加载应用的代码包并且在启动完成之后通过调用AppRegistry.runApplication来真正运行应用。<br>要“结束”一个应用并销毁视图的话，请调用AppRegistry.unmountApplicationComponentAtRootTag方法，参数为在runApplication中使用的标签名。它们必须严格匹配。<br>AppRegistry应当在require序列中尽可能早的被require到，以确保JS运行环境在其它模块之前被准备好。</p><h3 id="StyleSheet"><a href="#StyleSheet" class="headerlink" title="StyleSheet"></a>StyleSheet</h3><p>StyleSheet提供了一种类似CSS样式表的抽象。<br>创建一个样式表：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var styles = StyleSheet.create(&#123;</span><br><span class="line">  container: &#123;</span><br><span class="line">    borderRadius: 4,</span><br><span class="line">    borderWidth: 0.5,</span><br><span class="line">    borderColor: <span class="string">'#d6d7da'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  title: &#123;</span><br><span class="line">    fontSize: 19,</span><br><span class="line">    fontWeight: <span class="string">'bold'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  activeTitle: &#123;</span><br><span class="line">    color: <span class="string">'red'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>使用一个样式表：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">  &lt;Text style=&#123;[styles.title, this.props.isActive &amp;&amp; styles.activeTitle]&#125; /&gt;</span><br><span class="line">&lt;/View&gt;</span><br></pre></td></tr></table></figure></p><p>从代码质量角度：<br>从render函数中移除具体的样式内容，可以使代码更清晰易懂。<br>给样式命名也是对render函数中的原始组件的作用的一种标记。<br>从性能角度：<br>创建一个样式表，就可以使得我们后续更容易通过ID来引用样式，而不是每次都创建一个新的对象。<br>它还使得样式只会在JavaScript和原生之间传递一次，随后的过程都可以只传递一个ID（这个优化还未实现）。<br>注意：create() 和 hairlineWidth<br>这一常量定义了当前平台上的最细的宽度。可以用作边框或是两个元素间的分隔线。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    borderBottomColor: <span class="string">'#bbb'</span>,</span><br><span class="line">    borderBottomWidth: StyleSheet.hairlineWidth</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这一常量始终是一个整数的像素值（线看起来会像头发丝一样细），并会尽量符合当前平台最细的线的标准。然而，你不能把它“视为一个常量”，因为不同的平台和不同的屏幕像素密度会导致不同的结果。</p><h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h3><p>一个用于显示文本的React组件，并且它也支持嵌套、样式，以及触摸处理。<br>Android内建的字体有:</p><ul><li>normal</li><li>serif</li><li>monospace <br></li></ul><p>\<text>元素在布局上不同于其它组件：在Text内部的元素不再使用flexbox布局，而是采用文本布局。这意味着\<text>内部的元素不再是一个个矩形，而可能会在行末进行折叠。<br>\<text>元素在布局上不同于其它组件：在Text内部的元素不再使用flexbox布局，而是采用文本布局。这意味着\<text>内部的元素不再是一个个矩形，而可能会在行末进行折叠。<br>你必须把你的文本节点放在\<text>组件内。你不能直接在\<view>下放置一段文本。</view></text></text></text></text></text></p><h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><h4 id="宽、高尺寸设置"><a href="#宽、高尺寸设置" class="headerlink" title="宽、高尺寸设置"></a>宽、高尺寸设置</h4><ul><li>Image 组件必须在样式中声明图片的宽和高。如果没有声明，则图片将不会被呈现在界面上。</li><li>有时我们需要将某张图片点对点地显示在手机上，如果我们知道图片实际分辨率（比如：actrualWidth * actrualHeight），那么可以使用如下方式定义图片显示样式：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">preciseImageStyle: &#123;</span><br><span class="line">  width: actrualWidth / PixelRatio.get(),</span><br><span class="line">  height: actrualHeight / PixelRatio.get(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Image组件的常见属性"><a href="#Image组件的常见属性" class="headerlink" title="Image组件的常见属性"></a>Image组件的常见属性</h4><ul><li><p>onLayout(function) <br><br>当Image布局发生改变的，会进行调用该方法，调用的代码为:{nativeEvent: {layout: {x, y, width, height}}}.</p></li><li><p>onLoad (function)  <br><br>当图片加载成功之后，回调该方法</p></li><li><p>onLoadEnd (function)  <br><br>当图片加载失败回调该方法，该不会管图片加载成功还是失败</p></li><li>onLoadStart (fcuntion)  <br><br>当图片开始加载的时候调用该方法</li><li>resizeMode  <br><br>缩放比例,可选参数(‘cover’, ‘contain’, ‘stretch’) 该当图片的尺寸超过布局的尺寸的时候，会根据设置Mode进行缩放或者裁剪图片</li><li>source{uri:string}  <br><br>进行标记图片的引用，该参数可以为一个网络url地址或者一个本地的路径<br>它可以接收一个数组作为参数，这样可根据组件的宽和高自动加载与之匹配的宽和高的图片。使用方式如下:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Image</span><br><span class="line">               style=&#123;&#123;flex: 1&#125;&#125;</span><br><span class="line">               <span class="built_in">source</span>=&#123;[</span><br><span class="line">                  &#123;uri:<span class="string">'https://facebook.github.io/react/img/logo_small.png'</span>, width: 38, height: 38&#125;,</span><br><span class="line">                 &#123;uri: <span class="string">'https://facebook.github.io/react/img/logo_small_2x.png'</span>, width: 76, height: 76&#125;,</span><br><span class="line">                 &#123;uri: <span class="string">'https://facebook.github.io/react/img/logo_og.png'</span>, width: 400, height: 400&#125;</span><br><span class="line">                       ]&#125;</span><br><span class="line">                   /&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>作为创建UI时最基础的组件，View是一个支持Flexbox布局、样式、一些触摸处理、和一些无障碍功能的容器，并且它可以放到其它的视图里，也可以有任意多个任意类型的子视图。不论在什么平台上，View都会直接对应一个平台的原生视图，无论它是UIView、\<div>还是android.view.View。<br>View的设计初衷是和StyleSheet搭配使用，这样可以使代码更清晰并且获得更高的性能。尽管内联样式也同样可以使用。</div></p><h4 id="accessible-bool"><a href="#accessible-bool" class="headerlink" title="accessible bool"></a>accessible bool</h4><p>当此属性为true时，表示此视图时一个启用了无障碍功能的元素。默认情况下，所有可触摸操作的元素都是无障碍功能元素。</p><p>如果要为View添加普通点击事件，请直接使用Touchable系列组件替代View，然后添加onPress函数。</p><h4 id="onResponderMove-function"><a href="#onResponderMove-function" class="headerlink" title="onResponderMove function"></a>onResponderMove function</h4><p>当用户正在屏幕上移动手指时调用这个函数</p><h3 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h3><p>一个简单的跨平台的按钮组件。可以进行一些简单的定制。<br>disabled bool<br>设置为true时此按钮将不可点击</p><p> title: PropTypes.string.isRequired,<br>Platform.OS === ‘android’ ? title.toUpperCase() : title;</p><h3 id="FlatList"><a href="#FlatList" class="headerlink" title="FlatList"></a>FlatList</h3><p>FlatList组件用于显示一个垂直的滚动列表，其中的元素之间结构近似而仅数据不同。<br>FlatList组件必须的两个属性是data和renderItem。data是列表的数据源，而renderItem则从数据源中逐个解析数据，然后返回一个设定好格式的组件来渲染。<br>FlatList更适于长列表数据，且元素个数可以增删。和ScrollView不同的是，FlatList并不立即渲染所有元素，而是优先渲染屏幕上可见的元素。</p><h3 id="SectionList"><a href="#SectionList" class="headerlink" title="SectionList"></a>SectionList</h3><p>如果要渲染的是一组需要分组的数据，也许还带有分组标签的，那么SectionList将是个不错的选择。</p><h3 id="TouchableOpacity"><a href="#TouchableOpacity" class="headerlink" title="TouchableOpacity"></a>TouchableOpacity</h3><p>本组件用于封装视图，使其可以正确响应触摸操作。当按下的时候，封装的视图的不透明度会降低。这个过程并不会真正改变视图层级，大部分情况下很容易添加到应用中而不会带来一些奇怪的副作用。<br>此组件与TouchableHighlight的区别在于并没有额外的颜色变化，更适于一般场景</p><h3 id="TouchableHighlight"><a href="#TouchableHighlight" class="headerlink" title="TouchableHighlight"></a>TouchableHighlight</h3><p><em>注意：TouchableHighlight只支持一个子节点<br>如果你希望包含多个子组件，用一个View来包装它们。</em></p><h3 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h3><p>一个包装了平台的ScrollView（滚动视图）的组件，同时还集成了触摸锁定的“响应者”系统。<br>ScrollView和ListView/FlatList应该如何选择？<br>ScrollView会简单粗暴地把所有子元素一次性全部渲染出来。ListView会惰性渲染子元素，只在它们将要出现在屏幕中时开始渲染。FlatList是0.43版本开始新出的改进版的ListView，性能更优。</p><h4 id="horizontal-bool"><a href="#horizontal-bool" class="headerlink" title="horizontal bool"></a>horizontal bool</h4><p>当此属性为true的时候，所有的子视图会在水平方向上排成一行，而不是默认的在垂直方向上排成一列。默认值为false。</p><h4 id="pagingEnabled-bool"><a href="#pagingEnabled-bool" class="headerlink" title="pagingEnabled bool"></a>pagingEnabled bool</h4><p>当值为true时，滚动条会停在滚动视图的尺寸的整数倍位置。这个可以用在水平分页上。默认值为false。</p><h4 id="showsHorizontalScrollIndicator-bool"><a href="#showsHorizontalScrollIndicator-bool" class="headerlink" title="showsHorizontalScrollIndicator bool"></a>showsHorizontalScrollIndicator bool</h4><p>当此属性为true的时候，显示一个水平方向的滚动条。</p><h3 id="Dimensions"><a href="#Dimensions" class="headerlink" title="Dimensions"></a>Dimensions</h3><p>本模块用于获取设备屏幕的宽高<br>例子：var {height, width} = Dimensions.get(‘window’);</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在玩React Native，话说React Native的环境真的烂啊，莫名其妙就崩了一次一次又一次。&lt;br&gt;初学了一些东西，做个总结。&lt;br&gt;
    
    </summary>
    
      <category term="学习" scheme="http://xuyonglin222.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="React Native" scheme="http://xuyonglin222.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>friendships</title>
    <link href="http://xuyonglin222.github.io/2018/05/23/friendships/"/>
    <id>http://xuyonglin222.github.io/2018/05/23/friendships/</id>
    <published>2018-05-23T04:03:10.000Z</published>
    <updated>2019-07-29T09:43:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>发现一个小技巧，把视频先传到抖音或者其他平台上去，平台应该会帮你压缩处理，然后下载下来，放到CDN上，就不会这么大了，哈哈哈哈哈。<br></p><p>之前跟着潇潇指弹的视频，学了一下抖音上比较火的friendship，还挺有意思，就放上来，玩一下，嘻嘻嘻嘻。<br><a id="more"></a></p><div style="width:100%;"><br><div style="transform: rotate(-90deg);margin-left: 28%; width: 50%;margin-top: -125px;"><br><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/friendships.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><br><br></div><br></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现一个小技巧，把视频先传到抖音或者其他平台上去，平台应该会帮你压缩处理，然后下载下来，放到CDN上，就不会这么大了，哈哈哈哈哈。&lt;br&gt;&lt;/p&gt;
&lt;p&gt;之前跟着潇潇指弹的视频，学了一下抖音上比较火的friendship，还挺有意思，就放上来，玩一下，嘻嘻嘻嘻。&lt;br&gt;
    
    </summary>
    
      <category term="指弹" scheme="http://xuyonglin222.github.io/categories/%E6%8C%87%E5%BC%B9/"/>
    
    
      <category term="指弹" scheme="http://xuyonglin222.github.io/tags/%E6%8C%87%E5%BC%B9/"/>
    
  </entry>
  
  <entry>
    <title>流行的云</title>
    <link href="http://xuyonglin222.github.io/2018/05/20/%E6%B5%81%E8%A1%8C%E7%9A%84%E4%BA%91/"/>
    <id>http://xuyonglin222.github.io/2018/05/20/流行的云/</id>
    <published>2018-05-20T08:41:37.000Z</published>
    <updated>2019-07-29T09:43:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>又到了周末啊，时间过得真快，今天看了看正则表达式，手痒啊，把之前学的流行的云录下来，好久没碰吉他了啊。</p><a id="more"></a><div id="dplayer2" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer2"),"theme":"#FADFA3","loop":true,"video":{"url":"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/Cloud.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又到了周末啊，时间过得真快，今天看了看正则表达式，手痒啊，把之前学的流行的云录下来，好久没碰吉他了啊。&lt;/p&gt;
    
    </summary>
    
      <category term="指弹" scheme="http://xuyonglin222.github.io/categories/%E6%8C%87%E5%BC%B9/"/>
    
    
      <category term="指弹" scheme="http://xuyonglin222.github.io/tags/%E6%8C%87%E5%BC%B9/"/>
    
  </entry>
  
  <entry>
    <title>time travel</title>
    <link href="http://xuyonglin222.github.io/2018/04/29/timetravel/"/>
    <id>http://xuyonglin222.github.io/2018/04/29/timetravel/</id>
    <published>2018-04-29T12:50:28.000Z</published>
    <updated>2019-07-29T09:43:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>如果有一天，不再敲代码，就去一家山清水秀的小城市开个小吉他店。</p></blockquote><a id="more"></a><p>喜欢岸部真明就是从这首曲子开始的，大学时光匆匆流逝，虽然有点吵，确实记录了大学一角，我的室友，我的吉他，我的音响，还有那些遗憾和憧憬。<br>(录得效果不好)</p><div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"theme":"#FADFA3","loop":true,"video":{"url":"https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VID20180416232819.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;如果有一天，不再敲代码，就去一家山清水秀的小城市开个小吉他店。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="指弹" scheme="http://xuyonglin222.github.io/categories/%E6%8C%87%E5%BC%B9/"/>
    
    
      <category term="指弹" scheme="http://xuyonglin222.github.io/tags/%E6%8C%87%E5%BC%B9/"/>
    
  </entry>
  
  <entry>
    <title>从源码看vue的lifecycle</title>
    <link href="http://xuyonglin222.github.io/2018/04/29/Vue-lifecycle/"/>
    <id>http://xuyonglin222.github.io/2018/04/29/Vue-lifecycle/</id>
    <published>2018-04-29T05:47:53.000Z</published>
    <updated>2019-07-29T09:43:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>又到了写文章的deadline，其实已经拖了有段时间了，聊聊Vue的生命周期。</p></blockquote><a id="more"></a><p>话不多说，先来张图。<br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/lifecycle.png" alt><br>熟悉吧！ 没错，这张图来自官网。我记得一开始学习Vue的时候，看到这张图，就晕，啥意思啊，不懂。<br>知道最近，再看Vue的源码的时候（看了有一段时间了，分模块进行的），产生了强烈的共鸣。</p><h3 id="阅读技巧"><a href="#阅读技巧" class="headerlink" title="阅读技巧"></a>阅读技巧</h3><p>这是题外话，关于阅读源码，也算有点经验了，记得之前看Jquery的源码时，我擦嘞9000+行（得嘞，我还是歇着吧），买了本书，《Jquery技术内幕》，看了目录才知道，其实框架都是按模块开发的，而jquery先从架构开始<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(window, undefined) &#123;</span><br><span class="line">    var  jQuery = <span class="keyword">function</span>(selector, context) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> new jQuery.fn.init(selector, context, rootjQuery);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line"></span><br><span class="line">        init: <span class="keyword">function</span>(selector, context, rootjQuery) &#123;</span><br><span class="line">            // ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jQuery.fn.init.prototype = jQuery.fn;</span><br><span class="line"></span><br><span class="line">&#125;)(window);</span><br></pre></td></tr></table></figure></p><p>然后结合书籍，或者直接看源码（头晕），可以借助Webstorm编辑器的ctrl+鼠标左键，进行函数跳转，一定要先把某些函数缩进起来，便于阅读，个人认为，可以先适当了解它的私有函数，比如pushStack，makeArray，merage等方法，因为jquery暴露出的api，其实用到了很多这样的方法。</p><p>而Vue和react这类框架，建议去阅读它的真正源码而不是压缩后的，可以再node_modules里找到，Vue的结构是这样的。<br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/VueYM.png" alt><br>而入口文件是 core/index.js</p><h3 id="正文开始"><a href="#正文开始" class="headerlink" title="正文开始"></a>正文开始</h3><p>core/index.js源码如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//Vue的核心方法</span><br><span class="line">import Vue from <span class="string">'./instance/index'</span></span><br><span class="line">//初始化全局API</span><br><span class="line">import &#123; initGlobalAPI &#125; from <span class="string">'./global-api/index'</span></span><br><span class="line">//获取布尔值变量判断是不是SSR</span><br><span class="line">import &#123; isServerRendering &#125; from <span class="string">'core/util/env'</span></span><br><span class="line">// 初始化全局变量</span><br><span class="line">initGlobalAPI(Vue)</span><br><span class="line">// 为Vue原型定义属性<span class="variable">$isServer</span></span><br><span class="line">Object.defineProperty(Vue.prototype, <span class="string">'$isServer'</span>, &#123;</span><br><span class="line">    get: isServerRendering</span><br><span class="line">&#125;)</span><br><span class="line">// 为Vue原型定义属性<span class="variable">$ssrContext</span></span><br><span class="line">Object.defineProperty(Vue.prototype, <span class="string">'$ssrContext'</span>, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span></span> () &#123;</span><br><span class="line">        /* istanbul ignore next */</span><br><span class="line">        <span class="built_in">return</span> this.<span class="variable">$vnode</span> &amp;&amp; this.<span class="variable">$vnode</span>.ssrContext</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.version = <span class="string">'__VERSION__'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default Vue</span><br></pre></td></tr></table></figure><p>emmmm，感觉被欺骗了，好像啥都没有的样子。于是Ctrl+鼠标左键点击  ‘./instance/index’,(凭直觉，这里应该有东西)<br><br><br>./instance/index<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import &#123; initMixin &#125; from <span class="string">'./init'</span></span><br><span class="line">import &#123; stateMixin &#125; from <span class="string">'./state'</span></span><br><span class="line">import &#123; renderMixin &#125; from <span class="string">'./render'</span></span><br><span class="line">import &#123; eventsMixin &#125; from <span class="string">'./events'</span></span><br><span class="line">import &#123; lifecycleMixin &#125; from <span class="string">'./lifecycle'</span></span><br><span class="line">import &#123; warn &#125; from <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Vue (options) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(this instanceof Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  this._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//为Vue的原型扩展_init方法</span><br><span class="line">initMixin(Vue)</span><br><span class="line"></span><br><span class="line">//初始化<span class="variable">$data</span> <span class="variable">$props</span> <span class="variable">$set</span> <span class="variable">$delete</span>等</span><br><span class="line">stateMixin(Vue)</span><br><span class="line"></span><br><span class="line">//初始化<span class="variable">$on</span> <span class="variable">$once</span> <span class="variable">$off</span> <span class="variable">$emit</span>等函数</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line"></span><br><span class="line">//初始化_update <span class="variable">$forceUpdate</span> <span class="variable">$destroy</span>函数</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line"></span><br><span class="line">//初始化 <span class="variable">$nextTick</span> _render函数</span><br><span class="line">renderMixin(Vue)</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default Vue</span><br></pre></td></tr></table></figure></p><p>当Vue被实例化时好像只执行了_init方法，并为Vue的原型扩展了一些方法，OK进_init去看看</p><p>点击去之后发现他是在instance的目录下，而函数_init是在 initMixin里</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> initMixin (Vue: Class&lt;Component&gt;) &#123;</span><br><span class="line">  Vue.prototype._init = <span class="keyword">function</span> (options?: Object) &#123;</span><br></pre></td></tr></table></figure><p>initMixin就是再前文提到的./instance/index里被调用的。<br>其实接下来才开始和那张图有关系。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = <span class="keyword">function</span> (options?: Object) &#123;</span><br><span class="line">    const vm: Component = this</span><br><span class="line">    // a uid</span><br><span class="line">    vm._uid = uid++</span><br><span class="line"></span><br><span class="line">    <span class="built_in">let</span> startTag, endTag</span><br><span class="line">    /* istanbul ignore <span class="keyword">if</span> */</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      startTag = `vue-perf-start:<span class="variable">$&#123;vm._uid&#125;</span>`</span><br><span class="line">      endTag = `vue-perf-end:<span class="variable">$&#123;vm._uid&#125;</span>`</span><br><span class="line">      mark(startTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        // 如果是Vue的实例，则不需要被observe</span><br><span class="line">    vm._isVue = <span class="literal">true</span></span><br><span class="line">        // 第一步： options参数的处理</span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">      // optimize internal component instantiation</span><br><span class="line">      // since dynamic options merging is pretty slow, and none of the</span><br><span class="line">      // internal component options needs special treatment.</span><br><span class="line">      initInternalComponent(vm, options)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vm.<span class="variable">$options</span> = mergeOptions(</span><br><span class="line">        resolveConstructorOptions(vm.constructor),</span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">        // 第二步： renderProxy</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      initProxy(vm)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vm._renderProxy = vm</span><br><span class="line">    &#125;</span><br><span class="line">    // expose real self</span><br><span class="line">    vm._self = vm</span><br><span class="line">        // 第三步： vm的生命周期相关变量初始化</span><br><span class="line">    initLifecycle(vm)</span><br><span class="line">        // 第四步： vm的事件监听（v-on）初始化</span><br><span class="line">    initEvents(vm)</span><br><span class="line">    initRender(vm)</span><br><span class="line">    callHook(vm, <span class="string">'beforeCreate'</span>)</span><br><span class="line">    initInjections(vm) // resolve injections before data/props</span><br><span class="line">        // 第五步： vm的状态初始化，prop/data/computed/method/watch都在这里完成初始化，因此也是Vue实例create的关键。</span><br><span class="line">    initState(vm)</span><br><span class="line">    initProvide(vm) // resolve provide after data/props</span><br><span class="line">    callHook(vm, <span class="string">'created'</span>)</span><br><span class="line"></span><br><span class="line">    /* istanbul ignore <span class="keyword">if</span> */</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      vm._name = formatComponentName(vm, <span class="literal">false</span>)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(`vue <span class="variable">$&#123;vm._name&#125;</span> init`, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">        // 第六步：render &amp; mount</span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="variable">$options</span>.el) &#123;</span><br><span class="line">      vm.<span class="variable">$mount</span>(vm.<span class="variable">$options</span>.el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码中做了注释，</p><ul><li>第一步对option的merge处理是为了把业务逻辑以及组件的一些特性全都放到了vm.$options中，再里面复杂的逻辑先不看（容易头晕）。</li><li>第二步renderProxy，这是为后期render做准备的，作用是在render中将this指向vm._renderProxy。</li><li>第三步： vm的生命周期相关变量初始化，主要是建立组建的父子关系还有初始化组件的相关属性。这个时候已经可以开始看那张图了。</li><li>第四步  vm的事件监听（v-on）初始化以及将$attrs,$listeners进行响应式处理，然后调用出发beforeCreated钩子里的函数</li><li>第五步 将prop/data/computed/method/watch都在这里完成初始化以及响应式处理。</li></ul><p>因此，至少在created时才能拿到data等里面的值。<br></p><p>当数据都响应化，触发created之后，判断vm.$options.el是否存在，然后选择编译方式。</p><p>编译方式有两种：</p><ul><li>编译器:借助脚手架，将template的内容，通过parse，optimize，generate，编译成AST进而编译成render function字符串。</li></ul><p>然而，完整的编译还有一下过程：render function字符串通过调用render方法来一步步解析成VNode，最后通过patch函数转换成真实的DOM节点。</p><ul><li>运行时：去掉编译器的过程：render函数 → vnode → 真实dom节点。<br>（打把王者，回头再写，有点头疼）<br>loading…………………………………………………………………………..<br>王者打完了，接着写</li></ul><h2 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h2><p>解释一下图中在created和beforeMount之间的部分。<br>第一个分支：<br>如果我们在开发过程中，没有指定el挂载点，那么生命周期会暂时停止，只执行到created阶段，当然可以手动执行vm.$mount(el)，使暂停的生命周期进行下去。<br><br></p><p>第二个分支：<br>1.如果Vue实例对象中有template参数选项，则将其作为模板编译成render函数<br>2.如果没有template参数选项，则将外部的HTML作为模板编译（template），也就是说，template参数选项的优先级要比外部的HTML高<br>3.如果1,2条件都不具备，则报错</p><p>接着就调用beforeMount生命周期钩子<br><br><br>core/instance/lifecycle.js<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> mountComponent (</span><br><span class="line">  vm: Component,</span><br><span class="line">  el: ?Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  vm.<span class="variable">$el</span> = el</span><br><span class="line">  <span class="keyword">if</span> (!vm.<span class="variable">$options</span>.render) &#123;</span><br><span class="line">    vm.<span class="variable">$options</span>.render = createEmptyVNode</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      /* istanbul ignore <span class="keyword">if</span> */</span><br><span class="line">      <span class="keyword">if</span> ((vm.<span class="variable">$options</span>.template &amp;&amp; vm.<span class="variable">$options</span>.template.charAt(0) !== <span class="string">'#'</span>) ||</span><br><span class="line">        vm.<span class="variable">$options</span>.el || el) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'You are using the runtime-only build of Vue where the template '</span> +</span><br><span class="line">          <span class="string">'compiler is not available. Either pre-compile the templates into '</span> +</span><br><span class="line">          <span class="string">'render functions, or use the compiler-included build.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'Failed to mount component: template or render function not defined.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, <span class="string">'beforeMount'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> updateComponent</span><br><span class="line">  /* istanbul ignore <span class="keyword">if</span> */</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = () =&gt; &#123;</span><br><span class="line">      const name = vm._name</span><br><span class="line">      const id = vm._uid</span><br><span class="line">      const startTag = `vue-perf-start:<span class="variable">$&#123;id&#125;</span>`</span><br><span class="line">      const endTag = `vue-perf-end:<span class="variable">$&#123;id&#125;</span>`</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      const vnode = vm._render()</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(`vue <span class="variable">$&#123;name&#125;</span> render`, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(`vue <span class="variable">$&#123;name&#125;</span> patch`, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateComponent = () =&gt; &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // we <span class="built_in">set</span> this to vm._watcher inside the watcher<span class="string">'s constructor</span></span><br><span class="line"><span class="string">  // since the watcher'</span>s initial patch may call <span class="variable">$forceUpdate</span> (e.g. inside child</span><br><span class="line">  // component<span class="string">'s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line"><span class="string">  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */)</span></span><br><span class="line"><span class="string">  hydrating = false</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // manually mounted instance, call mounted on self</span></span><br><span class="line"><span class="string">  // mounted is called for render-created child components in its inserted hook</span></span><br><span class="line"><span class="string">  if (vm.$vnode == null) &#123;</span></span><br><span class="line"><span class="string">    vm._isMounted = true</span></span><br><span class="line"><span class="string">    callHook(vm, '</span>mounted<span class="string">')</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  return vm</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;又到了写文章的deadline，其实已经拖了有段时间了，聊聊Vue的生命周期。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习" scheme="http://xuyonglin222.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="vue" scheme="http://xuyonglin222.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>http学习总结</title>
    <link href="http://xuyonglin222.github.io/2018/04/19/http/"/>
    <id>http://xuyonglin222.github.io/2018/04/19/http/</id>
    <published>2018-04-19T05:30:30.000Z</published>
    <updated>2019-07-29T09:43:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>做一下http总结吧！！！</p></blockquote><a id="more"></a><h1 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h1><p>HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本—-HTTP 1.1。</p><p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p><p>HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。 对于这种无状态的链接也是有一些解决的方法的：</p><ul><li>对于保持登录状态，可以通过cookie技术，主要通过写入sessionID来实现的。</li><li>在HTTP1.1版本引入了keep-alive方法，只要任意一段没有明确表示出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接。</li><li>Websocket，这个玩意儿是基于HTTP的，就是借用了HTTP request建立长链接，之后的交换数据都不需要再发 HTTP request了，使得这个长连接变成了一个真.长连接。</li><li>管线化，主要是因为它不会等待一个请求得到响应之后，才去发送下一个请求，当请求数越多，它的速度之快表现的越明显。</li></ul><p><br><br><br><br></p><p>一次http链接的生命周期，基本包括请求和响应。</p><h1 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h1><p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成。</p><h2 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h2><p>请求行分为三个部分：请求方法、请求地址和协议版本.</p><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>从服务端获取资源</td></tr><tr><td>POST</td><td>用来传输实体的主题</td></tr><tr><td>HEAD</td><td>获得报文首部，一般用来确认URI的有效性和资源更新的日期时间等</td></tr><tr><td>OPTIONS</td><td>询问支持的方法</td></tr><tr><td>PUT</td><td>传输文件，要求在请求报文的主体中包含文件内容，然后保存在请求URI的主题位置（鉴于安全问题一般不使用）</td></tr><tr><td>DELETE</td><td>按请求URI删除指定文件</td></tr><tr><td>TRACE</td><td>追踪路径，易引发XST（跨站攻击），不常用</td></tr></tbody></table><h3 id="请求地址"><a href="#请求地址" class="headerlink" title="请求地址"></a>请求地址</h3><p>URL：统一资源定位符 组成包括协议、域名/主机、端口号、路径、参数啥的。</p><p>说一下URL和URI的区别： URI是Uniform Resource Identifier的缩写，就是由某个协议方案表示的资源的定位标识符（即协议类型的名称）。 URI用字符串标识某一互联网资源，而URL表示资源的地方，所以URL是URI的子集。</p><h3 id="协议版本"><a href="#协议版本" class="headerlink" title="协议版本"></a>协议版本</h3><p>常用的有HTTP1.0和HTTP1.1，貌似HTTP2.0应用还很少。昨天爱奇艺笔试我记得有一道选择题问HTTP2.0有什么特点。查了资料大概如下：</p><ul><li>多路复用<br><br>2.0新增了一个二进制分帧层的东西，在二进制分帧层上， HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。</li><li>头部压缩<br><br>当客户端向同一个服务器请求很多东西看上去产不多的，会采用压缩技术处理这些相似的信息。</li><li>随时复位<br><br>HTTP1.1一个缺点是当HTTP信息有一定长度大小数据传输时，你不能方便地随时停止它，中断TCP连接的代价是昂贵的。使用HTTP2的RST_STREAM将能方便停止一个信息传输，启动新的信息，在不中断连接的情况下提高带宽利用效率。</li><li>服务器端推流: Server Push<br><br>客户端请求一个资源X，服务器端判断也许客户端还需要资源Z，在无需事先询问客户端情况下将资源Z推送到客户端，客户端接受到后，可以缓存起来以备后用。</li><li>优先权和依赖<br><br>每个流都有自己的优先级别，会表明哪个流是最重要的，客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。</li></ul><h2 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h2><p>请求头部是由键值对组成。包括通用首部字段，请求首部字段和实体首部字段</p><h3 id="通用请求首部"><a href="#通用请求首部" class="headerlink" title="通用请求首部"></a>通用请求首部</h3><table><thead><tr><th>首部</th><th>描述</th></tr></thead><tbody><tr><td>Connection</td><td>允许客户端和服务器指定与请求/响应连接有关的选项</td></tr><tr><td>Date</td><td>提供日期和时间标志，说明报文是什么时间创建的</td></tr><tr><td>MIME-Version</td><td>给出了发送短使用的 MINE 版本</td></tr><tr><td>Trailer</td><td>如果报文采用了分块传输编码(chunked transfer encoding)方式，就可以用这个首部列出位于报文拖挂(trailer)部分的首部集合</td></tr><tr><td>Transfer-Encoding</td><td>告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式</td></tr><tr><td>Update</td><td>给出了发送端可能想要”升级”使用的新版本或协议</td></tr><tr><td>Via</td><td>显示报文经过的中间节点（代理、网关）</td></tr></tbody></table><h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Accept</td><td>用户代理可处理的媒体类型</td></tr><tr><td>Accept-Charset</td><td>优先的字符集</td></tr><tr><td>Accept-Encoding</td><td>优先的内容编码</td></tr><tr><td>Accept-Language</td><td>有限的语言</td></tr><tr><td>Authorization</td><td>Web认证信息</td></tr><tr><td>Expect</td><td>期待副武器的特定行为</td></tr><tr><td>from</td><td>用户的电子邮件地址</td></tr><tr><td>Host</td><td>请求资源所在服务器</td></tr><tr><td>If-Match</td><td>比较实体标记ETag</td></tr><tr><td>If-Modified-Sincce</td><td>比较资源的更新时间</td></tr><tr><td>If-None-Match</td><td>比较实体标记与If-Match相反</td></tr><tr><td>If-Range</td><td>资源委更新时发送实体Byte的范围请求</td></tr><tr><td>If-Unmodified-Since</td><td>比较资源的更新时间 与 If-Modified-Sincce相反</td></tr><tr><td>Max-Forwards</td><td>最大传输逐跳数</td></tr><tr><td>Proxy-Authorization</td><td>代理服务器要求客户端的认证消息</td></tr><tr><td>Range</td><td>实体的字节范围请求</td></tr><tr><td>Referer</td><td>队请求中URI的原始获取方法</td></tr><tr><td>TE</td><td>传输编码的优先级</td></tr><tr><td>User-Agent</td><td>HTTP客户端程序的信息</td></tr></tbody></table><blockquote><p>从今以后请称呼在下位为前端打字员，谢谢</p></blockquote><h3 id="实体首部"><a href="#实体首部" class="headerlink" title="实体首部"></a>实体首部</h3><table><thead><tr><th>首部</th><th>描述</th></tr></thead><tbody><tr><td>Allow</td><td>列出可以对此事提执行的请求方法</td></tr><tr><td>Location</td><td>告知客户端实际上位于何处；用于将接收端定向到资源的(可能是新的)位置(URL)上去</td></tr><tr><td>Content-Base</td><td>解释主体中的相对 URL 时使用的基础 URL</td></tr><tr><td>Content-Encoding</td><td>对主体执行的任意编码方式</td></tr><tr><td>Content-Language</td><td>理解主体时最适宜使用的自然语言</td></tr><tr><td>Content-Length</td><td>主体的长度或尺寸</td></tr><tr><td>Content-Locaton</td><td>资源实际所处的位置</td></tr><tr><td>Content-MD5</td><td>主体的 MD5 校验和</td></tr><tr><td>Content-Range</td><td>在整个资源中此实体表示的字节范围</td></tr><tr><td>Content-Type</td><td>在这个主体的对象类型</td></tr><tr><td>ETag</td><td>与此实体相关的实体标记</td></tr><tr><td>Expires</td><td>实体不再有效，要从原始的源端再次获取此实体的日期和时间</td></tr><tr><td>Last-Modified</td><td>这个实体最后一次被修改的日期和时间</td></tr></tbody></table><h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>即使第四部分的请求数据为空，也必须有空行。</p><h2 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h2><p>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p><h1 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h1><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p><h2 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h2><p>状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</p><p>说一下状态码（复制粘贴的）</p><table><thead><tr><th>状态码</th><th>含义</th></tr></thead><tbody><tr><td>100</td><td>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</td></tr><tr><td>101</td><td>服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</td></tr><tr><td>102</td><td>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</td></tr><tr><td>200</td><td>请求已成功，请求所希望的响应头或数据体将随此响应返回。</td></tr><tr><td>201</td><td>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。</td></tr><tr><td>202</td><td>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td></tr><tr><td>203</td><td>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</td></tr><tr><td>204</td><td>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td></tr><tr><td>205</td><td>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</td></tr><tr><td>206</td><td>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 响应必须包含如下的头部域： Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 Date ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。</td></tr><tr><td>207</td><td>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td></tr><tr><td>300</td><td>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td></tr><tr><td>301</td><td>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。</td></tr><tr><td>302</td><td>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</td></tr><tr><td>303</td><td>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</td></tr><tr><td>304</td><td>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 该响应必须包含以下的头信息： Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</td></tr><tr><td>305</td><td>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</td></tr><tr><td>306</td><td>在最新版的规范中，306状态码已经不再被使用。</td></tr><tr><td>307</td><td>请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td></tr><tr><td>400</td><td>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 2、请求参数有误。</td></tr><tr><td>401</td><td>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</td></tr><tr><td>402</td><td>该状态码是为了将来可能的需求而预留的。</td></tr><tr><td>403</td><td>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</td></tr><tr><td>404</td><td>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</td></tr><tr><td>405</td><td>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td></tr><tr><td>406</td><td>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td></tr><tr><td>407</td><td>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。</td></tr><tr><td>408</td><td>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td></tr><tr><td>409</td><td>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</td></tr><tr><td>410</td><td>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</td></tr><tr><td>411</td><td>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td></tr><tr><td>412</td><td>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td></tr><tr><td>413</td><td>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td></tr><tr><td>414</td><td>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</td></tr><tr><td>415</td><td>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td></tr><tr><td>416</td><td>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</td></tr><tr><td>417</td><td>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</td></tr><tr><td>421</td><td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td></tr><tr><td>422</td><td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td></tr><tr><td>422</td><td>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 当前资源被锁定。（RFC 4918 WebDAV）</td></tr><tr><td>424</td><td>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</td></tr><tr><td>425</td><td>在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</td></tr><tr><td>426</td><td>客户端应当切换到TLS/1.0。（RFC 2817）</td></tr><tr><td>449</td><td>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td></tr><tr><td>500</td><td>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</td></tr><tr><td>501</td><td>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</td></tr><tr><td>502</td><td>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td></tr><tr><td>503</td><td>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</td></tr><tr><td>504</td><td>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 注意：某些代理服务器在DNS查询超时时会返回400或者500错误</td></tr><tr><td>505</td><td>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td></tr><tr><td>506</td><td>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td></tr><tr><td>507</td><td>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</td></tr><tr><td>509</td><td>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td></tr><tr><td>510</td><td>获取资源所需要的策略并没有没满足。（RFC 2774）</td></tr></tbody></table><h2 id="响应报头"><a href="#响应报头" class="headerlink" title="响应报头"></a>响应报头</h2><h3 id="响应首部"><a href="#响应首部" class="headerlink" title="响应首部"></a>响应首部</h3><table><thead><tr><th>首部</th><th>描述</th></tr></thead><tbody><tr><td>Age</td><td>（从最初创建开始)响应持续时间。</td></tr><tr><td>Public</td><td>服务器为其资源支持的请求方法列表。</td></tr><tr><td>Retry-After</td><td>如果资源不可用的话，在此日期或时间重试。</td></tr><tr><td>Server</td><td>服务器应用程序软件的名称和版本。</td></tr><tr><td>Title</td><td>对 HTML 文档来说，就是 HTML 文档的源端给出的标题。</td></tr><tr><td>Warning</td><td>比原因短语更详细一些的警告报文。</td></tr><tr><td>Accept-Ranges</td><td>对此资源来说，服务器可接受的范围类型。</td></tr><tr><td>Vary</td><td>服务器查看的其他首部列表，可能会使响应发生变化；也就是说，这是一个首部列表，服务器会根据这些首部的内容挑选出最适合的资源版本发送给客户端。</td></tr><tr><td>Proxy-Authenticate</td><td>来自代理的对客户端的质询列表。</td></tr><tr><td>Set-Cookie</td><td>不是真正的安全首部，但隐含安全功能；可以在客户端设置一个令牌，以便服务器对其客户端进行标识。</td></tr><tr><td>Set-Cookie2</td><td>与 Set-Cookie 类似，PFC 2965 Cookie定义。</td></tr><tr><td>WWW-Authenticate</td><td>来自服务器对客户端的质询列表。</td></tr></tbody></table><h1 id="实体首部-1"><a href="#实体首部-1" class="headerlink" title="实体首部"></a>实体首部</h1><table><thead><tr><th>首部</th><th>描述</th></tr></thead><tbody><tr><td>Allow</td><td>列出可以对此事提执行的请求方法。</td></tr><tr><td>Location</td><td>告知客户端实际上位于何处；用于将接收端定向到资源的(可能是新的)位置(URL)上去。</td></tr><tr><td>Content-Base</td><td>解释主体中的相对 URL 时使用的基础 URL</td></tr><tr><td>Content-Encoding</td><td>对主体执行的任意编码方式。</td></tr><tr><td>Content-Language</td><td>理解主体时最适宜使用的自然语言。</td></tr><tr><td>Content-Length</td><td>主体的长度或尺寸。</td></tr><tr><td>Content-Locaton</td><td>资源实际所处的位置。</td></tr><tr><td>Content-MD5</td><td>主体的 MD5 校验和。</td></tr><tr><td>Content-Range</td><td>在整个资源中此实体表示的字节范围。</td></tr><tr><td>Content-Type</td><td>在这个主体的对象类型。</td></tr><tr><td>ETag</td><td>与此实体相关的实体标记。</td></tr><tr><td>Expires</td><td>实体不再有效，要从原始的源端再次获取此实体的日期和时间。</td></tr><tr><td>Last-Modified</td><td>这个实体最后一次被修改的日期和时间。</td></tr></tbody></table><p><a href="http://tool.oschina.net/commons?type=5" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;做一下http总结吧！！！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习" scheme="http://xuyonglin222.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="http" scheme="http://xuyonglin222.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>template</title>
    <link href="http://xuyonglin222.github.io/2018/04/18/template/"/>
    <id>http://xuyonglin222.github.io/2018/04/18/template/</id>
    <published>2018-04-18T03:38:08.000Z</published>
    <updated>2019-07-29T09:43:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>之前学习React了解了一下JSX的编译，那么对于Vue中的template，是怎么编译的呢？<br><a id="more"></a></p></blockquote><p>compile编译主要分为parse、optimize与generate三个阶段，最终得到render function。</p><h3 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h3><p>parse会用正则表达式将template字符串进行解析，得到指令、class、style啥的，形成一个叫AST的东西。<br>形如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :class=<span class="string">"c"</span> class=<span class="string">"demo"</span> v-if=<span class="string">"isShow"</span>&gt;</span><br><span class="line">    &lt;span v-for=<span class="string">"item in sz"</span>&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    /* 标签属性的map，记录了标签上属性 */</span><br><span class="line">    <span class="string">'attrsMap'</span>: &#123;</span><br><span class="line">        <span class="string">':class'</span>: <span class="string">'c'</span>,</span><br><span class="line">        <span class="string">'class'</span>: <span class="string">'demo'</span>,</span><br><span class="line">        <span class="string">'v-if'</span>: <span class="string">'isShow'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    /* 解析得到的:class */</span><br><span class="line">    <span class="string">'classBinding'</span>: <span class="string">'c'</span>,</span><br><span class="line">    /* 标签属性v-if */</span><br><span class="line">    <span class="string">'if'</span>: <span class="string">'isShow'</span>,</span><br><span class="line">    /* v-if的条件 */</span><br><span class="line">    <span class="string">'ifConditions'</span>: [</span><br><span class="line">        <span class="string">'exp'</span>: <span class="string">'isShow'</span></span><br><span class="line">    ],</span><br><span class="line">    /* 标签属性class */</span><br><span class="line">    <span class="string">'staticClass'</span>: <span class="string">'demo'</span>,</span><br><span class="line">    /* 标签的tag */</span><br><span class="line">    <span class="string">'tag'</span>: <span class="string">'div'</span>,</span><br><span class="line">    /* 子标签数组 */</span><br><span class="line">    <span class="string">'children'</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">'attrsMap'</span>: &#123;</span><br><span class="line">                <span class="string">'v-for'</span>: <span class="string">"item in sz"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            /* <span class="keyword">for</span>循环的参数 */</span><br><span class="line">            <span class="string">'alias'</span>: <span class="string">"item"</span>,</span><br><span class="line">            /* <span class="keyword">for</span>循环的对象 */</span><br><span class="line">            <span class="string">'for'</span>: <span class="string">'sz'</span>,</span><br><span class="line">            /* <span class="keyword">for</span>循环是否已经被处理的标记位 */</span><br><span class="line">            <span class="string">'forProcessed'</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">'tag'</span>: <span class="string">'span'</span>,</span><br><span class="line">            <span class="string">'children'</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    /* 表达式，_s是一个转字符串的函数 */</span><br><span class="line">                    <span class="string">'expression'</span>: <span class="string">'_s(item)'</span>,</span><br><span class="line">                    <span class="string">'text'</span>: <span class="string">'&#123;&#123;item&#125;&#125;'</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="optimize"><a href="#optimize" class="headerlink" title="optimize"></a>optimize</h3><p>optimize主要作用是优化，虚拟Dom在在比对时，对于一些修饰性节点和没有发生改变的节点，是没有必要比对的，这个阶段就是<br>来标记静态节点的。<br>经过 optimize 这层的处理，每个节点会加上 static 属性，用来标记是否是静态的。</p><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><p>generate 会将 AST 转化成 render funtion 字符串，最终得到 render 的字符串以及 staticRenderFns 字符串。</p><h3 id="VNode"><a href="#VNode" class="headerlink" title="VNode"></a>VNode</h3><p>render function 会被转化成 VNode 节点，它是用对象属性来描述节点的一种方式，实际上它只是一层对真实 DOM 的抽象。<br>浏览器引擎可分为两部分，渲染引擎和js解释器，当我们获取Dom元素、操纵Dom时是在解释器这边，然后更新时，就跑到了渲染引擎那边，</p><p>这样跨线程是很浪费成本的，尤其是一行一行的执行时，一般开发时，会先创建documentFragment，然后把元素装进去，最后放到文档里，</p><p>Vue在渲染前将新产生的 VNode 节点与老 VNode 进行一个 patch 的过程，比对得出「差异」，最终将这些「差异」更新到视图上。</p><p>Vue基于Object.defineProperty方法构建了一个响应式系统，可以实现貌似立即渲染的功能，但是频繁渲染不也很浪费性能吗？还是说他有像React<br>那样有利用setState合并状态的过程。</p><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><p>其实当页面在触发更新的时候会有一个依赖收集的过程，通过Dep订阅者和Watcher监听者来实现的，之前有写过简陋的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//订阅者</span><br><span class="line">class Dep&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span>()&#123;</span><br><span class="line">        //用来存放watcher对象的数组</span><br><span class="line">        this.subs = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //在subs中添加一个watcher对象</span><br><span class="line">    addSub(sub)&#123;</span><br><span class="line">        this.subs.push(sub);</span><br><span class="line">    &#125;</span><br><span class="line">    //通知watcher对象更新视图</span><br><span class="line">    <span class="function"><span class="title">notify</span></span>()&#123;</span><br><span class="line">        this.subs.forEach((sub)=&gt;&#123;</span><br><span class="line">            sub.update();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//观察者</span><br><span class="line"></span><br><span class="line">class watcher&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span>()&#123;</span><br><span class="line">        //在new一个watcher对象时将该对象赋值给Dep.target,在get时会用到。</span><br><span class="line">        Dep.target  =this;</span><br><span class="line">        console.log(this)</span><br><span class="line">    &#125;</span><br><span class="line">    //更新视图的方法</span><br><span class="line">    <span class="function"><span class="title">update</span></span>()&#123;</span><br><span class="line">        console.log(<span class="string">'view change'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好吧！  把Vue和之前提到的双向绑定的也贴上吧</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">cb</span></span>() &#123;</span><br><span class="line">//    简陋的视图更新函数</span><br><span class="line">    console.log(<span class="string">'视图更新了'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> defineReactive(obj, key, val) &#123;</span><br><span class="line">    const dep = new Dep();</span><br><span class="line">    Object.defineProperty(obj,key,&#123;</span><br><span class="line">        enumerable:<span class="literal">true</span>,   //属性可枚举</span><br><span class="line">        configurable:<span class="literal">true</span>, //属性可被删除或修改</span><br><span class="line">        get:<span class="keyword">function</span> <span class="function"><span class="title">reactiveGetter</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">            dep.addSub(Dep.target);</span><br><span class="line">            <span class="built_in">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">set</span>:<span class="keyword">function</span> reactiveSetter(newVal)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newVal===val) <span class="built_in">return</span>;</span><br><span class="line">            //通知watcher对象更新视图</span><br><span class="line">            val = newVal</span><br><span class="line">            dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> observer(value)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!value||(typeof value !== <span class="string">'object'</span>))&#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object.keys(value).forEach((key)=&gt;&#123;</span><br><span class="line">        defineReactive(value,key,value[key]);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Vue &#123;</span><br><span class="line">    constructor(options)&#123;</span><br><span class="line">        this._data = options.data;</span><br><span class="line">        observer(this._data);</span><br><span class="line">        //new一个观察者对象，这时候Dep.target会指向这个watcher</span><br><span class="line">        new watcher();</span><br><span class="line">        //模拟render过程，为了触发<span class="built_in">test</span>属性的get函数</span><br><span class="line">        console.log(<span class="string">'render'</span>,this._data.test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖收集其实接受的就是Watcher的实例化对象，它的主要作用是在数据被触发setter后，通过update方法来更新试图，但是这个Watcher对象其实会<br>被push到一个队列里，在下一次tick时，把队列里的全部拿出来执行，这让我想到了node的执行机制。Vue貌似是通过Promise，seTimeout等方法在微任务队列<br>（microtask queue）里创建一个事件，当主线程（调用栈）清空时，在一定条件下执行这个事件。这之间当然有一个状态合并的 过程，因为把所有的事件都执行也不是很好，。在Vue被实例化时，watcher被记录下来，然后通过内部变量id标记Watcher，推入队列的时候，相同的会被剔除。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前学习React了解了一下JSX的编译，那么对于Vue中的template，是怎么编译的呢？&lt;br&gt;
    
    </summary>
    
      <category term="学习" scheme="http://xuyonglin222.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="vue" scheme="http://xuyonglin222.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>axioshhh</title>
    <link href="http://xuyonglin222.github.io/2018/04/10/axioshhh/"/>
    <id>http://xuyonglin222.github.io/2018/04/10/axioshhh/</id>
    <published>2018-04-09T16:51:31.000Z</published>
    <updated>2019-07-29T09:43:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>这几天在用Vue写销售系统，想着后台用node写几个接口，给前端用，之前登陆信息，暂时存在localStorage里，真是脸红。</p></blockquote><a id="more"></a><p>这个项目是很早之前写过的，没有网络请求，也没有Vuex，所以想着重写一遍，顺便捋捋node和http通信这一块。<br></p><p>说实话，我觉得我后台很渣，但是也没想到这么渣，之前用原生js去封装ajax，啥事没有。<br></p><p>今天用axios，各种Content-type不适配，好不容易好不容易传过来，打印出来是这样的<br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/axioshhh.png" alt><br>exm????为啥传来的值在key上，<br>是我的body-parser用的不对吗？之前也是这么用的啊<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> bodyParser = require(<span class="string">"body-parser"</span>);</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.use(bodyParser.urlencoded(&#123; extended: <span class="literal">true</span> &#125;));</span><br></pre></td></tr></table></figure></p><p>好吧，先不管了，先用keys方法取出来，之后再研究，发现自己对前后端通信，一无所知。</p><h3 id="axios简介"><a href="#axios简介" class="headerlink" title="axios简介"></a>axios简介</h3><p>axios是一个基于Promise用于浏览器和node的http客户端，是对ajax的封装，如同angular的httpclient。<br>通过npm install axios安装后，import引入，然后可以通过Vue.prototype.$http=axios，赋值在Vue的原型上，这样就可以在任何单页面组件里，使用axios。<br>值得一体的是axios不是个插件，之前我是通过Vue.use(axios)使用的，发现了各式各样的bug。</p><h3 id="axios配置"><a href="#axios配置" class="headerlink" title="axios配置"></a>axios配置</h3><p>般一个项目中的根host和Content-Type都是统一的，这里对axios进行统一的配置（如果这个后端需要formData格式的表单即content-type=’application/x-www-form-urlencoded;charset=utf-8’数据，需要对请求数据进行表单序列化，比较快的方式就是引入qs库qs.stringify进行处理后传输）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.headers.common[<span class="string">'Content-Type'</span>] = <span class="string">'application/json'</span></span><br><span class="line">axios.defaults.baseURL = _apiHost</span><br></pre></td></tr></table></figure><h3 id="axios使用方法"><a href="#axios使用方法" class="headerlink" title="axios使用方法"></a>axios使用方法</h3><p>基本使用方法<br>GET请求<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Make a request <span class="keyword">for</span> a user with a given ID</span><br><span class="line">axios.get(<span class="string">'/user?ID=12345'</span>)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="keyword">function</span> (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="keyword">function</span> (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">// Optionally the request above could also be <span class="keyword">done</span> as</span><br><span class="line">axios.get(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: 12345</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="keyword">function</span> (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="keyword">function</span> (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><p>POST请求<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">'/user'</span>, &#123;</span><br><span class="line">   firstName: <span class="string">'Fred'</span>,</span><br><span class="line">   lastName: <span class="string">'Flintstone'</span></span><br><span class="line"> &#125;)</span><br><span class="line"> .<span class="keyword">then</span>(<span class="keyword">function</span> (response) &#123;</span><br><span class="line">   console.log(response);</span><br><span class="line"> &#125;)</span><br><span class="line"> .catch(<span class="keyword">function</span> (error) &#123;</span><br><span class="line">   console.log(error);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></p><p>同时执行多个<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getUserAccount</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> axios.get(<span class="string">'/user/12345'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getUserPermissions</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> axios.get(<span class="string">'/user/12345/permissions'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class="line">  .<span class="keyword">then</span>(axios.spread(<span class="keyword">function</span> (acct, perms) &#123;</span><br><span class="line">    // Both requests are now complete</span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure></p><p>可以直接通过config来完成请求<br>axios(config)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  url: <span class="string">'/user/12345'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>详情请点击<a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">这里</a></p><h3 id="请求配置"><a href="#请求配置" class="headerlink" title="请求配置"></a>请求配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  // `url` 是用于请求的服务器 URL</span><br><span class="line">  url: <span class="string">'/user'</span>,</span><br><span class="line"></span><br><span class="line">  // `method` 是创建请求时使用的方法</span><br><span class="line">  method: <span class="string">'get'</span>, // 默认是 get</span><br><span class="line"></span><br><span class="line">  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span><br><span class="line">  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span><br><span class="line">  baseURL: <span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line"></span><br><span class="line">  // `transformRequest` 允许在向服务器发送前，修改请求数据</span><br><span class="line">  // 只能用在 <span class="string">'PUT'</span>, <span class="string">'POST'</span> 和 <span class="string">'PATCH'</span> 这几个请求方法</span><br><span class="line">  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span><br><span class="line">  transformRequest: [<span class="keyword">function</span> (data) &#123;</span><br><span class="line">    // 对 data 进行任意转换处理</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  // `transformResponse` 在传递给 <span class="keyword">then</span>/catch 前，允许修改响应数据</span><br><span class="line">  transformResponse: [<span class="keyword">function</span> (data) &#123;</span><br><span class="line">    // 对 data 进行任意转换处理</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  // `headers` 是即将被发送的自定义请求头</span><br><span class="line">  headers: &#123;<span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>&#125;,</span><br><span class="line"></span><br><span class="line">  // `params` 是即将与请求一起发送的 URL 参数</span><br><span class="line">  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象</span><br><span class="line">  params: &#123;</span><br><span class="line">    ID: 12345</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // `paramsSerializer` 是一个负责 `params` 序列化的函数</span><br><span class="line">  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span><br><span class="line">  paramsSerializer: <span class="keyword">function</span>(params) &#123;</span><br><span class="line">    <span class="built_in">return</span> Qs.stringify(params, &#123;arrayFormat: <span class="string">'brackets'</span>&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // `data` 是作为请求主体被发送的数据</span><br><span class="line">  // 只适用于这些请求方法 <span class="string">'PUT'</span>, <span class="string">'POST'</span>, 和 <span class="string">'PATCH'</span></span><br><span class="line">  // 在没有设置 `transformRequest` 时，必须是以下类型之一：</span><br><span class="line">  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span><br><span class="line">  // - 浏览器专属：FormData, File, Blob</span><br><span class="line">  // - Node 专属： Stream</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span><br><span class="line">  // 如果请求话费了超过 `timeout` 的时间，请求将被中断</span><br><span class="line">  timeout: 1000,</span><br><span class="line"></span><br><span class="line">  // `withCredentials` 表示跨域请求时是否需要携带cookie</span><br><span class="line">  withCredentials: <span class="literal">false</span>, // 默认的</span><br><span class="line"></span><br><span class="line">  // `adapter` 允许自定义处理请求，以使测试更轻松</span><br><span class="line">  // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](<span class="comment">#response-api)).</span></span><br><span class="line">  adapter: <span class="keyword">function</span> (config) &#123;</span><br><span class="line">    /* ... */</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // `auth` 表示应该使用 HTTP 基础验证，并提供凭据</span><br><span class="line">  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头</span><br><span class="line">  auth: &#123;</span><br><span class="line">    username: <span class="string">'janedoe'</span>,</span><br><span class="line">    password: <span class="string">'s00pers3cret'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // `responseType` 表示服务器响应的数据类型，可以是 <span class="string">'arraybuffer'</span>, <span class="string">'blob'</span>, <span class="string">'document'</span>, <span class="string">'json'</span>, <span class="string">'text'</span>, <span class="string">'stream'</span></span><br><span class="line">  responseType: <span class="string">'json'</span>, // 默认的</span><br><span class="line"></span><br><span class="line">  // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称</span><br><span class="line">  xsrfCookieName: <span class="string">'XSRF-TOKEN'</span>, // default</span><br><span class="line"></span><br><span class="line">  // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称</span><br><span class="line">  xsrfHeaderName: <span class="string">'X-XSRF-TOKEN'</span>, // 默认的</span><br><span class="line"></span><br><span class="line">  // `onUploadProgress` 允许为上传处理进度事件</span><br><span class="line">  onUploadProgress: <span class="keyword">function</span> (progressEvent) &#123;</span><br><span class="line">    // 对原生进度事件的处理</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // `onDownloadProgress` 允许为下载处理进度事件</span><br><span class="line">  onDownloadProgress: <span class="keyword">function</span> (progressEvent) &#123;</span><br><span class="line">    // 对原生进度事件的处理</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // `maxContentLength` 定义允许的响应内容的最大尺寸</span><br><span class="line">  maxContentLength: 2000,</span><br><span class="line"></span><br><span class="line">  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `<span class="literal">true</span>` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte</span><br><span class="line">  validateStatus: <span class="keyword">function</span> (status) &#123;</span><br><span class="line">    <span class="built_in">return</span> status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目</span><br><span class="line">  // 如果设置为0，将不会 follow 任何重定向</span><br><span class="line">  maxRedirects: 5, // 默认的</span><br><span class="line"></span><br><span class="line">  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：</span><br><span class="line">  // `keepAlive` 默认没有启用</span><br><span class="line">  httpAgent: new http.Agent(&#123; keepAlive: <span class="literal">true</span> &#125;),</span><br><span class="line">  httpsAgent: new https.Agent(&#123; keepAlive: <span class="literal">true</span> &#125;),</span><br><span class="line"></span><br><span class="line">  // <span class="string">'proxy'</span> 定义代理服务器的主机名称和端口</span><br><span class="line">  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span><br><span class="line">  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。</span><br><span class="line">  proxy: &#123;</span><br><span class="line">    host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    port: 9000,</span><br><span class="line">    auth: : &#123;</span><br><span class="line">      username: <span class="string">'mikeymike'</span>,</span><br><span class="line">      password: <span class="string">'rapunz3l'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // `cancelToken` 指定用于取消请求的 cancel token</span><br><span class="line">  // （查看后面的 Cancellation 这节了解更多）</span><br><span class="line">  cancelToken: new CancelToken(<span class="keyword">function</span> (cancel) &#123;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // `data` 由服务器提供的响应</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  // `status` 来自服务器响应的 HTTP 状态码</span><br><span class="line">  status: 200,</span><br><span class="line"></span><br><span class="line">  // `statusText` 来自服务器响应的 HTTP 状态信息</span><br><span class="line">  statusText: <span class="string">'OK'</span>,</span><br><span class="line"></span><br><span class="line">  // `headers` 服务器响应的头</span><br><span class="line">  headers: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  // `config` 是为请求提供的配置信息</span><br><span class="line">  config: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><p>后来做项目时，用axios遇到了一个问题，发送delete请求时，总是报405，询问后端之后了解到后台是允许delete method的，那为啥还会报405呢？<br>原来浏览器在发送delete请求时，会先发送一个options请求询问服务器是否允许浏览器以此方法、接口访问服务器，如果允许，浏览器会发送真实的delete请求。<br>之所以报405，是因为后台的Acess-Control-Allow-Methods里没有OPTIONS，所以就报了个405。</p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这几天在用Vue写销售系统，想着后台用node写几个接口，给前端用，之前登陆信息，暂时存在localStorage里，真是脸红。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习" scheme="http://xuyonglin222.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="javascript" scheme="http://xuyonglin222.github.io/tags/javascript/"/>
    
  </entry>
  
</feed>
