<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>庚庚</title>
  
  <subtitle>任风雨飘摇 我自怡然不动</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-27T04:02:12.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>徐永林</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>垃圾回收</title>
    <link href="http://yoursite.com/2019/09/28/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://yoursite.com/2019/09/28/浏览器-垃圾回收/</id>
    <published>2019-09-28T07:20:25.000Z</published>
    <updated>2020-05-27T04:02:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>在javascript中，原始数据类型是存储在栈空间中的，引用类型的数据是存储在堆空间中的，那么在执行过程中，没有用的数据是怎么清理的？<br><a id="more"></a></p></blockquote><h2 id="代际假说"><a href="#代际假说" class="headerlink" title="代际假说"></a>代际假说</h2><p>代际假说是垃圾回收机制中的一个关键术语，代际假说有以下两个特点：</p><ul><li>大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</li><li>不死的对象，会活得更久。</li></ul><p>通常垃圾回收机制有多种算法，但是不论什么垃圾回收器都有一些定期需要去做的任务：</p><ul><li>标记活动对象（live objects）和非活动对象(dead objects)。活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</li></ul><ul><li>回收或者重用被非活动对象占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。它就是将非活动对象占用的内存空间添加到一个叫空闲列表（free-list）的数据结构中。一旦标记完成，垃圾回收器会找到不可访问对象的内存空间，并将内存空间添加到相应的空闲列表中。</li></ul><ul><li>合并或者整理内存（可选），一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如副垃圾回收器。</li></ul><p>这些任务可以按照顺序或者交叉地执行。一种方式是暂停JavaScript的执行，在主线程上按照顺序去执行这些任务。<br>这样做导致的结果就是JavaScript延迟执行，以及页面渲染时JavaScript来不及执行导致的页面空白或者卡顿问题。</p><h2 id="分代堆布局"><a href="#分代堆布局" class="headerlink" title="分代堆布局"></a>分代堆布局</h2><p>堆在V8 中会分为两块不同的区域，我们将其称之为代（generations）；<br>这两块区域分别称之为老生代（old generation）和新生代（young generation），新生代又进一步分为 ‘nursery’ 子代和 ‘intermediate’ 子代两块区域生代又进一步分为 ‘nursery’ 子代(对象区域)和 ‘intermediate’ 子代(空闲区域)两块区域.</p><p><img src="https://v8.js.cn/_img/trash-talk/02.svg" alt=""></p><p>V8分代堆布局的设计主要是为了利用对象存在生命周期的这个事实；垃圾回收实质上就是整理内存和移动内存中的对象，那这就意味着我们应该多移动对象到空闲列表中的内存中去；这个看上去似乎有点违反直觉，因为在垃圾回收的时候复制对象的成本很高。但是根据代际假说在垃圾回收中，在内存中存活下来的对象其实并不是很多。所以重新分配内存给新创建的对象，这反而变成了隐式的垃圾；这就意味着我们只需花费复制存活对象的成本，并不需要耗费成本去分配新的内存。</p><p>新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p><ul><li>副垃圾回收器，主要负责新生代的垃圾回收。</li><li>主垃圾回收器，主要负责老生代的垃圾回收。</li></ul><h2 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h2><p>副垃圾回收器主要负责新生区的垃圾回收。</p><p>新生代中用 Scavenge 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</p><p>在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。</p><p>由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p><p>完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。</p><p>由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</p><h2 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h2><p>主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</p><p>由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。</p><ul><li><p>标记。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。</p></li><li><p>清除。将没有被标记的对象添加到空闲列表中。</p></li></ul><p>不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（Mark-Compact），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><h2 id="全停顿"><a href="#全停顿" class="headerlink" title="全停顿"></a>全停顿</h2><p>V8 是使用副垃圾回收器和主垃圾回收器处理垃圾回收的，不过由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。这种行为叫做全停顿（Stop-The-World）。</p><p><strong>测量垃圾回收所花费时间的一个重要指标就是执行垃圾回收时主线程挂起的时间。</strong></p><p><img src="https://static001.geekbang.org/resource/image/98/0c/9898646a08b46bce4f12f918f3c1e60c.png" alt=""></p><p>比如堆中的数据有 1.5GB，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。</p><h3 id="并行垃圾回收"><a href="#并行垃圾回收" class="headerlink" title="并行垃圾回收"></a>并行垃圾回收</h3><p>并行是主线程和协助线程同时执行同样的工作，这就是一种 ‘stop-the-world’ 的垃圾回收方式，但是垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）。这是这三种技术中最简单的 JavaScript 垃圾回收方式；因为没有 JavaScript 的执行，因此只要确保同时只有一个协助线程在访问对象就好了。</p><p><img src="https://v8.js.cn/_img/trash-talk/05.svg" alt=""></p><h3 id="增量垃圾回收"><a href="#增量垃圾回收" class="headerlink" title="增量垃圾回收"></a>增量垃圾回收</h3><p>在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了 200 毫秒，在这 200 毫秒内，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。</p><p>为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。</p><p><img src="https://static001.geekbang.org/resource/image/de/e7/de117fc96ae425ed90366e9060aa14e7.png" alt=""></p><p>使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</p><h3 id="并发垃圾回收"><a href="#并发垃圾回收" class="headerlink" title="并发垃圾回收"></a>并发垃圾回收</h3><p>并发是主线程一直执行 JavaScript，而辅助线程在后台完全的执行垃圾回收。这种方式是这三种技术中最难的一种，JavaScript 堆里面的内容随时都有可能发生变化，从而使之前做的工作完全无效。最重要的是，现在有读/写竞争（read/write races），主线程和辅助线程极有可能在同一时间去更改同一个对象。这种方式的优势也非常明显，主线程不会被挂起，JavaScript 可以自由地执行 ，尽管为了保证同一对象同一时间只有一个辅助线程在修改而带来的一些同步开销。</p><p><img src="https://v8.js.cn/_img/trash-talk/07.svg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在javascript中，原始数据类型是存储在栈空间中的，引用类型的数据是存储在堆空间中的，那么在执行过程中，没有用的数据是怎么清理的？&lt;br&gt;
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>渲染</title>
    <link href="http://yoursite.com/2019/09/17/%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%B8%B2%E6%9F%93/"/>
    <id>http://yoursite.com/2019/09/17/浏览器-渲染/</id>
    <published>2019-09-17T02:36:53.000Z</published>
    <updated>2020-05-25T12:09:23.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>浏览器渲染篇<br><a id="more"></a></p></blockquote><p>先说一下浏览器，目前的浏览器都是多进程架构的。以chrome为例，它包括1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。<br>其中：</p><ul><li><strong>浏览器进程</strong>。主要负责界面显示、用户交互、自进程管理，同时提供存储等功能。</li><li><strong>渲染进程</strong>。核心任务是将 HTML、CSS 和 JavaScript转换成用户可以与之交互的页面，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中。默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li><li><strong>网络进程</strong>。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的。</li><li><strong>GPU进程</strong>。用来绘制UI界面。</li><li><strong>插件进程</strong>。主要负责插件的运行，因插件已崩溃，所以需要通过插件进程来隔离。</li></ul><p>以前了解浏览器的渲染，我学到的是这样好的。<br><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/webkitflow.png" alt="浏览器渲染过程"></p><p>但是各种细节不是很清楚，这次做个总结。</p><h2 id="DOM树生成"><a href="#DOM树生成" class="headerlink" title="DOM树生成"></a>DOM树生成</h2><ul><li><p>转换Bytes：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符</p></li><li><p>Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集</p></li><li><p>Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则</p></li><li><p>DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样</p></li></ul><h2 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h2><p>样式计算分为以下三步</p><h3 id="将CSS转换为浏览器能够理解的结构"><a href="#将CSS转换为浏览器能够理解的结构" class="headerlink" title="将CSS转换为浏览器能够理解的结构"></a>将CSS转换为浏览器能够理解的结构</h3><p>来源：</p><ul><li>通过link引用的外部CSS文件</li><li>style标签引入的</li><li>DOM的style属性内嵌的<br>纯文本的CSS样式，浏览器是无法理解的，必须转换成StyleSheet</li></ul><h3 id="转换样式表中的属性值，使其标准化"><a href="#转换样式表中的属性值，使其标准化" class="headerlink" title="转换样式表中的属性值，使其标准化"></a>转换样式表中的属性值，使其标准化</h3><p>css的某些属性值，渲染引擎是不容易理解的，比如em，red， bold，这些会被转化成px，rgb以及700的形式。</p><h3 id="计算DOM树中每个节点的具体样式"><a href="#计算DOM树中每个节点的具体样式" class="headerlink" title="计算DOM树中每个节点的具体样式"></a>计算DOM树中每个节点的具体样式</h3><p>主要是通过继承和层叠来实线。</p><ul><li><p>一个子元素的的样式可以从父元素继承而来，比如font-weight、font-family的font系列，text-align、line-height、color等文本系列，visibility以及cursor等。</p></li><li><p>css有个优先级策略，比如!important&gt;行内&gt;id&gt;class&gt;Tag&gt;*，统一等级的下面的会覆盖上面的。</p></li></ul><p>浏览器还有默认的userAgent。</p><p>通过这两种方式累计计算Dom的样式。</p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>布局是计算出元素的可见位置，分为创建布局树和布局计算两步。</p><h3 id="创建布局树"><a href="#创建布局树" class="headerlink" title="创建布局树"></a>创建布局树</h3><ul><li><p>遍历DOM树中的可见节点，并将节点加到布局树中</p></li><li><p>忽略不可见的元素，比如head标签里面的元素，display为none的元素。</p></li></ul><h3 id="布局计算"><a href="#布局计算" class="headerlink" title="布局计算"></a>布局计算</h3><p>布局是一个递归的过程，这是因为一个节点的大小通常需要先计算他的自节点的位置、大小等信息。</p><p>计算布局的主要过程是的RenderObject的layout函数来完成的，步骤大致如下：</p><ul><li><p>通过检查位数组中的相应标记位、子元素是否需要计算布局来确定。</p></li><li><p>确定网页的宽度和垂直方向上的外边距，这是因为网页通常是在垂直方向上滚动，而水平方向上不需要滚动。？？？？</p></li><li><p>接着函数会便利其每一个子元素，以此计算他们的布局。如果元素定义了自身的狂傲，那么webkit按照定义的宽高来确定元素的大小，而对于像文本节点的內联元素则需要结合其字号大小及文字的多少等来确定其对应的狂傲，除非页面定义了页面元素的狂傲，一般来说页面元素的宽高是在布局的时候通过相关计算的出来的。如果有子元素，则递归这一过程。</p></li><li><p>最后，节点根据计算他的子女们的大小计算出自己的高度，整个过程结束。</p></li></ul><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>渲染引擎为特定节点创建新的层的条件（满足两点任意一点就行）</p><ul><li>拥有层叠上下文，例如<ul><li>根元素 (HTML),</li><li>z-index 值不为 “auto”的 绝对/相对定位元素，</li><li>固定（fixed）/ 沾滞（sticky）定位（沾滞定位适配所有移动设备上的浏览器，但老的桌面浏览器不支持）</li><li>z-index值不为 “auto”的 flex 子项 (flex item)，即：父元素 display: flex|inline-flex，</li><li>z-index值不为“auto”的grid子项，即：父元素display：grid</li><li>opacity 属性值小于 1 的元素（参考 the specification for opacity），</li><li>mix-blend-mode 属性值不为 “normal”的元素，</li><li>transform属性值不为“none”的元素 </li><li>filter值不为“none”的元素，</li><li>perspective值不为“none”的元素，</li><li>clip-path值不为“none”的元素</li><li>mask / mask-image / mask-border不为“none”的元素</li><li>isolation 属性被设置为 “isolate”的元素</li><li>在 will-change 中指定了任意CSS属性（参考 这篇文章）</li><li>-webkit-overflow-scrolling 属性被设置 “touch”的元素</li><li>contain属性值为“layout”，“paint”，或者综合值比如“strict”，“content”</li></ul></li></ul><ul><li>需要裁剪的地方</li></ul><h2 id="图层绘制"><a href="#图层绘制" class="headerlink" title="图层绘制"></a>图层绘制</h2><p>渲染引擎会把一个图层拆分成很多小的绘制指令，然后这些指令按照顺序组成一个待绘制列表。包含绘制的形状、绘制、样式等。</p><h2 id="栅格化（raster）操作"><a href="#栅格化（raster）操作" class="headerlink" title="栅格化（raster）操作"></a>栅格化（raster）操作</h2><p>在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p><p>基于这个原因，<strong>合成线程会将图层划分为图块（tile）</strong>，这些图块的大小通常是 256x256 或者 512x512</p><p><strong>然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图</strong>。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。</p><p>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p><p><img src="https://static001.geekbang.org/resource/image/a8/87/a8d954cd8e4722ee03d14afaa14c3987.png" alt=""></p><h2 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h2><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;浏览器渲染篇&lt;br&gt;
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Quic</title>
    <link href="http://yoursite.com/2019/08/07/%E7%BD%91%E7%BB%9C-Quic/"/>
    <id>http://yoursite.com/2019/08/07/网络-Quic/</id>
    <published>2019-08-07T08:27:47.000Z</published>
    <updated>2019-09-17T02:41:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Google家是真的DIAO啊，掌控了http的发展啊。</p></blockquote><h3 id="Quic简述"><a href="#Quic简述" class="headerlink" title="Quic简述"></a>Quic简述</h3><p>Quic 全称 quick udp internet connection，“快速 UDP 互联网连接”，是由 google 提出的使用 udp 进行多路并发传输的协议。</p><h3 id="为啥需要Quic"><a href="#为啥需要Quic" class="headerlink" title="为啥需要Quic"></a>为啥需要Quic</h3><p>为毛需要Quic，因为http2.0有一些硬伤难以解决，啥硬伤呢？就是TCP。<br><br>经过几十年的经验累积，网络工程师对怎么优化网络访问，降低延迟也有了新的认知，于是就想着更新 TCP 协议，但是 TCP 的更新非常困难，因为网络协议栈的实现本来就依赖系统内核更新，而不管是终端设备，中间设备的系统更新都极其缓慢，一个更新迭代可能需要5-15年的时间去普及，对于现在的互联网发展来说太慢了。</p><p>所以 TCP 的硬伤总结一下就是：TCP的更新优化需要依赖系统内核更新。</p><h4 id="基础环境的不match"><a href="#基础环境的不match" class="headerlink" title="基础环境的不match"></a>基础环境的不match</h4><h5 id="中间设备的僵化"><a href="#中间设备的僵化" class="headerlink" title="中间设备的僵化"></a>中间设备的僵化</h5><p>目前，我们很多中间设备，比如防火墙、NAT网关等出现了一些默认的动作。</p><p>比如防火墙只允许通过80和443，不放通其他端口。NAT 网关在转换网络地址时重写传输层的头部，有可能导致双方无法使用新的传输格式。整流器和中间代理有时候出于安全的需要，会删除一些它们不认识的选项字段。<br>TCP 协议本来是支持端口、选项及特性的增加和修改。但是由于 TCP 协议和知名端口及选项使用的历史太悠久，中间设备已经依赖于这些潜规则，所以对这些内容的修改很容易遭到中间环节的干扰而失败。</p><p>而这些干扰，也导致很多在 TCP 协议上的优化变得小心谨慎，步履维艰。</p><h5 id="依赖于操作系统的实现导致协议僵化"><a href="#依赖于操作系统的实现导致协议僵化" class="headerlink" title="依赖于操作系统的实现导致协议僵化"></a>依赖于操作系统的实现导致协议僵化</h5><p>TCP 是由操作系统在内核西方栈层面实现的，应用程序只能使用，不能直接修改。虽然应用程序的更新迭代非常快速和简单。但是 TCP 的迭代却非常缓慢，原因就是操作系统升级很麻烦。</p><p>现在移动终端更加流行，但是移动端部分用户的操作系统升级依然可能滞后数年时间。PC 端的系统升级滞后得更加严重，windows xp 现在还有大量用户在使用，尽管它已经存在快 20 年。</p><p>服务端系统不依赖用户升级，但是由于操作系统升级涉及到底层软件和运行库的更新，所以也比较保守和缓慢。</p><p>这也就意味着即使 TCP 有比较好的特性更新，也很难快速推广。比如 TCP Fast Open。它虽然 2013 年就被提出了，但是 Windows 很多系统版本依然不支持它。</p><h4 id="连接建立快"><a href="#连接建立快" class="headerlink" title="连接建立快"></a>连接建立快</h4><p>现在，网络建立在TCP之上，因为它作为传输协议的可靠性。要启动TCP连接，将执行3次握手。这意味着每个起始连接的额外往返（网络数据包来回发送）会增加任何新连接的显着延迟。另外，如果还需要TLS创建安全加密的https连接，则需要发送更多的网络数据包。</p><p>当客户端首次发起QUIC连接时，客户端想服务器发送一个client hello消息，服务器回复一个server reject消息。该消息中有包括server config，类似于TLS1.3中的key_share交换。这需要产生1-RTT. 事实上，QUIC加密协议的作者也明确指出当前的QUIC加密协议是「注定要死掉的」(destined to die), 未来将会被TLS1.3代替。只是在QUIC提出来的时候，TLS1.3还没出生😂，这只是一个临时的加密方案。</p><p>当客户端获取到server config以后，就可以直接计算出密钥，发送应用数据了，可以认为是0-RTT。因此，QUIC握手除去首次连接需要产生1-RTT，理论上，后续握手都是0-RTT的。假设1-RTT=100ms, QUIC建立安全连接连接的握手开销为0ms, 功能上等价于TCP+TLS, 但是握手开销比建立普通的TCP连接延迟都低。</p><h4 id="更高效的拥塞控制"><a href="#更高效的拥塞控制" class="headerlink" title="更高效的拥塞控制"></a>更高效的拥塞控制</h4><p>目前的 QUIC 的拥塞控制主要实现了 TCP 的慢启动，拥塞避免，快重传，快恢复。在这些拥塞控制算法的基础上，再进行改进。</p><p>比如单调递增的 Packet Number。TCP 使用了基于字节序号 Sequence Number 和 ACK 来保证消息的有序到达。但是 Sequence Number 在重传的时候有二义性。你不知道下一个 ACK 是上一次请求的响应还是这次重传的响应。而单调递增的 Packet Number 可以避免这个问题，保证采样 RTT 的准确。</p><blockquote><p>具体改进可以参考<a href="https://zhuanlan.zhihu.com/p/32553477" target="_blank" rel="noopener">这篇文章</a></p></blockquote><p>QUIC 拥塞控制算法主要重新实现了一遍 TCP 的算法，毕竟 TCP 的算法是经过几十年的生产验证的。</p><h4 id="可插拔"><a href="#可插拔" class="headerlink" title="可插拔"></a>可插拔</h4><p>什么叫可插拔呢？就是能够非常灵活地生效，变更和停止。体现在如下方面：</p><ol><li>应用程序层面就能实现不同的拥塞控制算法，不需要操作系统，不需要内核支持。这是一个飞跃，因为传统的 TCP 拥塞控制，必须要端到端的网络协议栈支持，才能实现控制效果。而内核和操作系统的部署成本非常高，升级周期很长，这在产品快速迭代，网络爆炸式增长的今天，显然有点满足不了需求。</li><li>即使是单个应用程序的不同连接也能支持配置不同的拥塞控制。就算是一台服务器，接入的用户网络环境也千差万别，结合大数据及人工智能处理，我们能为各个用户提供不同的但又更加精准更加有效的拥塞控制。比如 BBR 适合，Cubic 适合。</li><li>应用程序不需要停机和升级就能实现拥塞控制的变更，我们在服务端只需要修改一下配置，reload 一下，完全不需要停止服务就能实现拥塞控制的切换。<br>STGW 在配置层面进行了优化，我们可以针对不同业务，不同网络制式，甚至不同的 RTT，使用不同的拥塞控制算法。<h4 id="前向纠错"><a href="#前向纠错" class="headerlink" title="前向纠错"></a>前向纠错</h4></li></ol><p>QUIC的一个很好的功能是FEC或前向纠错。发送的每个数据包还包括其他数据包的足够数据，以便可以重建丢失的数据包而无需重新传输。</p><p>这实际上是网络级别的RAID 5。</p><p>因此，需要进行权衡：每个UDP数据包包含的负载超出了严格必要的数量，因为它可以解决丢失数据包的可能性，这种数据包可以更容易地以这种方式重新创建。</p><p>当前比率似乎约为10个数据包。因此，对于每发送10个UDP数据包，有足够的数据来重建丢失的数据包。如果你愿意，可以节省10％的开销。</p><p>将前向纠错视为可以发送的“每UDP数据包数据”的牺牲，但增益不必重新发送丢失的数据包，这将花费更长的时间（收件人必须确认丢失的数据包，请求它再次等待回应）。</p><h4 id="会话恢复和并行下载"><a href="#会话恢复和并行下载" class="headerlink" title="会话恢复和并行下载"></a>会话恢复和并行下载</h4><p>在TCP中，需要四个参数建立连接，源IP、源端口和目的IP、目的端口。如果任何参数（源IP /端口或目标IP /端口）发生更改，则需要进行新的TCP连接。如果任何参数（源IP /端口或目标IP /端口）发生更改，则需要进行新的TCP连接。<br>使用QUIC，因为它现在使用UDP，所以没有四元组。</p><p>QUIC为称为Connection UUID的唯一连接实现了自己的标识符。从WiFi到LTE仍然可以保持连接UUID，因此无需重新协商连接或TLS。之前的连接仍然有效。</p><p>这与Mosh Shell的工作方式相同，通过UDP保持SSH连接，以获得更好的漫游和移动体验。</p><p>这也打开了使用多个来源获取内容的大门。如果可以通过WiFi 和蜂窝连接共享连接UUID ，理论上可以使用两种媒体来下载内容。用户可以使用拥有的每个可用界面并行地有效地流式传输或下载内容。</p><p>虽然仍然是理论上的，但UDP允许这种创新。</p><p>参考连接<a href="https://zhuanlan.zhihu.com/p/32553477" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32553477</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>明镜小结</title>
    <link href="http://yoursite.com/2019/07/25/%E6%9D%82%E8%AE%B0-MingJingNote/"/>
    <id>http://yoursite.com/2019/07/25/杂记-MingJingNote/</id>
    <published>2019-07-25T15:54:06.000Z</published>
    <updated>2019-09-17T02:41:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>将项目里遇到的坑，或者说一些优秀的想法记下来</p></blockquote><a id="more"></a><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>import(‘/src/nav.js’)是import的动态用法，返回值是一个promise，resolve的形如{ default: nav, __esModule: true }</p><h3 id="asyncComponent"><a href="#asyncComponent" class="headerlink" title="asyncComponent"></a>asyncComponent</h3><p>对于加载页面时，并未立即显示的组件，可以采用异步组件的模式按需加载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> loadComponent(getComponent)&#123;</span><br><span class="line">    <span class="built_in">return</span> class AsyncComponent extend PureComponent&#123;</span><br><span class="line">        static AsyComponent = null;</span><br><span class="line">        state = &#123;</span><br><span class="line">            AsyComponent : AsyncComponent.AsyComponent</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function"><span class="title">componentDidMount</span></span>()&#123;</span><br><span class="line">            <span class="keyword">if</span>(!this.state.AsyComponent)&#123;</span><br><span class="line">                getComponent().<span class="keyword">then</span>((&#123; default: Component &#125;) =&gt; &#123;</span><br><span class="line">                    this.setState(&#123;</span><br><span class="line">                        AsyComponent: Component</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">render</span></span>()&#123;</span><br><span class="line">            const &#123; AsyComponent &#125; = this.state;</span><br><span class="line">            <span class="built_in">return</span> (</span><br><span class="line">                <span class="keyword">if</span>(AsyComponent)&#123;</span><br><span class="line">                    &lt;AsyComponent/&gt;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">return</span> &lt;Spin title=<span class="string">'加载中....'</span>/&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps"></a>mapDispatchToProps</h3><ul><li>mapDispatchToProps用于建立组件跟store.dispatch的映射关系</li><li>可以是一个object，也可以传入函数</li><li>如果mapDispatchToProps是一个函数，它可以传入dispatch,ownProps, 定义UI组件如何发出action，实际上就是要调用dispatch这个方法</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* 假设actions是一个import进来的值为actionCreator的object */</span><br><span class="line">action.increase = <span class="keyword">function</span> (info) &#123;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="built_in">type</span>:<span class="string">'INCREASE'</span>，</span><br><span class="line">        info</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mapDispatchToProps = (dispatch, ownProps) =&gt; &#123;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    increase: (...args) =&gt; dispatch(actions.increase(...args)),</span><br><span class="line">    decrease: (...args) =&gt; dispatch(actions.decrease(...args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用actions.increase()只能得到一个 action对象{type:’INCREASE’} ，要触发这个 action必须在store 上调用 dispatch 方法。 diapatch正是 mapDispatchToProps的第一个参数。但是，为了不让 组件感知到 dispatch 的存在，需要将increase 和 decrease 两个函数包装一下，使之成为直接可被调用的函数（即，调用该方法就会触发 dispatch ）。</p><h4 id="bindActionCreator"><a href="#bindActionCreator" class="headerlink" title="bindActionCreator"></a>bindActionCreator</h4><p>bindActionCreator可以将action包装成可以被调用的函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import &#123;bindActionCreators&#125; from <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line">const mapDispatchToProps = &#123;</span><br><span class="line">&#125; = (dispatch, ownProps) =&gt; &#123;</span><br><span class="line">  <span class="built_in">return</span> bindActionCreators(&#123;</span><br><span class="line">    increase: action.increase,</span><br><span class="line">    decrease: action.decrease</span><br><span class="line">  &#125;, dispatch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 返回跟上面一样的object */</span><br><span class="line">&#123;</span><br><span class="line">   increase: (...args) =&gt; dispatch(action.increase(...args)),</span><br><span class="line">   decrease: (...args) =&gt; dispatch(action.decrease(...args)),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>如果mapDispatchToProps是一个函数, 并且传入ownProps, 当组件获取新的props的时候，mapDispatchToProps也会被调用.</li><li>传入一个object，其中这个object所对应的value必须是actionCreator，这样redux里面会自动帮我们调用bindActionCreator，所以上面又可以变成</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const mapDispatchToProps = &#123;</span><br><span class="line">    ...action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h5><p><a href="https://imweb.io/topic/5a426d32a192c3b460fce354" target="_blank" rel="noopener">https://imweb.io/topic/5a426d32a192c3b460fce354</a></p><h3 id="antd"><a href="#antd" class="headerlink" title="antd"></a>antd</h3><h4 id="CheckBox"><a href="#CheckBox" class="headerlink" title="CheckBox"></a>CheckBox</h4><ul><li>描述： form.resetFields时，不能重置checkbox</li><li>解决办法：在getFieldDecorator(key, options)的options里添加{valuePropName: ‘checked’}</li></ul><h4 id="rangePicker"><a href="#rangePicker" class="headerlink" title="rangePicker"></a>rangePicker</h4><ul><li>默认时间不显示</li><li>解决办法：用initialValue而不是defaultValue更不是defaultPickerValue</li></ul><h4 id="小常识"><a href="#小常识" class="headerlink" title="小常识"></a>小常识</h4><p>被form.create()包裹的组件，当form控件的的值方式变化的时候，会触发自定义组件的rerender。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;将项目里遇到的坑，或者说一些优秀的想法记下来&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>封培总结</title>
    <link href="http://yoursite.com/2019/07/22/%E5%B0%81%E5%9F%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/07/22/封培总结/</id>
    <published>2019-07-22T02:44:48.000Z</published>
    <updated>2020-05-27T03:49:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>正式开始接需求之前，公司安排进行了时期5天的封闭培训，真的是收获了满满的感动和‘疲惫’</p></blockquote><a id="more"></a><p>此次参加在弦上项目题目是基于供需预测的热力图方案，前端技术栈主要是react+dva+mapbox，主要实现了对于乘客端热力在历史、现在以及未来不同时间的查询与展示的基础功能，另外添加了调色板，popup，日夜间模式，更换底图以及打点的附加功能，另外因为我们有移动端的同学，因此对前端进行了适配，使之嵌套在安卓端和ios端。</p><ul><li>难点：mapbox的官方文档及其不友好，在开发过程中花费了大量的时间在查询api上。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><ul><li>帮助另外非react技术栈的同学开发。</li><li>能够为遇到的问题提供合适的解决方案。</li><li>开发热情持续高亢，五天中有三四天熬夜熬到了凌晨4点半。</li></ul><h3 id="不足："><a href="#不足：" class="headerlink" title="不足："></a>不足：</h3><ul><li>在拆分产品需求阶段，前端方面的拆分有疏漏，原因是地图相关业务知识的短缺，没有及时了解相关知识。</li><li>功能评定level部分不合理，在前后端未调通之前，主要功能方面只开发了UI部分，忽视了逻辑部分，将精力大量的投入到了换底图，打点，日夜间模式切换的功能上面。</li><li>前后端沟通不充分，因此，在遇到项目bug时，未能及时准确定位出原因，浪费了一些精力。</li><li>部分接口缺少mock。</li></ul><h3 id="收获以及感悟："><a href="#收获以及感悟：" class="headerlink" title="收获以及感悟："></a>收获以及感悟：</h3><ul><li>在项目的产品需求拆分阶段或者开发初期阶段，就应该提前了解该项目的相关业务知识。</li><li>功能拆分后，应当对需求的level进行合理的划分，而不是简单地列一下，就进行分工。</li><li>在我看来，我们小组每一位同学都尽可能地散发出了光和热，每一位同学对技术都有着极大地热情，每个人都想着去完善这个项目，最终收获了一等奖。</li></ul><p>此次在弦上培训让我意识到了什么是团队，虽然只是短暂的五天，却留下了满满的感动和’疲惫’，希望第八组的每个同学在各自的工作团队做出好成绩，也感谢在弦上的每一位教委老师，感谢教练，感谢两位运营管家，以及最后的评委老师，老师们真的提出了对我们职业生涯很重要的意见。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;正式开始接需求之前，公司安排进行了时期5天的封闭培训，真的是收获了满满的感动和‘疲惫’&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>封培总结</title>
    <link href="http://yoursite.com/2019/07/22/%E5%85%B6%E4%BB%96-%E5%B0%81%E5%9F%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/07/22/其他-封培总结/</id>
    <published>2019-07-22T02:44:48.000Z</published>
    <updated>2019-09-17T02:38:39.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>正式开始接需求之前，公司安排进行了时期5天的封闭培训，真的是收获了满满的感动和‘疲惫’</p></blockquote><a id="more"></a><p>此次参加在弦上项目题目是基于供需预测的热力图方案，前端技术栈主要是react+dva+mapbox，主要实现了对于乘客端热力在历史、现在以及未来不同时间的查询与展示的基础功能，另外添加了调色板，popup，日夜间模式，更换底图以及打点的附加功能，另外因为我们有移动端的同学，因此对前端进行了适配，使之嵌套在安卓端和ios端。</p><ul><li>难点：mapbox的官方文档及其不友好，在开发过程中花费了大量的时间在查询api上。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><ul><li>帮助另外非react技术栈的同学开发。</li><li>能够为遇到的问题提供合适的解决方案。</li><li>开发热情持续高亢，五天中有三四天熬夜熬到了凌晨4点半。</li></ul><h3 id="不足："><a href="#不足：" class="headerlink" title="不足："></a>不足：</h3><ul><li>在拆分产品需求阶段，前端方面的拆分有疏漏，原因是地图相关业务知识的短缺，没有及时了解相关知识。</li><li>功能评定level部分不合理，在前后端未调通之前，主要功能方面只开发了UI部分，忽视了逻辑部分，将精力大量的投入到了换底图，打点，日夜间模式切换的功能上面。</li><li>前后端沟通不充分，因此，在遇到项目bug时，未能及时准确定位出原因，浪费了一些精力。</li><li>部分接口缺少mock。</li></ul><h3 id="收获以及感悟："><a href="#收获以及感悟：" class="headerlink" title="收获以及感悟："></a>收获以及感悟：</h3><ul><li>在项目的产品需求拆分阶段或者开发初期阶段，就应该提前了解该项目的相关业务知识。</li><li>功能拆分后，应当对需求的level进行合理的划分，而不是简单地列一下，就进行分工。</li><li>在我看来，我们小组每一位同学都尽可能地散发出了光和热，每一位同学对技术都有着极大地热情，每个人都想着去完善这个项目，最终收获了一等奖。</li></ul><p>此次在弦上培训让我意识到了什么是团队，虽然只是短暂的五天，却留下了满满的感动和’疲惫’，希望第八组的每个同学在各自的工作团队做出好成绩，也感谢在弦上的每一位教委老师，感谢教练，感谢两位运营管家，以及最后的评委老师，老师们真的提出了对我们职业生涯很重要的意见。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;正式开始接需求之前，公司安排进行了时期5天的封闭培训，真的是收获了满满的感动和‘疲惫’&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="其他" scheme="http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>vue的diff</title>
    <link href="http://yoursite.com/2019/01/17/vue-vue%E7%9A%84diff/"/>
    <id>http://yoursite.com/2019/01/17/vue-vue的diff/</id>
    <published>2019-01-17T09:41:09.000Z</published>
    <updated>2019-09-17T02:43:30.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>昨天部门做了分享，主题是react，不知道为毛扯到了vue的diff的，之前有看过diff文章和部分源码，时间太久，发现也忘记了，于是重新去瞅了一下源码，做个总结，举了3个🌰，画了12张图，所以本文更侧重于图文，而不是源码子曰：温故而知新，古人诚不我欺。</p></blockquote><a id="more"></a><h2 id="关键源码"><a href="#关键源码" class="headerlink" title="关键源码"></a>关键源码</h2><h3 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h3><p>vue关于diff模块源码地址：<a href="https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js" target="_blank" rel="noopener">https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js</a></p><p>其中最关键的就是在404行的updateChildren的函数里，顺便加点注释，PS：最好以后面的图文为主。</p><p>规则很简单，循环体内：</p><ul><li>首先判断newStart和oldEnd是不是undefind，如果是就newStart往后移，oldEnd往前移动。（源码中用的oldStartIdx，oldEndIdx，newStartIdx，oldStartVnode指得是索引，我的描述倾向于指针，指向的是该vNode节点，没啥区别）</li><li>oldStart和newStart判断是否值得比较，若true就patch，然后newStart++，oldStart++，否则进入下一步。</li><li>oldEnd和newEnd判断是否值得比较，若true就patch，然后newEnd–，oldEnd–，否则进入下一步。</li><li>oldStart和newEnd判断是否值得比较，若true就patch，接着将oldStart所指向的真实节点移动到的oldEnd所指向的真实节点的下一个节点的前面（就是移动到oldENd的位置），然后newEnd–，oldStart++，否则进入下一步。</li><li><p>oldEnd和newStart判断是否值得比较，若true就patch，接着将oldEnd所指向的真实节点移动到oldStart的前面,然后oldEnd–，newStart++，否则进入下一步。</p></li><li><p>如果两组指针都不能判断一个newVdom是增加的还是删除，就会创建一个map，存储oldVnode的映射。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;</span><br><span class="line">    <span class="built_in">let</span> oldStartIdx = 0</span><br><span class="line">    <span class="built_in">let</span> newStartIdx = 0</span><br><span class="line">    <span class="built_in">let</span> oldEndIdx = oldCh.length - 1</span><br><span class="line">    <span class="built_in">let</span> oldStartVnode = oldCh[0]</span><br><span class="line">    <span class="built_in">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">    <span class="built_in">let</span> newEndIdx = newCh.length - 1</span><br><span class="line">    <span class="built_in">let</span> newStartVnode = newCh[0]</span><br><span class="line">    <span class="built_in">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">    <span class="built_in">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">    // removeOnly is a special flag used only by &lt;transition-group&gt;</span><br><span class="line">    // to ensure removed elements stay <span class="keyword">in</span> correct relative positions</span><br><span class="line">    // during leaving transitions</span><br><span class="line">    const canMove = !removeOnly</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      checkDuplicateKeys(newCh)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right</span><br><span class="line">        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left</span><br><span class="line">        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       /*</span><br><span class="line">          生成一个key与旧VNode的key对应的哈希表，形如&#123;oldKey0: 0,oldKey1: 1,oldKey2: 2,oldKey3:</span><br><span class="line">          3&#125;，map的KEY(olKeyn)为vnode的key值，map的VALUE(n)为该vnode在oldVnode序列的索引</span><br><span class="line">        */</span><br><span class="line">        <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        idxInOld = isDef(newStartVnode.key)</span><br><span class="line">          ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        <span class="keyword">if</span> (isUndef(idxInOld)) &#123; // New element</span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          vnodeToMove = oldCh[idxInOld]</span><br><span class="line">          <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">            oldCh[idxInOld] = undefined</span><br><span class="line">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            // same key but different element. treat as new element</span><br><span class="line">            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm</span><br><span class="line">      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="keyword">function</span> createKeyToOldIdx (children, beginIdx, endIdx) &#123;</span><br><span class="line">  <span class="built_in">let</span> i, key</span><br><span class="line">  const map = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (i = beginIdx; i &lt;= endIdx; ++i) &#123;</span><br><span class="line">    key = children[i].key</span><br><span class="line">    <span class="keyword">if</span> (isDef(key)) map[key] = i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h3><p>代码在这：<a href="https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js" target="_blank" rel="noopener">https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js</a>   第501行。<br>其实这个函数就是在两个节点值得diff的情况下，去更新差异。<br>规则如下：</p><p>1.如果新旧VNode都是静态的，同时它们的key相同（代表同一节点），并且新的VNode是clone或者是标记了once（标记v-once属性，只渲染一次），那么只需要替换elm以及componentInstance即可。</p><p>2.新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren，这个updateChildren也是diff的核心。</p><p>3.如果老节点没有子节点而新节点存在子节点，先清空老节点DOM的文本内容，然后为当前DOM节点加入子节点。</p><p>4.当新节点没有子节点而老节点有子节点的时候，则移除该DOM节点的所有子节点。</p><p>5.当新老节点都无子节点的时候，只是文本的替换。</p><h3 id="sameVnode"><a href="#sameVnode" class="headerlink" title="sameVnode"></a>sameVnode</h3><p>代码量很少就贴一下代码，其实功能就是判断两个虚拟dom节点是不是值得patch。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> sameVnode (a, b) &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    a.key === b.key &amp;&amp; (</span><br><span class="line">      (</span><br><span class="line">        a.tag === b.tag &amp;&amp;</span><br><span class="line">        a.isComment === b.isComment &amp;&amp;</span><br><span class="line">        isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class="line">        sameInputType(a, b)</span><br><span class="line">      ) || (</span><br><span class="line">        isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class="line">        a.asyncFactory === b.asyncFactory &amp;&amp;</span><br><span class="line">        isUndef(b.asyncFactory.error)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开始BB"><a href="#开始BB" class="headerlink" title="开始BB"></a>开始BB</h2><p>首先diff是对新的和老的vNode节点进行比对，比对依赖于两个东西：</p><ul><li><p>两组指针，newStart，newEnd以及oldStart，oldEnd，通过对比移动，最后比较两组值的大小，来确定删除增加移动，但并不是所有的情况都能覆盖。</p></li><li><p>一个map，是一个用来建立oldVnode的key和索引的映射关系，形如</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    oldKey0: 0,</span><br><span class="line">    oldKey1: 1,</span><br><span class="line">    oldKey2: 2,</span><br><span class="line">    oldKey3: 3,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h3><p>原来dom节点是这样的，ABCD对应节点的key分别为A，B，C，D，后来在B和C插入了一个元素X，那么在diff的时候，指针的指向如下列图所示。</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/1.jpg" alt="1"></p><h4 id="第1步"><a href="#第1步" class="headerlink" title="第1步"></a>第1步</h4><p>在满足oldStart&lt;= oldEnd &amp;&amp; newStart &lt;= newEnd时，oldStart和newStart进行对比，sameVnode函数返回true，也就是说值得比较，于是就patchVnode就是讲新产生的变化更新到真实的dom节点上，之后改变指针指向进入下一步，如图所示。</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/2.jpg" alt="2"></p><h4 id="第2步"><a href="#第2步" class="headerlink" title="第2步"></a>第2步</h4><p>接着发现newB和oldB也是值得比较的就重复上述的步骤</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/3.jpg" alt="2"></p><h4 id="第3步"><a href="#第3步" class="headerlink" title="第3步"></a>第3步</h4><p>C和X不一样，也就是说sameVnode返回的是false，那么就会比较oldEnd和newEnd，发现是值得比较的，没话说，上去就是一顿patch，然后指针都往前移，👇</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/4.jpg" alt="2"></p><h4 id="第4步"><a href="#第4步" class="headerlink" title="第4步"></a>第4步</h4><p>这个时候还是满足while的循环条件的嘛，故一顿patch之后，指针前移，👇</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/5.jpg" alt="2"></p><h4 id="第5步"><a href="#第5步" class="headerlink" title="第5步"></a>第5步</h4><p>这个时候oldEnd&gt;oldStart不满足oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx，这个时候</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/fenxi.jpeg" alt=""></p><p>oldStart &gt; oldEnd，那么newStart和newEnd所指向的节点就是新增的，反过来</p><p>newStart &gt; newEnd，那么oldStart和oldEnd所指向的节点就是被删掉的。判断出该节点的状态之后，就直接在真实的dom上去更新了，就是用的addVnodes或者removeVnodes，看着是穿进去了很多参数，其实最后，就是insert(parentEle, X, C)，其实最终变换形态就是parentEle.insertBefore(X, C)，在C前插入X，我之前一直以为会用队列进行缓存这个插入的状态，然后在Dom引擎一次更新（想到啥，写点啥），顺便说一下，所谓直接操作dom性能差的原因：</p><blockquote><ol><li>js是单线程的，但是Dom操作和js执行是在不同的引擎上的，dom进行操作时，JS引擎就得被挂起，反之亦然。</li><li>JS 代码调用 DOM API 必须经过 <em>挂起 JS 引擎、转换传入参数数据、激活 DOM 引擎</em>，DOM 重绘后再转换可能有的返回值，最后激活 JS 引擎并继续执行，再挂起Dom引擎。</li><li>若有频繁的 DOM API 调用，且浏览器厂商不做“批量处理”优化，引擎间切换的单位代价将迅速积累。</li><li>若其中有强制重绘的 DOM API 调用，不但厂商费尽心机做的“批量处理”优化被中断，<strong>重新计算布局</strong>、<strong>重新绘制图像</strong>会引起更大的性能消耗。</li></ol></blockquote><p>所以，我觉得频繁的更新Dom，频繁的切换引擎，引擎的不断挂起和激活，无疑是在消耗巨大的性能，故用个队列存一下，一次更新，避免开销，然而看源码之后，发现vue并没有做，其实很显然。。。。。。。。。。。。。。。。。。。拿队列去存储更新的dom的状态，然后循环遍历读取状态并更新也是要切换引擎的。。。。。。（竟然把一个错误的理解了这么久）。现在其实只用了头和头尾跟尾的比较，还有头跟尾，尾和头的呢？那就再举个🌰</p><h3 id="再举个🌰"><a href="#再举个🌰" class="headerlink" title="再举个🌰"></a>再举个🌰</h3><h4 id="第1步-1"><a href="#第1步-1" class="headerlink" title="第1步"></a>第1步</h4><p>原来的节点是这样的：A B C D，后来的是这样的：D C B A，ok，继续看图作文。</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/6.jpg" alt=""></p><h4 id="第2步-1"><a href="#第2步-1" class="headerlink" title="第2步"></a>第2步</h4><p>目前真实的dom和oldNodeList是一样，以后<strong><em>移动节点是在真实的dom上移动的</em></strong>。oldStart和newStart以及newEnd和oldEnd都不是值得比较，因此会进行到oldStart和newEnd的比较，patch之后开始移动，<br>根据文章一开始介绍的规则，将oldStart移动到<strong><em>oldEnd</em></strong>所指向的真实节点的下一个，也就是将A移动到D的下一个节点（及文本节点）的前面，那么真实的dom就变成了B C D A，然后移动指针</p><p>move的代码如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br></pre></td></tr></table></figure><p>nodeOps是vue对weex和web的ui变化进行封装了一些方法，比如insertBefore，removeChild，appendChild等等，在<a href="https://github.com/vuejs/vue/tree/2.6/src/platforms" target="_blank" rel="noopener">这个位置</a> 会看到两个文件夹，web和weex，各有一个runtime/node-ops.js。</p><p>如图<br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/7.jpg" alt=""></p><h4 id="第3步-1"><a href="#第3步-1" class="headerlink" title="第3步"></a>第3步</h4><p>ok，接下来就是下一次循环，还是进入oldStart与newEnd的比较，和上一步的比较规则一样，这次是把真实domB移动到D的下一个节点（即真实DomA）的前面就变成了C D B A，然后移动指针。<br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/12.jpg" alt=""></p><h4 id="第4步-1"><a href="#第4步-1" class="headerlink" title="第4步"></a>第4步</h4><p>最后一步，巧了，还是比较oldStart和newEnd，不同的是这次是domC，按照规则，是把C移动到D的下一个节点（即真实DomB）的前面，就变成了D C B A，是不是就和newVnode的顺序是一样的了。</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/8.jpg" alt=""></p><h3 id="再再举个例子"><a href="#再再举个例子" class="headerlink" title="再再举个例子"></a>再再举个例子</h3><h4 id="第1步-2"><a href="#第1步-2" class="headerlink" title="第1步"></a>第1步</h4><p>原来的dom节点是A B C D，新的是C D A B，每个节点的key对应的是自己的名称，如下图所示，这时，两组指针相互对比发现，并不能得出某个dom节点的状态，这就是两组指针不能涵盖的情况。</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/9.jpg" alt=""></p><h4 id="第2步-2"><a href="#第2步-2" class="headerlink" title="第2步"></a>第2步</h4><p>于是key就起到了作用，创建一个map{A: 0,B: 1, C: 2, D: 3}，这是一个oldVnode和key抽出来的映射，然后通过map[newStart.key]就能找到newVnode在原来老节点的位置，在这个🌰中，就是map[C]，然后对比oldVnodeC和newVnodeC，然后将差异更新到真实的dom上，然后<strong><em>将newStart对应的真实dom移动到oldStart的前面</em></strong>，也就是将真实domC放在A的前面，其实用的也是parentEle.insertBefore(C, A)然后newStart往后挪动一位，再把oldVnode中的C置为undefined，如下图所示</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/10.jpg" alt=""></p><h4 id="第3步-2"><a href="#第3步-2" class="headerlink" title="第3步"></a>第3步</h4><p>至此，本次循环就结束了，进入下一轮循环，然后会进入到oldEnd和newStart，就是oldVnode的D和newVnode的D的对比，更新差异之后，<strong><em>将oldEnd对应的真实dom移动到oldStart的前面</em></strong>，也就是把D放在A的前面，然后将oldEnd前移，newStart后移，变成下面的样子（注：当指针指向undefined时，end会前移，start会后移，所以我把箭头直接指向了B）。<br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/11.jpg" alt=""></p><h4 id="第4步-2"><a href="#第4步-2" class="headerlink" title="第4步"></a>第4步</h4><p>接下来的情况就好说了，dom和期望的顺序已经是一致的了，接下来就是运用diff的start之间的比较更新下差异就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;昨天部门做了分享，主题是react，不知道为毛扯到了vue的diff的，之前有看过diff文章和部分源码，时间太久，发现也忘记了，于是重新去瞅了一下源码，做个总结，举了3个🌰，画了12张图，所以本文更侧重于图文，而不是源码子曰：温故而知新，古人诚不我欺。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue的diff</title>
    <link href="http://yoursite.com/2019/01/17/vue%E7%9A%84diff/"/>
    <id>http://yoursite.com/2019/01/17/vue的diff/</id>
    <published>2019-01-17T09:41:09.000Z</published>
    <updated>2020-05-27T03:49:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>昨天部门做了分享，主题是react，不知道为毛扯到了vue的diff的，之前有看过diff文章和部分源码，时间太久，发现也忘记了，于是重新去瞅了一下源码，做个总结，举了3个🌰，画了12张图，所以本文更侧重于图文，而不是源码子曰：温故而知新，古人诚不我欺。</p></blockquote><a id="more"></a><h2 id="关键源码"><a href="#关键源码" class="headerlink" title="关键源码"></a>关键源码</h2><h3 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h3><p>vue关于diff模块源码地址：<a href="https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js" target="_blank" rel="noopener">https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js</a></p><p>其中最关键的就是在404行的updateChildren的函数里，顺便加点注释，PS：最好以后面的图文为主。</p><p>规则很简单，循环体内：</p><ul><li>首先判断newStart和oldEnd是不是undefind，如果是就newStart往后移，oldEnd往前移动。（源码中用的oldStartIdx，oldEndIdx，newStartIdx，oldStartVnode指得是索引，我的描述倾向于指针，指向的是该vNode节点，没啥区别）</li><li>oldStart和newStart判断是否值得比较，若true就patch，然后newStart++，oldStart++，否则进入下一步。</li><li>oldEnd和newEnd判断是否值得比较，若true就patch，然后newEnd–，oldEnd–，否则进入下一步。</li><li>oldStart和newEnd判断是否值得比较，若true就patch，接着将oldStart所指向的真实节点移动到的oldEnd所指向的真实节点的下一个节点的前面（就是移动到oldENd的位置），然后newEnd–，oldStart++，否则进入下一步。</li><li><p>oldEnd和newStart判断是否值得比较，若true就patch，接着将oldEnd所指向的真实节点移动到oldStart的前面,然后oldEnd–，newStart++，否则进入下一步。</p></li><li><p>如果两组指针都不能判断一个newVdom是增加的还是删除，就会创建一个map，存储oldVnode的映射。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;</span><br><span class="line">    <span class="built_in">let</span> oldStartIdx = 0</span><br><span class="line">    <span class="built_in">let</span> newStartIdx = 0</span><br><span class="line">    <span class="built_in">let</span> oldEndIdx = oldCh.length - 1</span><br><span class="line">    <span class="built_in">let</span> oldStartVnode = oldCh[0]</span><br><span class="line">    <span class="built_in">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">    <span class="built_in">let</span> newEndIdx = newCh.length - 1</span><br><span class="line">    <span class="built_in">let</span> newStartVnode = newCh[0]</span><br><span class="line">    <span class="built_in">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">    <span class="built_in">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">    // removeOnly is a special flag used only by &lt;transition-group&gt;</span><br><span class="line">    // to ensure removed elements stay <span class="keyword">in</span> correct relative positions</span><br><span class="line">    // during leaving transitions</span><br><span class="line">    const canMove = !removeOnly</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      checkDuplicateKeys(newCh)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right</span><br><span class="line">        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left</span><br><span class="line">        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       /*</span><br><span class="line">          生成一个key与旧VNode的key对应的哈希表，形如&#123;oldKey0: 0,oldKey1: 1,oldKey2: 2,oldKey3:</span><br><span class="line">          3&#125;，map的KEY(olKeyn)为vnode的key值，map的VALUE(n)为该vnode在oldVnode序列的索引</span><br><span class="line">        */</span><br><span class="line">        <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        idxInOld = isDef(newStartVnode.key)</span><br><span class="line">          ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        <span class="keyword">if</span> (isUndef(idxInOld)) &#123; // New element</span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          vnodeToMove = oldCh[idxInOld]</span><br><span class="line">          <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">            oldCh[idxInOld] = undefined</span><br><span class="line">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            // same key but different element. treat as new element</span><br><span class="line">            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm</span><br><span class="line">      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="keyword">function</span> createKeyToOldIdx (children, beginIdx, endIdx) &#123;</span><br><span class="line">  <span class="built_in">let</span> i, key</span><br><span class="line">  const map = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (i = beginIdx; i &lt;= endIdx; ++i) &#123;</span><br><span class="line">    key = children[i].key</span><br><span class="line">    <span class="keyword">if</span> (isDef(key)) map[key] = i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h3><p>代码在这：<a href="https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js" target="_blank" rel="noopener">https://github.com/vuejs/vue/blob/2.6/src/core/vdom/patch.js</a>   第501行。<br>其实这个函数就是在两个节点值得diff的情况下，去更新差异。<br>规则如下：</p><p>1.如果新旧VNode都是静态的，同时它们的key相同（代表同一节点），并且新的VNode是clone或者是标记了once（标记v-once属性，只渲染一次），那么只需要替换elm以及componentInstance即可。</p><p>2.新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren，这个updateChildren也是diff的核心。</p><p>3.如果老节点没有子节点而新节点存在子节点，先清空老节点DOM的文本内容，然后为当前DOM节点加入子节点。</p><p>4.当新节点没有子节点而老节点有子节点的时候，则移除该DOM节点的所有子节点。</p><p>5.当新老节点都无子节点的时候，只是文本的替换。</p><h3 id="sameVnode"><a href="#sameVnode" class="headerlink" title="sameVnode"></a>sameVnode</h3><p>代码量很少就贴一下代码，其实功能就是判断两个虚拟dom节点是不是值得patch。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> sameVnode (a, b) &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    a.key === b.key &amp;&amp; (</span><br><span class="line">      (</span><br><span class="line">        a.tag === b.tag &amp;&amp;</span><br><span class="line">        a.isComment === b.isComment &amp;&amp;</span><br><span class="line">        isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class="line">        sameInputType(a, b)</span><br><span class="line">      ) || (</span><br><span class="line">        isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class="line">        a.asyncFactory === b.asyncFactory &amp;&amp;</span><br><span class="line">        isUndef(b.asyncFactory.error)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开始BB"><a href="#开始BB" class="headerlink" title="开始BB"></a>开始BB</h2><p>首先diff是对新的和老的vNode节点进行比对，比对依赖于两个东西：</p><ul><li><p>两组指针，newStart，newEnd以及oldStart，oldEnd，通过对比移动，最后比较两组值的大小，来确定删除增加移动，但并不是所有的情况都能覆盖。</p></li><li><p>一个map，是一个用来建立oldVnode的key和索引的映射关系，形如</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    oldKey0: 0,</span><br><span class="line">    oldKey1: 1,</span><br><span class="line">    oldKey2: 2,</span><br><span class="line">    oldKey3: 3,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h3><p>原来dom节点是这样的，ABCD对应节点的key分别为A，B，C，D，后来在B和C插入了一个元素X，那么在diff的时候，指针的指向如下列图所示。</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/1.jpg" alt="1"></p><h4 id="第1步"><a href="#第1步" class="headerlink" title="第1步"></a>第1步</h4><p>在满足oldStart&lt;= oldEnd &amp;&amp; newStart &lt;= newEnd时，oldStart和newStart进行对比，sameVnode函数返回true，也就是说值得比较，于是就patchVnode就是讲新产生的变化更新到真实的dom节点上，之后改变指针指向进入下一步，如图所示。</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/2.jpg" alt="2"></p><h4 id="第2步"><a href="#第2步" class="headerlink" title="第2步"></a>第2步</h4><p>接着发现newB和oldB也是值得比较的就重复上述的步骤</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/3.jpg" alt="2"></p><h4 id="第3步"><a href="#第3步" class="headerlink" title="第3步"></a>第3步</h4><p>C和X不一样，也就是说sameVnode返回的是false，那么就会比较oldEnd和newEnd，发现是值得比较的，没话说，上去就是一顿patch，然后指针都往前移，👇</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/4.jpg" alt="2"></p><h4 id="第4步"><a href="#第4步" class="headerlink" title="第4步"></a>第4步</h4><p>这个时候还是满足while的循环条件的嘛，故一顿patch之后，指针前移，👇</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/5.jpg" alt="2"></p><h4 id="第5步"><a href="#第5步" class="headerlink" title="第5步"></a>第5步</h4><p>这个时候oldEnd&gt;oldStart不满足oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx，这个时候</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/fenxi.jpeg" alt=""></p><p>oldStart &gt; oldEnd，那么newStart和newEnd所指向的节点就是新增的，反过来</p><p>newStart &gt; newEnd，那么oldStart和oldEnd所指向的节点就是被删掉的。判断出该节点的状态之后，就直接在真实的dom上去更新了，就是用的addVnodes或者removeVnodes，看着是穿进去了很多参数，其实最后，就是insert(parentEle, X, C)，其实最终变换形态就是parentEle.insertBefore(X, C)，在C前插入X，我之前一直以为会用队列进行缓存这个插入的状态，然后在Dom引擎一次更新（想到啥，写点啥），顺便说一下，所谓直接操作dom性能差的原因：</p><blockquote><ol><li>js是单线程的，但是Dom操作和js执行是在不同的引擎上的，dom进行操作时，JS引擎就得被挂起，反之亦然。</li><li>JS 代码调用 DOM API 必须经过 <em>挂起 JS 引擎、转换传入参数数据、激活 DOM 引擎</em>，DOM 重绘后再转换可能有的返回值，最后激活 JS 引擎并继续执行，再挂起Dom引擎。</li><li>若有频繁的 DOM API 调用，且浏览器厂商不做“批量处理”优化，引擎间切换的单位代价将迅速积累。</li><li>若其中有强制重绘的 DOM API 调用，不但厂商费尽心机做的“批量处理”优化被中断，<strong>重新计算布局</strong>、<strong>重新绘制图像</strong>会引起更大的性能消耗。</li></ol></blockquote><p>所以，我觉得频繁的更新Dom，频繁的切换引擎，引擎的不断挂起和激活，无疑是在消耗巨大的性能，故用个队列存一下，一次更新，避免开销，然而看源码之后，发现vue并没有做，其实很显然。。。。。。。。。。。。。。。。。。。拿队列去存储更新的dom的状态，然后循环遍历读取状态并更新也是要切换引擎的。。。。。。（竟然把一个错误的理解了这么久）。现在其实只用了头和头尾跟尾的比较，还有头跟尾，尾和头的呢？那就再举个🌰</p><h3 id="再举个🌰"><a href="#再举个🌰" class="headerlink" title="再举个🌰"></a>再举个🌰</h3><h4 id="第1步-1"><a href="#第1步-1" class="headerlink" title="第1步"></a>第1步</h4><p>原来的节点是这样的：A B C D，后来的是这样的：D C B A，ok，继续看图作文。</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/6.jpg" alt=""></p><h4 id="第2步-1"><a href="#第2步-1" class="headerlink" title="第2步"></a>第2步</h4><p>目前真实的dom和oldNodeList是一样，以后<strong><em>移动节点是在真实的dom上移动的</em></strong>。oldStart和newStart以及newEnd和oldEnd都不是值得比较，因此会进行到oldStart和newEnd的比较，patch之后开始移动，<br>根据文章一开始介绍的规则，将oldStart移动到<strong><em>oldEnd</em></strong>所指向的真实节点的下一个，也就是将A移动到D的下一个节点（及文本节点）的前面，那么真实的dom就变成了B C D A，然后移动指针</p><p>move的代码如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br></pre></td></tr></table></figure><p>nodeOps是vue对weex和web的ui变化进行封装了一些方法，比如insertBefore，removeChild，appendChild等等，在<a href="https://github.com/vuejs/vue/tree/2.6/src/platforms" target="_blank" rel="noopener">这个位置</a> 会看到两个文件夹，web和weex，各有一个runtime/node-ops.js。</p><p>如图<br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/7.jpg" alt=""></p><h4 id="第3步-1"><a href="#第3步-1" class="headerlink" title="第3步"></a>第3步</h4><p>ok，接下来就是下一次循环，还是进入oldStart与newEnd的比较，和上一步的比较规则一样，这次是把真实domB移动到D的下一个节点（即真实DomA）的前面就变成了C D B A，然后移动指针。<br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/12.jpg" alt=""></p><h4 id="第4步-1"><a href="#第4步-1" class="headerlink" title="第4步"></a>第4步</h4><p>最后一步，巧了，还是比较oldStart和newEnd，不同的是这次是domC，按照规则，是把C移动到D的下一个节点（即真实DomB）的前面，就变成了D C B A，是不是就和newVnode的顺序是一样的了。</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/8.jpg" alt=""></p><h3 id="再再举个例子"><a href="#再再举个例子" class="headerlink" title="再再举个例子"></a>再再举个例子</h3><h4 id="第1步-2"><a href="#第1步-2" class="headerlink" title="第1步"></a>第1步</h4><p>原来的dom节点是A B C D，新的是C D A B，每个节点的key对应的是自己的名称，如下图所示，这时，两组指针相互对比发现，并不能得出某个dom节点的状态，这就是两组指针不能涵盖的情况。</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/9.jpg" alt=""></p><h4 id="第2步-2"><a href="#第2步-2" class="headerlink" title="第2步"></a>第2步</h4><p>于是key就起到了作用，创建一个map{A: 0,B: 1, C: 2, D: 3}，这是一个oldVnode和key抽出来的映射，然后通过map[newStart.key]就能找到newVnode在原来老节点的位置，在这个🌰中，就是map[C]，然后对比oldVnodeC和newVnodeC，然后将差异更新到真实的dom上，然后<strong><em>将newStart对应的真实dom移动到oldStart的前面</em></strong>，也就是将真实domC放在A的前面，其实用的也是parentEle.insertBefore(C, A)然后newStart往后挪动一位，再把oldVnode中的C置为undefined，如下图所示</p><p><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/10.jpg" alt=""></p><h4 id="第3步-2"><a href="#第3步-2" class="headerlink" title="第3步"></a>第3步</h4><p>至此，本次循环就结束了，进入下一轮循环，然后会进入到oldEnd和newStart，就是oldVnode的D和newVnode的D的对比，更新差异之后，<strong><em>将oldEnd对应的真实dom移动到oldStart的前面</em></strong>，也就是把D放在A的前面，然后将oldEnd前移，newStart后移，变成下面的样子（注：当指针指向undefined时，end会前移，start会后移，所以我把箭头直接指向了B）。<br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/11.jpg" alt=""></p><h4 id="第4步-2"><a href="#第4步-2" class="headerlink" title="第4步"></a>第4步</h4><p>接下来的情况就好说了，dom和期望的顺序已经是一致的了，接下来就是运用diff的start之间的比较更新下差异就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;昨天部门做了分享，主题是react，不知道为毛扯到了vue的diff的，之前有看过diff文章和部分源码，时间太久，发现也忘记了，于是重新去瞅了一下源码，做个总结，举了3个🌰，画了12张图，所以本文更侧重于图文，而不是源码子曰：温故而知新，古人诚不我欺。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>react的setState</title>
    <link href="http://yoursite.com/2019/01/04/react-react%E7%9A%84setState/"/>
    <id>http://yoursite.com/2019/01/04/react-react的setState/</id>
    <published>2019-01-04T10:04:57.000Z</published>
    <updated>2019-09-17T02:42:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>记得当时初学的时候，看的是《深入浅出react与redux》，学到了react与redux的基本用法，异步action的与原理，以及react-redux的原理，收获颇丰，但是对于react本身的原理倒是没有很多的阐述，最近很多人推荐《深入react技术栈》，其实这本书有点老了，但是不算过时，就去瞅了瞅。</p></blockquote><a id="more"></a><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>看书时，抱着疑问去看的，主要是为了解决这两个问题，一直以来都是一知半解，setState是异步的还是同步的？</p><h3 id="setState关键点"><a href="#setState关键点" class="headerlink" title="setState关键点"></a>setState关键点</h3><ul><li>setState不会立刻改变React组件中state的值</li><li>多次setState函数调用产生的效果会合并。</li><li>setState通过引发一次组件的更新过程来引发重新绘制，重绘指的就是引起React的更新生命周期函数4个函数：<ul><li>shouldComponentUpdate（被调用时this.state没有更新；如果返回了false，生命周期被中断，虽然不调用之后的函数了，但是state仍然会被更新）</li><li>componentWillUpdate（被调用时this.state没有更新）</li><li>render（被调用时this.state得到更新）</li><li>componentDidUpdate</li></ul></li></ul><p>首先举个🌰，修改了《深入react技术栈》中的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    num:0</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span></span>()&#123;</span><br><span class="line">    this.setState(&#123; </span><br><span class="line">      num: this.state.num+1</span><br><span class="line">     &#125;);</span><br><span class="line">     console.log(this.state.num);</span><br><span class="line">     this.setState(&#123; </span><br><span class="line">      num: this.state.num+1</span><br><span class="line">     &#125;);</span><br><span class="line">     console.log(this.state.num);</span><br><span class="line"></span><br><span class="line">     setTimeout(() =&gt; &#123;</span><br><span class="line">      this.setState(&#123; </span><br><span class="line">        num:this.state.num+1</span><br><span class="line">       &#125;)</span><br><span class="line">       console.log(<span class="string">'timeout'</span>, this.state.num);</span><br><span class="line">        this.setState(&#123; </span><br><span class="line">          num:this.state.num+1</span><br><span class="line">         &#125;)</span><br><span class="line">         console.log(<span class="string">'timeout'</span>, this.state.num);</span><br><span class="line">        &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidUpdate</span></span>()&#123;</span><br><span class="line">    // console.log(<span class="string">'update'</span>,this.state.num);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'rendering'</span>, this.state.num)</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">        &lt;p&gt;&#123;this.state.num&#125;&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出是这样的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rendering 0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">rendering 1</span><br><span class="line">rendering 2</span><br><span class="line">timeout 2</span><br><span class="line">rendering 3</span><br><span class="line">timeout 3</span><br></pre></td></tr></table></figure><p>看起来setState好像是异步的，state的值并没有立刻发生变化，但是setTimeout里setState却立刻更新了，瞅了一眼源码发现了这样一串代码。</p><figure class="highlight plain"><figcaption><span>enqueueUpdate(component) &#123;</span><a href="//">...  if (!batchingStrategy.isBatchingUpdates) &#123;    batchingStrategy.batchedUpdates(enqueueUpdate, component);    return;  &#125;  dirtyComponents.push(component);&#125;</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function enqueueUpdate(component) &#123;</span><br><span class="line">  ensureInjected();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Various parts of our code (such as ReactCompositeComponent&#39;s</span><br><span class="line">  &#x2F;&#x2F; _renderValidatedComponent) assume that calls to render aren&#39;t nested;</span><br><span class="line">  &#x2F;&#x2F; verify that that&#39;s the case. (This is called by each top-level update</span><br><span class="line">  &#x2F;&#x2F; function, like setProps, setState, forceUpdate, etc.; creation and</span><br><span class="line">  &#x2F;&#x2F; destruction of top-level components is guarded in ReactMount.)</span><br><span class="line"></span><br><span class="line">  if (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dirtyComponents.push(component);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>react在数据更新时，并不会立刻触发render，而是通过一个队列去缓存，然后通过isBatchingUpdates这个变量判断当前是否立刻更新。isBatchingUpdates默认是false，也就表示setState会同步更新this.state，当React在调用事件处理函数之前就会调用batchedUpdates，这个函数会把isBatchingUpdates修改为true，在componentDidMount时，这个值已经被置为true，所以两次setState并没有立刻改变state的值，而是缓存了起来，而setTimeout的回调函数在执行时，isBatchingUpdates这个值又被重置为false，所以settimeout离得setState是立刻更新state并触发render的，addEventListener也是和setTimeout一样的效果。</p><p><strong>所以，究其根本，setState本身就是同步的，它的实现内部没有用到eventLoop，全都是同步代码，所以在setTimeout里是上述情形</strong>，我们写的每一个组价都是函数，都是跑在react里的，他屏蔽了很多细节，包括setState改变state的机制。</p><h3 id="setState另一个用法"><a href="#setState另一个用法" class="headerlink" title="setState另一个用法"></a>setState另一个用法</h3><p>setState(nextState, callback)，指明callback，nextState会立即与当前state进行合并。</p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>seState会引发视图重新渲染，无论state有没有改变，就算传一个空对象进去，也会引发重绘，所以往往需要shouldComponentUpdate来进行优化，它的参数是nextProps和nextState，可以通过和当前的state，props进行比较，如果一致，就return false，阻止render函数调用。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记得当时初学的时候，看的是《深入浅出react与redux》，学到了react与redux的基本用法，异步action的与原理，以及react-redux的原理，收获颇丰，但是对于react本身的原理倒是没有很多的阐述，最近很多人推荐《深入react技术栈》，其实这本书有点老了，但是不算过时，就去瞅了瞅。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react的setState</title>
    <link href="http://yoursite.com/2019/01/04/react%E7%9A%84setState/"/>
    <id>http://yoursite.com/2019/01/04/react的setState/</id>
    <published>2019-01-04T10:04:57.000Z</published>
    <updated>2020-05-27T03:49:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>记得当时初学的时候，看的是《深入浅出react与redux》，学到了react与redux的基本用法，异步action的与原理，以及react-redux的原理，收获颇丰，但是对于react本身的原理倒是没有很多的阐述，最近很多人推荐《深入react技术栈》，其实这本书有点老了，但是不算过时，就去瞅了瞅。</p></blockquote><a id="more"></a><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>看书时，抱着疑问去看的，主要是为了解决这两个问题，一直以来都是一知半解，setState是异步的还是同步的？</p><h3 id="setState关键点"><a href="#setState关键点" class="headerlink" title="setState关键点"></a>setState关键点</h3><ul><li>setState不会立刻改变React组件中state的值</li><li>多次setState函数调用产生的效果会合并。</li><li>setState通过引发一次组件的更新过程来引发重新绘制，重绘指的就是引起React的更新生命周期函数4个函数：<ul><li>shouldComponentUpdate（被调用时this.state没有更新；如果返回了false，生命周期被中断，虽然不调用之后的函数了，但是state仍然会被更新）</li><li>componentWillUpdate（被调用时this.state没有更新）</li><li>render（被调用时this.state得到更新）</li><li>componentDidUpdate</li></ul></li></ul><p>首先举个🌰，修改了《深入react技术栈》中的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    num:0</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span></span>()&#123;</span><br><span class="line">    this.setState(&#123; </span><br><span class="line">      num: this.state.num+1</span><br><span class="line">     &#125;);</span><br><span class="line">     console.log(this.state.num);</span><br><span class="line">     this.setState(&#123; </span><br><span class="line">      num: this.state.num+1</span><br><span class="line">     &#125;);</span><br><span class="line">     console.log(this.state.num);</span><br><span class="line"></span><br><span class="line">     setTimeout(() =&gt; &#123;</span><br><span class="line">      this.setState(&#123; </span><br><span class="line">        num:this.state.num+1</span><br><span class="line">       &#125;)</span><br><span class="line">       console.log(<span class="string">'timeout'</span>, this.state.num);</span><br><span class="line">        this.setState(&#123; </span><br><span class="line">          num:this.state.num+1</span><br><span class="line">         &#125;)</span><br><span class="line">         console.log(<span class="string">'timeout'</span>, this.state.num);</span><br><span class="line">        &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidUpdate</span></span>()&#123;</span><br><span class="line">    // console.log(<span class="string">'update'</span>,this.state.num);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'rendering'</span>, this.state.num)</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">        &lt;p&gt;&#123;this.state.num&#125;&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出是这样的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rendering 0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">rendering 1</span><br><span class="line">rendering 2</span><br><span class="line">timeout 2</span><br><span class="line">rendering 3</span><br><span class="line">timeout 3</span><br></pre></td></tr></table></figure><p>看起来setState好像是异步的，state的值并没有立刻发生变化，但是setTimeout里setState却立刻更新了，瞅了一眼源码发现了这样一串代码。</p><figure class="highlight plain"><figcaption><span>enqueueUpdate(component) &#123;</span><a href="//">...  if (!batchingStrategy.isBatchingUpdates) &#123;    batchingStrategy.batchedUpdates(enqueueUpdate, component);    return;  &#125;  dirtyComponents.push(component);&#125;</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function enqueueUpdate(component) &#123;</span><br><span class="line">  ensureInjected();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Various parts of our code (such as ReactCompositeComponent&#39;s</span><br><span class="line">  &#x2F;&#x2F; _renderValidatedComponent) assume that calls to render aren&#39;t nested;</span><br><span class="line">  &#x2F;&#x2F; verify that that&#39;s the case. (This is called by each top-level update</span><br><span class="line">  &#x2F;&#x2F; function, like setProps, setState, forceUpdate, etc.; creation and</span><br><span class="line">  &#x2F;&#x2F; destruction of top-level components is guarded in ReactMount.)</span><br><span class="line"></span><br><span class="line">  if (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dirtyComponents.push(component);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>react在数据更新时，并不会立刻触发render，而是通过一个队列去缓存，然后通过isBatchingUpdates这个变量判断当前是否立刻更新。isBatchingUpdates默认是false，也就表示setState会同步更新this.state，当React在调用事件处理函数之前就会调用batchedUpdates，这个函数会把isBatchingUpdates修改为true，在componentDidMount时，这个值已经被置为true，所以两次setState并没有立刻改变state的值，而是缓存了起来，而setTimeout的回调函数在执行时，isBatchingUpdates这个值又被重置为false，所以settimeout离得setState是立刻更新state并触发render的，addEventListener也是和setTimeout一样的效果。</p><p><strong>所以，究其根本，setState本身就是同步的，它的实现内部没有用到eventLoop，全都是同步代码，所以在setTimeout里是上述情形</strong>，我们写的每一个组价都是函数，都是跑在react里的，他屏蔽了很多细节，包括setState改变state的机制。</p><h3 id="setState另一个用法"><a href="#setState另一个用法" class="headerlink" title="setState另一个用法"></a>setState另一个用法</h3><p>setState(nextState, callback)，指明callback，nextState会立即与当前state进行合并。</p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>seState会引发视图重新渲染，无论state有没有改变，就算传一个空对象进去，也会引发重绘，所以往往需要shouldComponentUpdate来进行优化，它的参数是nextProps和nextState，可以通过和当前的state，props进行比较，如果一致，就return false，阻止render函数调用。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记得当时初学的时候，看的是《深入浅出react与redux》，学到了react与redux的基本用法，异步action的与原理，以及react-redux的原理，收获颇丰，但是对于react本身的原理倒是没有很多的阐述，最近很多人推荐《深入react技术栈》，其实这本书有点老了，但是不算过时，就去瞅了瞅。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>selfPromise</title>
    <link href="http://yoursite.com/2018/12/31/js-selfPromise/"/>
    <id>http://yoursite.com/2018/12/31/js-selfPromise/</id>
    <published>2018-12-30T16:34:38.000Z</published>
    <updated>2019-09-17T02:42:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>把之前手写过的promise在梳理一遍</p></blockquote><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">var PENDING = 0;</span><br><span class="line">var FULFILLED = 1;</span><br><span class="line">var REJECTED = 2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> myPromise(fn) &#123;</span><br><span class="line">    var state = PENDING;</span><br><span class="line">    var value = null;</span><br><span class="line">    var handlers = [];</span><br><span class="line">    var e =null;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> resolve(val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val instanceof myPromise) &#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                val.then(resolve);</span><br><span class="line">            &#125;catch(e)&#123;</span><br><span class="line">                reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        state = FULFILLED;</span><br><span class="line">        value = val;</span><br><span class="line">        setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            handlers.map(<span class="keyword">function</span> (handler) &#123;</span><br><span class="line">                handle(handler)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, 0)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> reject(err) &#123;</span><br><span class="line">        state = REJECTED;</span><br><span class="line">        e = err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> handle(handler) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state === PENDING) &#123;</span><br><span class="line">            handlers.push(handler);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            <span class="keyword">if</span> (state === FULFILLED &amp;&amp; typeof handler.onFulfilled === <span class="string">'function'</span>) &#123;</span><br><span class="line">                <span class="built_in">let</span> ret = handler.onFulfilled(value);</span><br><span class="line">                handler.resolve(ret);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(e)&#123;</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//onFulfilled, onRejected是可选参数，如果不是函数可以忽略</span><br><span class="line">    this.then = <span class="keyword">function</span> (onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="built_in">return</span> new myPromise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">            handle(&#123;</span><br><span class="line">                onFulfilled,</span><br><span class="line">                resolve,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn(resolve, reject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：状态切换就不说了，很显然。</p><p>then函数将回调注册到promise内部的队列里，在resolve里遍历调用，要注意的是，resolve执行时，得是异步，要在then注册完之后调用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">new myPromise(<span class="keyword">function</span>(resolve)&#123;</span><br><span class="line">    GET(url, <span class="keyword">function</span>(data1)&#123;</span><br><span class="line">        resolve(data1)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="keyword">function</span>(data1)&#123;</span><br><span class="line">const toChainPoromise = new myPromise(<span class="keyword">function</span>(resolve)&#123;</span><br><span class="line">    POST(url, <span class="keyword">function</span>(data2)&#123;</span><br><span class="line">             resolve(data1+data2)</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">return</span> toChainPoromise;</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="keyword">function</span>(data)&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>为了链式调用，then函数的返回值一定是个promise，但是在第二个then里回调函数接受的数据data应该依赖于toChainPoromise，而不是then函数本身返回的promise，所以then函数既要把toChainPoromise和后面的then衔接起来。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;把之前手写过的promise在梳理一遍&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>selfPromise</title>
    <link href="http://yoursite.com/2018/12/31/selfPromise/"/>
    <id>http://yoursite.com/2018/12/31/selfPromise/</id>
    <published>2018-12-30T16:34:38.000Z</published>
    <updated>2020-05-27T03:49:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>把之前手写过的promise在梳理一遍</p></blockquote><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">var PENDING = 0;</span><br><span class="line">var FULFILLED = 1;</span><br><span class="line">var REJECTED = 2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> myPromise(fn) &#123;</span><br><span class="line">    var state = PENDING;</span><br><span class="line">    var value = null;</span><br><span class="line">    var handlers = [];</span><br><span class="line">    var e =null;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> resolve(val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val instanceof myPromise) &#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                val.then(resolve);</span><br><span class="line">            &#125;catch(e)&#123;</span><br><span class="line">                reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        state = FULFILLED;</span><br><span class="line">        value = val;</span><br><span class="line">        setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            handlers.map(<span class="keyword">function</span> (handler) &#123;</span><br><span class="line">                handle(handler)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, 0)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> reject(err) &#123;</span><br><span class="line">        state = REJECTED;</span><br><span class="line">        e = err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> handle(handler) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state === PENDING) &#123;</span><br><span class="line">            handlers.push(handler);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            <span class="keyword">if</span> (state === FULFILLED &amp;&amp; typeof handler.onFulfilled === <span class="string">'function'</span>) &#123;</span><br><span class="line">                <span class="built_in">let</span> ret = handler.onFulfilled(value);</span><br><span class="line">                handler.resolve(ret);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(e)&#123;</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//onFulfilled, onRejected是可选参数，如果不是函数可以忽略</span><br><span class="line">    this.then = <span class="keyword">function</span> (onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="built_in">return</span> new myPromise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">            handle(&#123;</span><br><span class="line">                onFulfilled,</span><br><span class="line">                resolve,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn(resolve, reject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：状态切换就不说了，很显然。</p><p>then函数将回调注册到promise内部的队列里，在resolve里遍历调用，要注意的是，resolve执行时，得是异步，要在then注册完之后调用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">new myPromise(<span class="keyword">function</span>(resolve)&#123;</span><br><span class="line">    GET(url, <span class="keyword">function</span>(data1)&#123;</span><br><span class="line">        resolve(data1)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="keyword">function</span>(data1)&#123;</span><br><span class="line">const toChainPoromise = new myPromise(<span class="keyword">function</span>(resolve)&#123;</span><br><span class="line">    POST(url, <span class="keyword">function</span>(data2)&#123;</span><br><span class="line">             resolve(data1+data2)</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">return</span> toChainPoromise;</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="keyword">function</span>(data)&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>为了链式调用，then函数的返回值一定是个promise，但是在第二个then里回调函数接受的数据data应该依赖于toChainPoromise，而不是then函数本身返回的promise，所以then函数既要把toChainPoromise和后面的then衔接起来。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;把之前手写过的promise在梳理一遍&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>git杂记</title>
    <link href="http://yoursite.com/2018/12/07/%E6%9D%82%E8%AE%B0-git%E6%9D%82%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/12/07/杂记-git杂记/</id>
    <published>2018-12-07T08:33:09.000Z</published>
    <updated>2019-09-17T02:39:55.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不会git的程序员啥也不是。ps:作为杂记篇，持续更新，对工作上遇到的问题做个积累。<br><a id="more"></a></p><h3 id="git的三个区域"><a href="#git的三个区域" class="headerlink" title="git的三个区域"></a>git的三个区域</h3><ul><li>工作区，就是在编辑器里看到的那些代码</li><li>缓存区，通过git add将指定文件添加到此区域</li><li>版本库，通过git commit可以将文件存缓存区提交到此区域，其实就是提交记录的集合，可以通过commitId进行回滚，也可以将此次提交push到远程仓库。</li></ul><h3 id="commitID"><a href="#commitID" class="headerlink" title="commitID"></a>commitID</h3><p>形如 1953<em>*</em>6c4ed4的这个东东，就是文件进行改动后，通过git commit命令生成的，可以当做一次提交的唯一标识，之后可以通过git reset/revert/checkout回滚。查看提交记录，可以使用  git log 或者git log  –oneline</p><h3 id="一些常用的命令"><a href="#一些常用的命令" class="headerlink" title="一些常用的命令"></a>一些常用的命令</h3><h4 id="git-status-gst"><a href="#git-status-gst" class="headerlink" title="git status (gst)"></a>git status (gst)</h4><p>当你处于我是谁我在哪我要干嘛的状态时，你可以通过这个命令查看你之前改动了什么，你的工作目录处于一个什么样的工作状态。</p><h4 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h4><p>查看本地分支已经存在的分支，当前分支带*。</p><ul><li>-r 查看远程分支</li><li>dev 加分支名，创建分支dev</li><li>-d dev 删除分支dev</li></ul><h4 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h4><ul><li><p>dev 切换到dev分支上，然后更新工作目录。</p></li><li><p>-b dev 创建dev分支，并切换， <strong>创建分支时，会复制当前分支的代码，多方协作时，最好先切换到master，并且git pull之后在创建并切换分支</strong>。</p></li><li><p>commitID file<br>查看文件之前的版本。它将工作目录中的 file 文件变成 commitID 中那个文件的拷贝，并将它加入缓存区。</p></li><li><p>commitID<br>更新工作目录中的所有文件，使得和某个特定提交中的文件一致。你可以将提交的哈希字串，或是标签作为 commitID参数。这会使指针处于分离HEAD的状态，然后你git log发现，woc，这之后的提交记录都没了，GG了。其实这个时候git checkout加你的分支名，就又回来了，这就是所谓的分支HEAD的意思，他就像一个虚拟的分支，你也可以再次状态下在复制一份创建分支。</p></li><li><p>-b dev origin/dev<br>  将上游dev分支拉取到本地，而且他的commit记录是完全复制自上游dev的，和之前所在的分支没有半毛钱关系。</p></li><li><p>-track origin/dev<br>  创建本地分支并关联</p><h4 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h4><p>如果你在现在的分支做了一半的工作，想切回其他的分支，直接checkout，往往会报错，add+commit的话，自己的提交记录又是一团糟，就可以使用这个命令将更改暂时存储到git的一个堆栈，然后就可以放心地切换到其他分支工作，最后切回来时，使用git  stash pop就可以恢复你的修改继续工作。PS:git stash是将修改提交到本地，并不会随着push推到远程。</p></li></ul><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>将上游更改拉下来与本地合并，相当于git fetch和git  merge，如果该分支尚未与上游关联则要加origin dev。（dev为分支名）</p><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git  revert"></a>git  revert</h3><p>Revert 撤销一个提交的同时会创建一个新的提交。这是一个安全的方法，因为它不会重写提交历史。比如，下面的命令会找出倒数第二个提交，然后创建一个新的提交来撤销这些更改，然后把这个提交加入项目中。</p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git  reset"></a>git  reset</h3><p>这个命令可以消除提交记录，比如git reset HEAD~2，你的最后的两次提交记录就没了，但是你的工作区，并没有改变，可以通过这个命令让你的提交记录整洁起来。<br><br>如果你加上–hard，那么你的工作区就会和你回到reset的那个状态，但是新增的文件依旧存在。</p><table><thead><tr><th>命令</th><th>作用域</th><th>常用场景</th></tr></thead><tbody><tr><td>git reset</td><td>提交层面</td><td>在私有分支上舍弃一些没有提交的更改</td></tr><tr><td>git reset</td><td></td><td>文件层面</td><td>将文件从缓存区中移除</td></tr><tr><td>git checkout</td><td>提交层面</td><td>切换分支或查看旧版本</td></tr><tr><td>git checkout</td><td>文件层面</td><td>舍弃工作目录中的更改</td></tr><tr><td>git revert</td><td>提交层面</td><td>在公共分支上回滚更改</td></tr></tbody></table><ul><li><p><a href="https://github.com/xuyonglin222/git-recipes/blob/master/sources/1-%E6%9E%9C%E5%A3%B3%E4%B8%AD%E7%9A%84Git.md" target="_blank" rel="noopener">git好文</a></p></li><li><p><a href="https://learngitbranching.js.org" target="_blank" rel="noopener">一个有意思的学习git的网站</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不会git的程序员啥也不是。ps:作为杂记篇，持续更新，对工作上遇到的问题做个积累。&lt;br&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="http://yoursite.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>git杂记</title>
    <link href="http://yoursite.com/2018/12/07/git%E6%9D%82%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/12/07/git杂记/</id>
    <published>2018-12-07T08:33:09.000Z</published>
    <updated>2020-05-27T03:49:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不会git的程序员啥也不是。ps:作为杂记篇，持续更新，对工作上遇到的问题做个积累。<br><a id="more"></a></p><h3 id="git的三个区域"><a href="#git的三个区域" class="headerlink" title="git的三个区域"></a>git的三个区域</h3><ul><li>工作区，就是在编辑器里看到的那些代码</li><li>缓存区，通过git add将指定文件添加到此区域</li><li>版本库，通过git commit可以将文件存缓存区提交到此区域，其实就是提交记录的集合，可以通过commitId进行回滚，也可以将此次提交push到远程仓库。</li></ul><h3 id="commitID"><a href="#commitID" class="headerlink" title="commitID"></a>commitID</h3><p>形如 1953<em>*</em>6c4ed4的这个东东，就是文件进行改动后，通过git commit命令生成的，可以当做一次提交的唯一标识，之后可以通过git reset/revert/checkout回滚。查看提交记录，可以使用  git log 或者git log  –oneline</p><h3 id="一些常用的命令"><a href="#一些常用的命令" class="headerlink" title="一些常用的命令"></a>一些常用的命令</h3><h4 id="git-status-gst"><a href="#git-status-gst" class="headerlink" title="git status (gst)"></a>git status (gst)</h4><p>当你处于我是谁我在哪我要干嘛的状态时，你可以通过这个命令查看你之前改动了什么，你的工作目录处于一个什么样的工作状态。</p><h4 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h4><p>查看本地分支已经存在的分支，当前分支带*。</p><ul><li>-r 查看远程分支</li><li>dev 加分支名，创建分支dev</li><li>-d dev 删除分支dev</li></ul><h4 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h4><ul><li><p>dev 切换到dev分支上，然后更新工作目录。</p></li><li><p>-b dev 创建dev分支，并切换， <strong>创建分支时，会复制当前分支的代码，多方协作时，最好先切换到master，并且git pull之后在创建并切换分支</strong>。</p></li><li><p>commitID file<br>查看文件之前的版本。它将工作目录中的 file 文件变成 commitID 中那个文件的拷贝，并将它加入缓存区。</p></li><li><p>commitID<br>更新工作目录中的所有文件，使得和某个特定提交中的文件一致。你可以将提交的哈希字串，或是标签作为 commitID参数。这会使指针处于分离HEAD的状态，然后你git log发现，woc，这之后的提交记录都没了，GG了。其实这个时候git checkout加你的分支名，就又回来了，这就是所谓的分支HEAD的意思，他就像一个虚拟的分支，你也可以再次状态下在复制一份创建分支。</p></li><li><p>-b dev origin/dev<br>  将上游dev分支拉取到本地，而且他的commit记录是完全复制自上游dev的，和之前所在的分支没有半毛钱关系。</p></li></ul><h4 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h4><p>如果你在现在的分支做了一半的工作，想切回其他的分支，直接checkout，往往会报错，add+commit的话，自己的提交记录又是一团糟，就可以使用这个命令将更改暂时存储到git的一个堆栈，然后就可以放心地切换到其他分支工作，最后切回来时，使用git  stash pop就可以恢复你的修改继续工作。PS:git stash是将修改提交到本地，并不会随着push推到远程。</p><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>将上游更改拉下来与本地合并，相当于git fetch和git  merge，如果该分支尚未与上游关联则要加origin dev。（dev为分支名）</p><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git  revert"></a>git  revert</h3><p>Revert 撤销一个提交的同时会创建一个新的提交。这是一个安全的方法，因为它不会重写提交历史。比如，下面的命令会找出倒数第二个提交，然后创建一个新的提交来撤销这些更改，然后把这个提交加入项目中。</p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git  reset"></a>git  reset</h3><p>这个命令可以消除提交记录，比如git reset HEAD~2，你的最后的两次提交记录就没了，但是你的工作区，并没有改变，可以通过这个命令让你的提交记录整洁起来。<br><br>如果你加上–hard，那么你的工作区就会和你回到reset的那个状态，但是新增的文件依旧存在。</p><table><thead><tr><th>命令</th><th>作用域</th><th>常用场景</th></tr></thead><tbody><tr><td>git reset</td><td>提交层面</td><td>在私有分支上舍弃一些没有提交的更改</td></tr><tr><td>git reset</td><td></td><td>文件层面</td><td>将文件从缓存区中移除</td></tr><tr><td>git checkout</td><td>提交层面</td><td>切换分支或查看旧版本</td></tr><tr><td>git checkout</td><td>文件层面</td><td>舍弃工作目录中的更改</td></tr><tr><td>git revert</td><td>提交层面</td><td>在公共分支上回滚更改</td></tr></tbody></table><ul><li><p><a href="https://github.com/xuyonglin222/git-recipes/blob/master/sources/1-%E6%9E%9C%E5%A3%B3%E4%B8%AD%E7%9A%84Git.md" target="_blank" rel="noopener">git好文</a></p></li><li><p><a href="https://learngitbranching.js.org" target="_blank" rel="noopener">一个有意思的学习git的网站</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不会git的程序员啥也不是。ps:作为杂记篇，持续更新，对工作上遇到的问题做个积累。&lt;br&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="http://yoursite.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>koaMiddleWare</title>
    <link href="http://yoursite.com/2018/08/07/koaMiddle/"/>
    <id>http://yoursite.com/2018/08/07/koaMiddle/</id>
    <published>2018-08-07T13:09:48.000Z</published>
    <updated>2020-05-27T03:49:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="js的异步解决方案"><a href="#js的异步解决方案" class="headerlink" title="js的异步解决方案"></a>js的异步解决方案</h3><p>在javascript里，异步的解决方案包括以下几种：</p><ul><li>回调</li><li>promise</li><li>generator</li><li>async<br>优雅程度自上而下。<a id="more"></a></li></ul><h3 id="express-koa1-koa2"><a href="#express-koa1-koa2" class="headerlink" title="express koa1 koa2"></a>express koa1 koa2</h3><p>随着社会的不断发展和进步，emmmmm，express团队从一开始陆续搞出了express、koa1和koa2，为毛他们闲着没事干，搞这么多起相同功能的轮子呢？不知道老子学不动了吗?（开玩笑<br></p><p>koa相比express，轻量了不少，看官方文档就能知道，其实之所以重复造轮子，应该是因为异步的解决方案。<br><br></p><p>在express中，处理异步的方式，就是回调，如果回调太深的话，恶心程度可想而知，koa1主要是用generator函数做中间件函数，koa2是用async函数。<br>个人认为async最为优雅。使用方式不同，是因为内部对中间件函数的处理不同，looklook。<br></p><h3 id="application-js"><a href="#application-js" class="headerlink" title="application.js"></a>application.js</h3><p>koa的源码也就4个文件，在下主要看了application.js,代码以及部分注释如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Module dependencies.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">const isGeneratorFunction = require(<span class="string">'is-generator-function'</span>);</span><br><span class="line">const debug = require(<span class="string">'debug'</span>)(<span class="string">'koa:application'</span>);</span><br><span class="line">const onFinished = require(<span class="string">'on-finished'</span>);</span><br><span class="line">const response = require(<span class="string">'./response'</span>);</span><br><span class="line">const compose = require(<span class="string">'koa-compose'</span>);</span><br><span class="line">const isJSON = require(<span class="string">'koa-is-json'</span>);</span><br><span class="line">const context = require(<span class="string">'./context'</span>);</span><br><span class="line">const request = require(<span class="string">'./request'</span>);</span><br><span class="line">const statuses = require(<span class="string">'statuses'</span>);</span><br><span class="line">const Emitter = require(<span class="string">'events'</span>);</span><br><span class="line">const util = require(<span class="string">'util'</span>);</span><br><span class="line">const Stream = require(<span class="string">'stream'</span>);</span><br><span class="line">const http = require(<span class="string">'http'</span>);</span><br><span class="line">const only = require(<span class="string">'only'</span>);</span><br><span class="line">const convert = require(<span class="string">'koa-convert'</span>);</span><br><span class="line">const deprecate = require(<span class="string">'depd'</span>)(<span class="string">'koa'</span>);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Expose `Application` class.</span><br><span class="line"> * Inherits from `Emitter.prototype`.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"> //继承Emitter  因此 koa的实例 this可以调用on</span><br><span class="line">module.exports = class Application extends Emitter &#123;</span><br><span class="line">  /**</span><br><span class="line">   * Initialize a new `Application`.</span><br><span class="line">   *</span><br><span class="line">   * @api public</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    super();</span><br><span class="line"></span><br><span class="line">    this.proxy = <span class="literal">false</span>; //代理设置</span><br><span class="line">    this.middleware = [];</span><br><span class="line">    this.subdomainOffset = 2; //域名偏移</span><br><span class="line">    this.env = process.env.NODE_ENV || <span class="string">'development'</span>;</span><br><span class="line">    this.context = Object.create(context);</span><br><span class="line">    this.request = Object.create(request);</span><br><span class="line">    this.response = Object.create(response);</span><br><span class="line">    <span class="keyword">if</span> (util.inspect.custom) &#123;</span><br><span class="line">      this[util.inspect.custom] = this.inspect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Shorthand <span class="keyword">for</span>:</span><br><span class="line">   *</span><br><span class="line">   *    http.createServer(app.callback()).listen(...)</span><br><span class="line">   *</span><br><span class="line">   * @param &#123;Mixed&#125; ...</span><br><span class="line">   * @<span class="built_in">return</span> &#123;Server&#125;</span><br><span class="line">   * @api public</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  listen(...args) &#123;</span><br><span class="line">    debug(<span class="string">'listen'</span>);</span><br><span class="line">    const server = http.createServer(this.callback());</span><br><span class="line">    <span class="built_in">return</span> server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Return JSON representation.</span><br><span class="line">   * We only bother showing settings.</span><br><span class="line">   *</span><br><span class="line">   * @<span class="built_in">return</span> &#123;Object&#125;</span><br><span class="line">   * @api public</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toJSON</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> only(this, [</span><br><span class="line">      <span class="string">'subdomainOffset'</span>,</span><br><span class="line">      <span class="string">'proxy'</span>,</span><br><span class="line">      <span class="string">'env'</span></span><br><span class="line">    ]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Inspect implementation.</span><br><span class="line">   *</span><br><span class="line">   * @<span class="built_in">return</span> &#123;Object&#125;</span><br><span class="line">   * @api public</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">inspect</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.toJSON();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Use the given middleware `fn`.</span><br><span class="line">   *</span><br><span class="line">   * Old-style middleware will be converted.</span><br><span class="line">   *</span><br><span class="line">   * @param &#123;Function&#125; fn</span><br><span class="line">   * @<span class="built_in">return</span> &#123;Application&#125; self</span><br><span class="line">   * @api public</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  //对 generator 函数利用 koa-convert 库进行转化(将 generator 函数包装成 Promise),</span><br><span class="line">  //如果不是则不转化, 然后将这个中间件函数 push 进实例对象的 middleware 数组中.</span><br><span class="line">  use(fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeof fn !== <span class="string">'function'</span>) throw new TypeError(<span class="string">'middleware must be a function!'</span>);</span><br><span class="line">    <span class="keyword">if</span> (isGeneratorFunction(fn)) &#123;</span><br><span class="line">      deprecate(<span class="string">'Support for generators will be removed in v3. '</span> +</span><br><span class="line">                <span class="string">'See the documentation for examples of how to convert old middleware '</span> +</span><br><span class="line">                <span class="string">'https://github.com/koajs/koa/blob/master/docs/migration.md'</span>);</span><br><span class="line">      fn = convert(fn);</span><br><span class="line">    &#125;</span><br><span class="line">    debug(<span class="string">'use %s'</span>, fn._name || fn.name || <span class="string">'-'</span>);</span><br><span class="line">    this.middleware.push(fn);</span><br><span class="line">    <span class="built_in">return</span> this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Return a request handler callback</span><br><span class="line">   * <span class="keyword">for</span> node<span class="string">'s native http server.</span></span><br><span class="line"><span class="string">   *</span></span><br><span class="line"><span class="string">   * @return &#123;Function&#125;</span></span><br><span class="line"><span class="string">   * @api public</span></span><br><span class="line"><span class="string">   */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  callback() &#123;</span></span><br><span class="line"><span class="string">    //合并中间件</span></span><br><span class="line"><span class="string">    const fn = compose(this.middleware);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (!this.listenerCount('</span>error<span class="string">')) this.on('</span>error<span class="string">', this.onerror);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    const handleRequest = (req, res) =&gt; &#123;</span></span><br><span class="line"><span class="string">      const ctx = this.createContext(req, res);</span></span><br><span class="line"><span class="string">      return this.handleRequest(ctx, fn);</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return handleRequest;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  /**</span></span><br><span class="line"><span class="string">   * Handle request in callback.</span></span><br><span class="line"><span class="string">   *</span></span><br><span class="line"><span class="string">   * @api private</span></span><br><span class="line"><span class="string">   */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  handleRequest(ctx, fnMiddleware) &#123;</span></span><br><span class="line"><span class="string">    const res = ctx.res;</span></span><br><span class="line"><span class="string">    res.statusCode = 404;</span></span><br><span class="line"><span class="string">    const onerror = err =&gt; ctx.onerror(err);</span></span><br><span class="line"><span class="string">    const handleResponse = () =&gt; respond(ctx);</span></span><br><span class="line"><span class="string">    onFinished(res, onerror);</span></span><br><span class="line"><span class="string">    return fnMiddleware(ctx).then(handleResponse).catch(onerror);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  /**</span></span><br><span class="line"><span class="string">   * Initialize a new context.</span></span><br><span class="line"><span class="string">   *</span></span><br><span class="line"><span class="string">   * @api private</span></span><br><span class="line"><span class="string">   */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   //创建cotext request reponse 与http模块的关系</span></span><br><span class="line"><span class="string">  createContext(req, res) &#123;</span></span><br><span class="line"><span class="string">    const context = Object.create(this.context);</span></span><br><span class="line"><span class="string">    const request = context.request = Object.create(this.request);</span></span><br><span class="line"><span class="string">    const response = context.response = Object.create(this.response);</span></span><br><span class="line"><span class="string">    context.app = request.app = response.app = this;</span></span><br><span class="line"><span class="string">    context.req = request.req = response.req = req;</span></span><br><span class="line"><span class="string">    context.res = request.res = response.res = res;</span></span><br><span class="line"><span class="string">    request.ctx = response.ctx = context;</span></span><br><span class="line"><span class="string">    request.response = response;</span></span><br><span class="line"><span class="string">    response.request = request;</span></span><br><span class="line"><span class="string">    context.originalUrl = request.originalUrl = req.url;</span></span><br><span class="line"><span class="string">    context.state = &#123;&#125;;</span></span><br><span class="line"><span class="string">    return context;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  /**</span></span><br><span class="line"><span class="string">   * Default error handler.</span></span><br><span class="line"><span class="string">   *</span></span><br><span class="line"><span class="string">   * @param &#123;Error&#125; err</span></span><br><span class="line"><span class="string">   * @api private</span></span><br><span class="line"><span class="string">   */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  onerror(err) &#123;</span></span><br><span class="line"><span class="string">    if (!(err instanceof Error)) throw new TypeError(util.format('</span>non-error thrown: %j<span class="string">', err));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (404 == err.status || err.expose) return;</span></span><br><span class="line"><span class="string">    if (this.silent) return;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    const msg = err.stack || err.toString();</span></span><br><span class="line"><span class="string">    console.error();</span></span><br><span class="line"><span class="string">    console.error(msg.replace(/^/gm, '</span>  <span class="string">'));</span></span><br><span class="line"><span class="string">    console.error();</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * Response helper.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function respond(ctx) &#123;</span></span><br><span class="line"><span class="string">  // allow bypassing koa</span></span><br><span class="line"><span class="string">  if (false === ctx.respond) return;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  const res = ctx.res;</span></span><br><span class="line"><span class="string">  if (!ctx.writable) return;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  let body = ctx.body;</span></span><br><span class="line"><span class="string">  const code = ctx.status;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // ignore body</span></span><br><span class="line"><span class="string">  if (statuses.empty[code]) &#123;</span></span><br><span class="line"><span class="string">    // strip headers</span></span><br><span class="line"><span class="string">    ctx.body = null;</span></span><br><span class="line"><span class="string">    return res.end();</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  if ('</span>HEAD<span class="string">' == ctx.method) &#123;</span></span><br><span class="line"><span class="string">    if (!res.headersSent &amp;&amp; isJSON(body)) &#123;</span></span><br><span class="line"><span class="string">      ctx.length = Buffer.byteLength(JSON.stringify(body));</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return res.end();</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // status body</span></span><br><span class="line"><span class="string">  if (null == body) &#123;</span></span><br><span class="line"><span class="string">    body = ctx.message || String(code);</span></span><br><span class="line"><span class="string">    if (!res.headersSent) &#123;</span></span><br><span class="line"><span class="string">      ctx.type = '</span>text<span class="string">';</span></span><br><span class="line"><span class="string">      ctx.length = Buffer.byteLength(body);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return res.end(body);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // responses</span></span><br><span class="line"><span class="string">  if (Buffer.isBuffer(body)) return res.end(body);</span></span><br><span class="line"><span class="string">  if ('</span>string<span class="string">' == typeof body) return res.end(body);</span></span><br><span class="line"><span class="string">  if (body instanceof Stream) return body.pipe(res);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // body: json</span></span><br><span class="line"><span class="string">  body = JSON.stringify(body);</span></span><br><span class="line"><span class="string">  if (!res.headersSent) &#123;</span></span><br><span class="line"><span class="string">    ctx.length = Buffer.byteLength(body);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  res.end(body);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><br>其实中间件就是一个函数，koa中有一个middleware去储存中间件函数，是一个数组。<br><br><br>当use的时候，koa1中会把generator函数转化成promise形式，koa2会把async转化成promise形式，用的都是koa-convert模块，然后将函数push到middleware中。<br><br>最后在createServer的callback中，将中间件函数数组进行了合并，用了一个叫koa-compose的中间件。</p><h3 id="compose-js"><a href="#compose-js" class="headerlink" title="compose.js"></a>compose.js</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">use strict<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * Expose compositor.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">module.exports = compose</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * Compose `middleware` returning</span></span><br><span class="line"><span class="string"> * a fully valid middleware comprised</span></span><br><span class="line"><span class="string"> * of all those which are passed.</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * @param &#123;Array&#125; middleware</span></span><br><span class="line"><span class="string"> * @return &#123;Function&#125;</span></span><br><span class="line"><span class="string"> * @api public</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function compose (middleware) &#123;</span></span><br><span class="line"><span class="string">  if (!Array.isArray(middleware)) throw new TypeError('</span>Middleware stack must be an array!<span class="string">')</span></span><br><span class="line"><span class="string">  for (const fn of middleware) &#123;</span></span><br><span class="line"><span class="string">    if (typeof fn !== '</span><span class="keyword">function</span><span class="string">') throw new TypeError('</span>Middleware must be composed of <span class="built_in">functions</span>!<span class="string">')</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  /**</span></span><br><span class="line"><span class="string">   * @param &#123;Object&#125; context</span></span><br><span class="line"><span class="string">   * @return &#123;Promise&#125;</span></span><br><span class="line"><span class="string">   * @api public</span></span><br><span class="line"><span class="string">   */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  return function (context, next) &#123;</span></span><br><span class="line"><span class="string">    // last called middleware #</span></span><br><span class="line"><span class="string">    let index = -1; //当前中间件的索引</span></span><br><span class="line"><span class="string">    return dispatch(0)</span></span><br><span class="line"><span class="string">    function dispatch (i) &#123;</span></span><br><span class="line"><span class="string">      if (i &lt;= index) return Promise.reject(new Error('</span>next() called multiple <span class="built_in">times</span><span class="string">'))</span></span><br><span class="line"><span class="string">      index = i</span></span><br><span class="line"><span class="string">      let fn = middleware[i]</span></span><br><span class="line"><span class="string">      if (i === middleware.length) fn = next</span></span><br><span class="line"><span class="string">      if (!fn) return Promise.resolve()</span></span><br><span class="line"><span class="string">      try &#123;</span></span><br><span class="line"><span class="string">        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));</span></span><br><span class="line"><span class="string">      &#125; catch (err) &#123;</span></span><br><span class="line"><span class="string">        return Promise.reject(err)</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>compose中主要是dispatch，递归调用了这个函数，其实就是在第一个函数里执行第二个函数，在第二个函数里执行第三个。。。。。 就像一个洋葱。<br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/onion.png" /><br>其实就是一个调用栈，然后包装成了promise，当next()时，generator函数，对应的就yield，就跳到了下一个中间件函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;js的异步解决方案&quot;&gt;&lt;a href=&quot;#js的异步解决方案&quot; class=&quot;headerlink&quot; title=&quot;js的异步解决方案&quot;&gt;&lt;/a&gt;js的异步解决方案&lt;/h3&gt;&lt;p&gt;在javascript里，异步的解决方案包括以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回调&lt;/li&gt;
&lt;li&gt;promise&lt;/li&gt;
&lt;li&gt;generator&lt;/li&gt;
&lt;li&gt;async&lt;br&gt;优雅程度自上而下。
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="koa" scheme="http://yoursite.com/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>koaMiddleWare</title>
    <link href="http://yoursite.com/2018/08/07/node-koaMiddle/"/>
    <id>http://yoursite.com/2018/08/07/node-koaMiddle/</id>
    <published>2018-08-07T13:09:48.000Z</published>
    <updated>2019-09-17T02:41:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="js的异步解决方案"><a href="#js的异步解决方案" class="headerlink" title="js的异步解决方案"></a>js的异步解决方案</h3><p>在javascript里，异步的解决方案包括以下几种：</p><ul><li>回调</li><li>promise</li><li>generator</li><li>async<br>优雅程度自上而下。<a id="more"></a></li></ul><h3 id="express-koa1-koa2"><a href="#express-koa1-koa2" class="headerlink" title="express koa1 koa2"></a>express koa1 koa2</h3><p>随着社会的不断发展和进步，emmmmm，express团队从一开始陆续搞出了express、koa1和koa2，为毛他们闲着没事干，搞这么多起相同功能的轮子呢？不知道老子学不动了吗?（开玩笑<br></p><p>koa相比express，轻量了不少，看官方文档就能知道，其实之所以重复造轮子，应该是因为异步的解决方案。<br><br></p><p>在express中，处理异步的方式，就是回调，如果回调太深的话，恶心程度可想而知，koa1主要是用generator函数做中间件函数，koa2是用async函数。<br>个人认为async最为优雅。使用方式不同，是因为内部对中间件函数的处理不同，looklook。<br></p><h3 id="application-js"><a href="#application-js" class="headerlink" title="application.js"></a>application.js</h3><p>koa的源码也就4个文件，在下主要看了application.js,代码以及部分注释如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Module dependencies.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">const isGeneratorFunction = require(<span class="string">'is-generator-function'</span>);</span><br><span class="line">const debug = require(<span class="string">'debug'</span>)(<span class="string">'koa:application'</span>);</span><br><span class="line">const onFinished = require(<span class="string">'on-finished'</span>);</span><br><span class="line">const response = require(<span class="string">'./response'</span>);</span><br><span class="line">const compose = require(<span class="string">'koa-compose'</span>);</span><br><span class="line">const isJSON = require(<span class="string">'koa-is-json'</span>);</span><br><span class="line">const context = require(<span class="string">'./context'</span>);</span><br><span class="line">const request = require(<span class="string">'./request'</span>);</span><br><span class="line">const statuses = require(<span class="string">'statuses'</span>);</span><br><span class="line">const Emitter = require(<span class="string">'events'</span>);</span><br><span class="line">const util = require(<span class="string">'util'</span>);</span><br><span class="line">const Stream = require(<span class="string">'stream'</span>);</span><br><span class="line">const http = require(<span class="string">'http'</span>);</span><br><span class="line">const only = require(<span class="string">'only'</span>);</span><br><span class="line">const convert = require(<span class="string">'koa-convert'</span>);</span><br><span class="line">const deprecate = require(<span class="string">'depd'</span>)(<span class="string">'koa'</span>);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Expose `Application` class.</span><br><span class="line"> * Inherits from `Emitter.prototype`.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"> //继承Emitter  因此 koa的实例 this可以调用on</span><br><span class="line">module.exports = class Application extends Emitter &#123;</span><br><span class="line">  /**</span><br><span class="line">   * Initialize a new `Application`.</span><br><span class="line">   *</span><br><span class="line">   * @api public</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    super();</span><br><span class="line"></span><br><span class="line">    this.proxy = <span class="literal">false</span>; //代理设置</span><br><span class="line">    this.middleware = [];</span><br><span class="line">    this.subdomainOffset = 2; //域名偏移</span><br><span class="line">    this.env = process.env.NODE_ENV || <span class="string">'development'</span>;</span><br><span class="line">    this.context = Object.create(context);</span><br><span class="line">    this.request = Object.create(request);</span><br><span class="line">    this.response = Object.create(response);</span><br><span class="line">    <span class="keyword">if</span> (util.inspect.custom) &#123;</span><br><span class="line">      this[util.inspect.custom] = this.inspect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Shorthand <span class="keyword">for</span>:</span><br><span class="line">   *</span><br><span class="line">   *    http.createServer(app.callback()).listen(...)</span><br><span class="line">   *</span><br><span class="line">   * @param &#123;Mixed&#125; ...</span><br><span class="line">   * @<span class="built_in">return</span> &#123;Server&#125;</span><br><span class="line">   * @api public</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  listen(...args) &#123;</span><br><span class="line">    debug(<span class="string">'listen'</span>);</span><br><span class="line">    const server = http.createServer(this.callback());</span><br><span class="line">    <span class="built_in">return</span> server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Return JSON representation.</span><br><span class="line">   * We only bother showing settings.</span><br><span class="line">   *</span><br><span class="line">   * @<span class="built_in">return</span> &#123;Object&#125;</span><br><span class="line">   * @api public</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toJSON</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> only(this, [</span><br><span class="line">      <span class="string">'subdomainOffset'</span>,</span><br><span class="line">      <span class="string">'proxy'</span>,</span><br><span class="line">      <span class="string">'env'</span></span><br><span class="line">    ]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Inspect implementation.</span><br><span class="line">   *</span><br><span class="line">   * @<span class="built_in">return</span> &#123;Object&#125;</span><br><span class="line">   * @api public</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">inspect</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.toJSON();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Use the given middleware `fn`.</span><br><span class="line">   *</span><br><span class="line">   * Old-style middleware will be converted.</span><br><span class="line">   *</span><br><span class="line">   * @param &#123;Function&#125; fn</span><br><span class="line">   * @<span class="built_in">return</span> &#123;Application&#125; self</span><br><span class="line">   * @api public</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  //对 generator 函数利用 koa-convert 库进行转化(将 generator 函数包装成 Promise),</span><br><span class="line">  //如果不是则不转化, 然后将这个中间件函数 push 进实例对象的 middleware 数组中.</span><br><span class="line">  use(fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeof fn !== <span class="string">'function'</span>) throw new TypeError(<span class="string">'middleware must be a function!'</span>);</span><br><span class="line">    <span class="keyword">if</span> (isGeneratorFunction(fn)) &#123;</span><br><span class="line">      deprecate(<span class="string">'Support for generators will be removed in v3. '</span> +</span><br><span class="line">                <span class="string">'See the documentation for examples of how to convert old middleware '</span> +</span><br><span class="line">                <span class="string">'https://github.com/koajs/koa/blob/master/docs/migration.md'</span>);</span><br><span class="line">      fn = convert(fn);</span><br><span class="line">    &#125;</span><br><span class="line">    debug(<span class="string">'use %s'</span>, fn._name || fn.name || <span class="string">'-'</span>);</span><br><span class="line">    this.middleware.push(fn);</span><br><span class="line">    <span class="built_in">return</span> this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Return a request handler callback</span><br><span class="line">   * <span class="keyword">for</span> node<span class="string">'s native http server.</span></span><br><span class="line"><span class="string">   *</span></span><br><span class="line"><span class="string">   * @return &#123;Function&#125;</span></span><br><span class="line"><span class="string">   * @api public</span></span><br><span class="line"><span class="string">   */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  callback() &#123;</span></span><br><span class="line"><span class="string">    //合并中间件</span></span><br><span class="line"><span class="string">    const fn = compose(this.middleware);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (!this.listenerCount('</span>error<span class="string">')) this.on('</span>error<span class="string">', this.onerror);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    const handleRequest = (req, res) =&gt; &#123;</span></span><br><span class="line"><span class="string">      const ctx = this.createContext(req, res);</span></span><br><span class="line"><span class="string">      return this.handleRequest(ctx, fn);</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return handleRequest;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  /**</span></span><br><span class="line"><span class="string">   * Handle request in callback.</span></span><br><span class="line"><span class="string">   *</span></span><br><span class="line"><span class="string">   * @api private</span></span><br><span class="line"><span class="string">   */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  handleRequest(ctx, fnMiddleware) &#123;</span></span><br><span class="line"><span class="string">    const res = ctx.res;</span></span><br><span class="line"><span class="string">    res.statusCode = 404;</span></span><br><span class="line"><span class="string">    const onerror = err =&gt; ctx.onerror(err);</span></span><br><span class="line"><span class="string">    const handleResponse = () =&gt; respond(ctx);</span></span><br><span class="line"><span class="string">    onFinished(res, onerror);</span></span><br><span class="line"><span class="string">    return fnMiddleware(ctx).then(handleResponse).catch(onerror);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  /**</span></span><br><span class="line"><span class="string">   * Initialize a new context.</span></span><br><span class="line"><span class="string">   *</span></span><br><span class="line"><span class="string">   * @api private</span></span><br><span class="line"><span class="string">   */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   //创建cotext request reponse 与http模块的关系</span></span><br><span class="line"><span class="string">  createContext(req, res) &#123;</span></span><br><span class="line"><span class="string">    const context = Object.create(this.context);</span></span><br><span class="line"><span class="string">    const request = context.request = Object.create(this.request);</span></span><br><span class="line"><span class="string">    const response = context.response = Object.create(this.response);</span></span><br><span class="line"><span class="string">    context.app = request.app = response.app = this;</span></span><br><span class="line"><span class="string">    context.req = request.req = response.req = req;</span></span><br><span class="line"><span class="string">    context.res = request.res = response.res = res;</span></span><br><span class="line"><span class="string">    request.ctx = response.ctx = context;</span></span><br><span class="line"><span class="string">    request.response = response;</span></span><br><span class="line"><span class="string">    response.request = request;</span></span><br><span class="line"><span class="string">    context.originalUrl = request.originalUrl = req.url;</span></span><br><span class="line"><span class="string">    context.state = &#123;&#125;;</span></span><br><span class="line"><span class="string">    return context;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  /**</span></span><br><span class="line"><span class="string">   * Default error handler.</span></span><br><span class="line"><span class="string">   *</span></span><br><span class="line"><span class="string">   * @param &#123;Error&#125; err</span></span><br><span class="line"><span class="string">   * @api private</span></span><br><span class="line"><span class="string">   */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  onerror(err) &#123;</span></span><br><span class="line"><span class="string">    if (!(err instanceof Error)) throw new TypeError(util.format('</span>non-error thrown: %j<span class="string">', err));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (404 == err.status || err.expose) return;</span></span><br><span class="line"><span class="string">    if (this.silent) return;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    const msg = err.stack || err.toString();</span></span><br><span class="line"><span class="string">    console.error();</span></span><br><span class="line"><span class="string">    console.error(msg.replace(/^/gm, '</span>  <span class="string">'));</span></span><br><span class="line"><span class="string">    console.error();</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * Response helper.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function respond(ctx) &#123;</span></span><br><span class="line"><span class="string">  // allow bypassing koa</span></span><br><span class="line"><span class="string">  if (false === ctx.respond) return;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  const res = ctx.res;</span></span><br><span class="line"><span class="string">  if (!ctx.writable) return;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  let body = ctx.body;</span></span><br><span class="line"><span class="string">  const code = ctx.status;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // ignore body</span></span><br><span class="line"><span class="string">  if (statuses.empty[code]) &#123;</span></span><br><span class="line"><span class="string">    // strip headers</span></span><br><span class="line"><span class="string">    ctx.body = null;</span></span><br><span class="line"><span class="string">    return res.end();</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  if ('</span>HEAD<span class="string">' == ctx.method) &#123;</span></span><br><span class="line"><span class="string">    if (!res.headersSent &amp;&amp; isJSON(body)) &#123;</span></span><br><span class="line"><span class="string">      ctx.length = Buffer.byteLength(JSON.stringify(body));</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return res.end();</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // status body</span></span><br><span class="line"><span class="string">  if (null == body) &#123;</span></span><br><span class="line"><span class="string">    body = ctx.message || String(code);</span></span><br><span class="line"><span class="string">    if (!res.headersSent) &#123;</span></span><br><span class="line"><span class="string">      ctx.type = '</span>text<span class="string">';</span></span><br><span class="line"><span class="string">      ctx.length = Buffer.byteLength(body);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return res.end(body);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // responses</span></span><br><span class="line"><span class="string">  if (Buffer.isBuffer(body)) return res.end(body);</span></span><br><span class="line"><span class="string">  if ('</span>string<span class="string">' == typeof body) return res.end(body);</span></span><br><span class="line"><span class="string">  if (body instanceof Stream) return body.pipe(res);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // body: json</span></span><br><span class="line"><span class="string">  body = JSON.stringify(body);</span></span><br><span class="line"><span class="string">  if (!res.headersSent) &#123;</span></span><br><span class="line"><span class="string">    ctx.length = Buffer.byteLength(body);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  res.end(body);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><br>其实中间件就是一个函数，koa中有一个middleware去储存中间件函数，是一个数组。<br><br><br>当use的时候，koa1中会把generator函数转化成promise形式，koa2会把async转化成promise形式，用的都是koa-convert模块，然后将函数push到middleware中。<br><br>最后在createServer的callback中，将中间件函数数组进行了合并，用了一个叫koa-compose的中间件。</p><h3 id="compose-js"><a href="#compose-js" class="headerlink" title="compose.js"></a>compose.js</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">use strict<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * Expose compositor.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">module.exports = compose</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * Compose `middleware` returning</span></span><br><span class="line"><span class="string"> * a fully valid middleware comprised</span></span><br><span class="line"><span class="string"> * of all those which are passed.</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * @param &#123;Array&#125; middleware</span></span><br><span class="line"><span class="string"> * @return &#123;Function&#125;</span></span><br><span class="line"><span class="string"> * @api public</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function compose (middleware) &#123;</span></span><br><span class="line"><span class="string">  if (!Array.isArray(middleware)) throw new TypeError('</span>Middleware stack must be an array!<span class="string">')</span></span><br><span class="line"><span class="string">  for (const fn of middleware) &#123;</span></span><br><span class="line"><span class="string">    if (typeof fn !== '</span><span class="keyword">function</span><span class="string">') throw new TypeError('</span>Middleware must be composed of <span class="built_in">functions</span>!<span class="string">')</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  /**</span></span><br><span class="line"><span class="string">   * @param &#123;Object&#125; context</span></span><br><span class="line"><span class="string">   * @return &#123;Promise&#125;</span></span><br><span class="line"><span class="string">   * @api public</span></span><br><span class="line"><span class="string">   */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  return function (context, next) &#123;</span></span><br><span class="line"><span class="string">    // last called middleware #</span></span><br><span class="line"><span class="string">    let index = -1; //当前中间件的索引</span></span><br><span class="line"><span class="string">    return dispatch(0)</span></span><br><span class="line"><span class="string">    function dispatch (i) &#123;</span></span><br><span class="line"><span class="string">      if (i &lt;= index) return Promise.reject(new Error('</span>next() called multiple <span class="built_in">times</span><span class="string">'))</span></span><br><span class="line"><span class="string">      index = i</span></span><br><span class="line"><span class="string">      let fn = middleware[i]</span></span><br><span class="line"><span class="string">      if (i === middleware.length) fn = next</span></span><br><span class="line"><span class="string">      if (!fn) return Promise.resolve()</span></span><br><span class="line"><span class="string">      try &#123;</span></span><br><span class="line"><span class="string">        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));</span></span><br><span class="line"><span class="string">      &#125; catch (err) &#123;</span></span><br><span class="line"><span class="string">        return Promise.reject(err)</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>compose中主要是dispatch，递归调用了这个函数，其实就是在第一个函数里执行第二个函数，在第二个函数里执行第三个。。。。。 就像一个洋葱。<br><img src="https://xuyonglinblog.oss-cn-beijing.aliyuncs.com/onion.png" /><br>其实就是一个调用栈，然后包装成了promise，当next()时，generator函数，对应的就yield，就跳到了下一个中间件函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;js的异步解决方案&quot;&gt;&lt;a href=&quot;#js的异步解决方案&quot; class=&quot;headerlink&quot; title=&quot;js的异步解决方案&quot;&gt;&lt;/a&gt;js的异步解决方案&lt;/h3&gt;&lt;p&gt;在javascript里，异步的解决方案包括以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回调&lt;/li&gt;
&lt;li&gt;promise&lt;/li&gt;
&lt;li&gt;generator&lt;/li&gt;
&lt;li&gt;async&lt;br&gt;优雅程度自上而下。
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="koa" scheme="http://yoursite.com/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>sort</title>
    <link href="http://yoursite.com/2018/07/25/js-sort/"/>
    <id>http://yoursite.com/2018/07/25/js-sort/</id>
    <published>2018-07-25T03:33:49.000Z</published>
    <updated>2019-09-17T02:42:39.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>先来张图片<br><img  src="http://pdqpny9og.bkt.clouddn.com/paixu.png" /><br><a id="more"></a></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li><1>.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li><2>.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li><3>.针对所有的元素重复以上的步骤，除了最后一个；</li><li><4>.重复步骤1~3，直到排序完成。</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bubbleSort(arr) &#123;</span><br><span class="line">    var i = arr.length-1;  //初始时,最后位置保持不变</span><br><span class="line">    <span class="keyword">while</span> ( i&gt; 0) &#123;</span><br><span class="line">        var pos= 0; //每趟开始时,无记录交换</span><br><span class="line">        <span class="keyword">for</span> (var j= 0; j&lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j]&gt; arr[j+1]) &#123;</span><br><span class="line">                pos= j; //记录交换的位置</span><br><span class="line">                var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        i= pos; //为下一趟排序作准备</span><br><span class="line">     &#125;</span><br><span class="line">     console.timeEnd(<span class="string">'改进后冒泡排序耗时'</span>);</span><br><span class="line">     <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li><1>.初始状态：无序区为R[1..n]，有序区为空；</li><li><2>.第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li><3>.n-1趟结束，数组有序化了。</li></ul><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> selectionSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    var minIndex, temp;</span><br><span class="line">    <span class="keyword">for</span> (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (var j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     //寻找最小的数</span><br><span class="line">                minIndex = j;                 //将最小数的索引保存</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li><1>.从第一个元素开始，该元素可以认为已经被排序；</li><li><2>.取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li><3>.如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li><4>.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li><5>.将新元素插入到该位置后；</li><li><6>.重复步骤2~5。</li></ul><h4 id="代码描述"><a href="#代码描述" class="headerlink" title="代码描述"></a>代码描述</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> insertionSort(array) &#123;</span><br><span class="line">    <span class="keyword">for</span> (var i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">            var key = array[i];</span><br><span class="line">            var j = i - 1;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= 0 &amp;&amp; array[j] &gt; key) &#123;</span><br><span class="line">                array[j + 1] = array[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            array[j + 1] = key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：输入数组按升序排列。T(n) = O(n)</li><li>最坏情况：输入数组按降序排列。T(n) = O(n2)</li><li>平均情况：T(n) = O(n2)</li></ul><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><h4 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li><1>. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li><2>.按增量序列个数k，对序列进行k 趟排序；</li><li><3>.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> shellSort(arr) &#123;</span><br><span class="line">    var len = arr.length,</span><br><span class="line">        temp,</span><br><span class="line">        gap = 1;</span><br><span class="line">    console.time(<span class="string">'希尔排序耗时:'</span>);</span><br><span class="line">    <span class="keyword">while</span>(gap &lt; len/5) &#123;          //动态定义间隔序列</span><br><span class="line">        gap =gap*5+1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (gap; gap &gt; 0; gap = Math.floor(gap/5)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (var i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123;</span><br><span class="line">                arr[j+gap] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j+gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    console.timeEnd(<span class="string">'希尔排序耗时:'</span>);</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(nlog2 n)</li><li>最坏情况：T(n) = O(nlog2 n)</li><li>平均情况：T(n) =O(nlog n)</li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li><1>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li><2>对这两个子序列分别采用归并排序；</li><li><3>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> mergeSort(arr) &#123;  //采用自上而下的递归方法</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; 2) &#123;</span><br><span class="line">        <span class="built_in">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    var middle = Math.floor(len / 2),</span><br><span class="line">        left = arr.slice(0, middle),</span><br><span class="line">        right = arr.slice(middle);</span><br><span class="line">    <span class="built_in">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> merge(left, right)</span><br><span class="line">&#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    console.time(<span class="string">'归并排序耗时'</span>);</span><br><span class="line">    <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[0] &lt;= right[0]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left.length)</span><br><span class="line">        result.push(left.shift());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right.length)</span><br><span class="line">        result.push(right.shift());</span><br><span class="line">    console.timeEnd(<span class="string">'归并排序耗时'</span>);</span><br><span class="line">    <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(n)</li><li>最坏情况：T(n) = O(nlog n)</li><li>平均情况：T(n) =O(nlog n)</li></ul><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li><1>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li><2>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li><3>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var arr = [12,3,23,5,17,9,15,46];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> quickSort(arr,left, right)&#123;</span><br><span class="line">  var i,j,t,temp;</span><br><span class="line">  <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  i = left;</span><br><span class="line">  j = right;</span><br><span class="line">  temp = arr[left];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(i!==j)&#123;</span><br><span class="line">    <span class="keyword">while</span>(temp&lt;=arr[j]&amp;&amp;i&lt;j)&#123;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(temp&gt;=arr[i]&amp;&amp;i&lt;j)&#123;</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">      [arr[j], arr[i]] = [arr[i], arr[j]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr[left] = arr[i];</span><br><span class="line">  arr[i] = temp;</span><br><span class="line">  quickSort(arr,left,i-1);</span><br><span class="line">  quickSort(arr,i+1,right);</span><br><span class="line">&#125;</span><br><span class="line">quickSort(arr,0, arr.length-1);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><h4 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(nlogn)</li><li>最坏情况：T(n) = O(n2)</li><li>平均情况：T(n) =O(nlog n)</li></ul><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li><1>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li><2>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li><3>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> heapify(arr, x, len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Object.prototype.toString.call(arr).slice(8, -1) === <span class="string">'Array'</span> &amp;&amp; typeof x === <span class="string">'number'</span>) &#123;</span><br><span class="line">        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != x) &#123;</span><br><span class="line">            temp = arr[x];</span><br><span class="line">            arr[x] = arr[largest];</span><br><span class="line">            arr[largest] = temp;</span><br><span class="line">            heapify(arr, largest, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'arr is not an Array or x is not a number!'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*方法说明：维护堆的性质</span><br><span class="line">@param  arr 数组</span><br><span class="line">@param  x   数组下标</span><br><span class="line">@param  len 堆大小*/</span><br><span class="line"><span class="keyword">function</span> heapify(arr, x, len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Object.prototype.toString.call(arr).slice(8, -1) === <span class="string">'Array'</span> &amp;&amp; typeof x === <span class="string">'number'</span>) &#123;</span><br><span class="line">        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != x) &#123;</span><br><span class="line">            temp = arr[x];</span><br><span class="line">            arr[x] = arr[largest];</span><br><span class="line">            arr[largest] = temp;</span><br><span class="line">            heapify(arr, largest, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'arr is not an Array or x is not a number!'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h4></li><li>最佳情况：T(n) = O(nlogn)</li><li>最坏情况：T(n) = O(nlogn)</li><li>平均情况：T(n) =O(nlogn)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先来张图片&lt;br&gt;&lt;img  src=&quot;http://pdqpny9og.bkt.clouddn.com/paixu.png&quot; /&gt;&lt;br&gt;
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>sort</title>
    <link href="http://yoursite.com/2018/07/25/sort/"/>
    <id>http://yoursite.com/2018/07/25/sort/</id>
    <published>2018-07-25T03:33:49.000Z</published>
    <updated>2020-05-27T03:49:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>先来张图片<br><img  src="http://pdqpny9og.bkt.clouddn.com/paixu.png" /><br><a id="more"></a></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li><1>.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li><2>.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li><3>.针对所有的元素重复以上的步骤，除了最后一个；</li><li><4>.重复步骤1~3，直到排序完成。</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bubbleSort(arr) &#123;</span><br><span class="line">    var i = arr.length-1;  //初始时,最后位置保持不变</span><br><span class="line">    <span class="keyword">while</span> ( i&gt; 0) &#123;</span><br><span class="line">        var pos= 0; //每趟开始时,无记录交换</span><br><span class="line">        <span class="keyword">for</span> (var j= 0; j&lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j]&gt; arr[j+1]) &#123;</span><br><span class="line">                pos= j; //记录交换的位置</span><br><span class="line">                var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        i= pos; //为下一趟排序作准备</span><br><span class="line">     &#125;</span><br><span class="line">     console.timeEnd(<span class="string">'改进后冒泡排序耗时'</span>);</span><br><span class="line">     <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li><1>.初始状态：无序区为R[1..n]，有序区为空；</li><li><2>.第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li><3>.n-1趟结束，数组有序化了。</li></ul><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> selectionSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    var minIndex, temp;</span><br><span class="line">    <span class="keyword">for</span> (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (var j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     //寻找最小的数</span><br><span class="line">                minIndex = j;                 //将最小数的索引保存</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li><1>.从第一个元素开始，该元素可以认为已经被排序；</li><li><2>.取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li><3>.如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li><4>.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li><5>.将新元素插入到该位置后；</li><li><6>.重复步骤2~5。</li></ul><h4 id="代码描述"><a href="#代码描述" class="headerlink" title="代码描述"></a>代码描述</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> insertionSort(array) &#123;</span><br><span class="line">    <span class="keyword">for</span> (var i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">            var key = array[i];</span><br><span class="line">            var j = i - 1;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= 0 &amp;&amp; array[j] &gt; key) &#123;</span><br><span class="line">                array[j + 1] = array[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            array[j + 1] = key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：输入数组按升序排列。T(n) = O(n)</li><li>最坏情况：输入数组按降序排列。T(n) = O(n2)</li><li>平均情况：T(n) = O(n2)</li></ul><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><h4 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li><1>. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li><2>.按增量序列个数k，对序列进行k 趟排序；</li><li><3>.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> shellSort(arr) &#123;</span><br><span class="line">    var len = arr.length,</span><br><span class="line">        temp,</span><br><span class="line">        gap = 1;</span><br><span class="line">    console.time(<span class="string">'希尔排序耗时:'</span>);</span><br><span class="line">    <span class="keyword">while</span>(gap &lt; len/5) &#123;          //动态定义间隔序列</span><br><span class="line">        gap =gap*5+1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (gap; gap &gt; 0; gap = Math.floor(gap/5)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (var i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123;</span><br><span class="line">                arr[j+gap] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j+gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    console.timeEnd(<span class="string">'希尔排序耗时:'</span>);</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(nlog2 n)</li><li>最坏情况：T(n) = O(nlog2 n)</li><li>平均情况：T(n) =O(nlog n)</li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li><1>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li><2>对这两个子序列分别采用归并排序；</li><li><3>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> mergeSort(arr) &#123;  //采用自上而下的递归方法</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; 2) &#123;</span><br><span class="line">        <span class="built_in">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    var middle = Math.floor(len / 2),</span><br><span class="line">        left = arr.slice(0, middle),</span><br><span class="line">        right = arr.slice(middle);</span><br><span class="line">    <span class="built_in">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> merge(left, right)</span><br><span class="line">&#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    console.time(<span class="string">'归并排序耗时'</span>);</span><br><span class="line">    <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[0] &lt;= right[0]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left.length)</span><br><span class="line">        result.push(left.shift());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right.length)</span><br><span class="line">        result.push(right.shift());</span><br><span class="line">    console.timeEnd(<span class="string">'归并排序耗时'</span>);</span><br><span class="line">    <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(n)</li><li>最坏情况：T(n) = O(nlog n)</li><li>平均情况：T(n) =O(nlog n)</li></ul><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li><1>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li><2>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li><3>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var arr = [12,3,23,5,17,9,15,46];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> quickSort(arr,left, right)&#123;</span><br><span class="line">  var i,j,t,temp;</span><br><span class="line">  <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  i = left;</span><br><span class="line">  j = right;</span><br><span class="line">  temp = arr[left];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(i!==j)&#123;</span><br><span class="line">    <span class="keyword">while</span>(temp&lt;=arr[j]&amp;&amp;i&lt;j)&#123;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(temp&gt;=arr[i]&amp;&amp;i&lt;j)&#123;</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">      [arr[j], arr[i]] = [arr[i], arr[j]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr[left] = arr[i];</span><br><span class="line">  arr[i] = temp;</span><br><span class="line">  quickSort(arr,left,i-1);</span><br><span class="line">  quickSort(arr,i+1,right);</span><br><span class="line">&#125;</span><br><span class="line">quickSort(arr,0, arr.length-1);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><h4 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(nlogn)</li><li>最坏情况：T(n) = O(n2)</li><li>平均情况：T(n) =O(nlog n)</li></ul><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li><1>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li><2>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li><3>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> heapify(arr, x, len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Object.prototype.toString.call(arr).slice(8, -1) === <span class="string">'Array'</span> &amp;&amp; typeof x === <span class="string">'number'</span>) &#123;</span><br><span class="line">        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != x) &#123;</span><br><span class="line">            temp = arr[x];</span><br><span class="line">            arr[x] = arr[largest];</span><br><span class="line">            arr[largest] = temp;</span><br><span class="line">            heapify(arr, largest, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'arr is not an Array or x is not a number!'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*方法说明：维护堆的性质</span><br><span class="line">@param  arr 数组</span><br><span class="line">@param  x   数组下标</span><br><span class="line">@param  len 堆大小*/</span><br><span class="line"><span class="keyword">function</span> heapify(arr, x, len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Object.prototype.toString.call(arr).slice(8, -1) === <span class="string">'Array'</span> &amp;&amp; typeof x === <span class="string">'number'</span>) &#123;</span><br><span class="line">        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != x) &#123;</span><br><span class="line">            temp = arr[x];</span><br><span class="line">            arr[x] = arr[largest];</span><br><span class="line">            arr[largest] = temp;</span><br><span class="line">            heapify(arr, largest, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'arr is not an Array or x is not a number!'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h4></li><li>最佳情况：T(n) = O(nlogn)</li><li>最坏情况：T(n) = O(nlogn)</li><li>平均情况：T(n) =O(nlogn)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先来张图片&lt;br&gt;&lt;img  src=&quot;http://pdqpny9og.bkt.clouddn.com/paixu.png&quot; /&gt;&lt;br&gt;
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Ngnix</title>
    <link href="http://yoursite.com/2018/07/19/%E6%9D%82%E8%AE%B0-Ngnix/"/>
    <id>http://yoursite.com/2018/07/19/杂记-Ngnix/</id>
    <published>2018-07-19T04:25:14.000Z</published>
    <updated>2019-09-17T02:41:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Nginx是啥"><a href="#Nginx是啥" class="headerlink" title="Nginx是啥"></a>Nginx是啥</h3><p>Nginx是一个使用c语言开发的高性能http服务器以及反向代理服务器。Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。<br><a id="more"></a></p><h3 id="Nginx可以干什么"><a href="#Nginx可以干什么" class="headerlink" title="Nginx可以干什么"></a>Nginx可以干什么</h3><p>网站资源服务器，反向代理负载均衡。</p><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的，此时大家可能都会用一个操作FQ进行访问，FQ的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！</p><p>上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>多个客户端给服务器发送的请求，Nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx扮演的就是一个反向代理角色，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息！</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>首先明确两个概念：</p><ul><li>负载量：客户端发送的、Nginx反向代理服务器接收到的请求数量。</li><li>均衡规则：请求数量按照一定的规则分配到不同服务器处理的规则。<br>故将服务器接收到的请求按照规则分发的过程，称为负载均衡。<h4 id="HTTP重定向实现"><a href="#HTTP重定向实现" class="headerlink" title="HTTP重定向实现"></a>HTTP重定向实现</h4>当用户发起http请求时，请求先被集群调度者捕获，调度者根据不同的调度算法分配服务器IP，并将其放入response的location字段，status返回302，然后浏览器拿到响应消息后，解析Location字段，并向url发起请求，然后指定的服务器处理该用户的请求，最后将结果返回给用户。<br></li></ul><p>在使用HTTP重定向来实现服务器集群负载均衡的过程中，需要一台服务器作为请求调度者。用户的一项操作需要发起两次HTTP请求，一次向调度服务器发送请求，获取后端服务器的IP，第二次向后端服务器发送请求，获取处理结果。<br></p><p>调度服务器收到用户的请求后，究竟选择哪台后端服务器处理请求，这由调度服务器所使用的调度策略决定。<br></p><ul><li><p>随机分配策略 :当调度服务器收到用户请求后，可以随机决定使用哪台后端服务器，然后将该服务器的IP封装在HTTP响应消息的Location属性中，返回给浏览器即可。</p></li><li><p>轮询策略(RR):调度服务器需要维护一个值，用于记录上次分配的后端服务器的IP。那么当新的请求到来时，调度者将请求依次分配给下一台服务器。</p></li></ul><p>由于轮询策略需要调度者维护一个值用于记录上次分配的服务器IP，因此需要额外的开销；此外，由于这个值属于互斥资源，那么当多个请求同时到来时，为了避免线程的安全问题，因此需要锁定互斥资源，从而降低了性能。而随机分配策略不需要维护额外的值，也就不存在线程安全问题，因此性能比轮询要高。<br></p><h5 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h5><p>采用HTTP重定向来实现服务器集群的负载均衡实现起来较为容易，逻辑比较简单，但缺点也较为明显。<br></p><p>在HTTP重定向方法中，调度服务器只在客户端第一次向网站发起请求的时候起作用。当调度服务器向浏览器返回响应信息后，客户端此后的操作都基于新的URL进行的(也就是后端服务器)，此后浏览器就不会与调度服务器产生关系，进而会产生如下几个问题：<br></p><p>由于不同用户的访问时间、访问页面深度有所不同，从而每个用户对各自的后端服务器所造成的压力也不同。而调度服务器在调度时，无法知道当前用户将会对服务器造成多大的压力，因此这种方式无法实现真正意义上的负载均衡，只不过是把请求次数平均分配给每台服务器罢了。<br></p><p>若分配给该用户的后端服务器出现故障，并且如果页面被浏览器缓存，那么当用户再次访问网站时，请求都会发给出现故障的服务器，从而导致访问失败。<br></p><h4 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h4><p>DNS服务器有一个天然的优势，如果一个域名指向了多个IP地址，那么每次进行域名解析时，DNS只要选一个IP返回给用户，就能够实现服务器集群的负载均衡。</p><h5 id="具体做法"><a href="#具体做法" class="headerlink" title="具体做法"></a>具体做法</h5><p>首先需要将我们的域名指向多个后端服务器(将一个域名解析到多个IP上)，再设置一下调度策略，那么我们的准备工作就完成了，接下来的负载均衡就完全由DNS服务器来实现。</p><p>当用户向我们的域名发起请求时，DNS服务器会自动地根据我们事先设定好的调度策略选一个合适的IP返回给用户，用户再向该IP发起请求。</p><h5 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h5><p>一般DNS提供商会提供一些调度策略供我们选择，如随机分配、轮询、根据请求者的地域分配离他最近的服务器。</p><h5 id="优缺点分析-1"><a href="#优缺点分析-1" class="headerlink" title="优缺点分析"></a>优缺点分析</h5><p>DNS负载均衡最大的优点就是配置简单。服务器集群的调度工作完全由DNS服务器承担，那么我们就可以把精力放在后端服务器上，保证他们的稳定性与吞吐量。而且完全不用担心DNS服务器的性能，即便是使用了轮询策略，它的吞吐率依然卓越。<br>此外，DNS负载均衡具有较强了扩展性，你完全可以为一个域名解析较多的IP，而且不用担心性能问题。<br><br><br>但是，由于把集群调度权交给了DNS服务器，从而我们没办法随心所欲地控制调度者，没办法定制调度策略。<br><br><br>DNS服务器也没办法了解每台服务器的负载情况，因此没办法实现真正意义上的负载均衡。它和HTTP重定向一样，只不过把所有请求平均分配给后端服务器罢了。<br><br><br>此外，当我们发现某一台后端服务器发生故障时，即使我们立即将该服务器从域名解析中去除，但由于DNS服务器会有缓存，该IP仍然会在DNS中保留一段时间，那么就会导致一部分用户无法正常访问网站。这是一个致命的问题！好在这个问题可以用动态DNS来解决。<br><br><br>动态DNS能够让我们通过程序动态修改DNS服务器中的域名解析。从而当我们的监控程序发现某台服务器挂了之后，能立即通知DNS将其删掉。<br><br></p><h4 id="反向代理负载均衡"><a href="#反向代理负载均衡" class="headerlink" title="反向代理负载均衡"></a>反向代理负载均衡</h4><p>反向代理服务器是一个位于实际服务器之前的服务器，所有向我们网站发来的请求都首先要经过反向代理服务器，服务器根据用户的请求要么直接将结果返回给用户，要么将请求交给后端服务器处理，再返回给用户。<br><br><br>之前我们介绍了用反向代理服务器实现静态页面和常用的动态页面的缓存。接下来我们介绍反向代理服务器更常用的功能——实现负载均衡。<br><br><br>我们知道，所有发送给我们网站的请求都首先经过反向代理服务器。那么，反向代理服务器就可以充当服务器集群的调度者，它可以根据当前后端服务器的负载情况，将请求转发给一台合适的服务器，并将处理结果返回给用户。<br><br></p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>隐藏后端服务器。</li><li>与HTTP重定向相比，反向代理能够隐藏后端服务器，所有浏览器都不会与后端服务器直接交互，从而能够确保调度者的控制权，提升集群的整体性能。<br>故障转移</li><li>与DNS负载均衡相比，反向代理能够更快速地移除故障结点。当监控程序发现某一后端服务器出现故障时，能够及时通知反向代理服务器，并立即将其删除。<br>合理分配任务</li><li><p>HTTP重定向和DNS负载均衡都无法实现真正意义上的负载均衡，也就是调度服务器无法根据后端服务器的实际负载情况分配任务。但反向代理服务器支持手动设定每台后端服务器的权重。我们可以根据服务器的配置设置不同的权重，权重的不同会导致被调度者选中的概率的不同。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5></li><li><p>调度者压力过大</p></li><li>由于所有的请求都先由反向代理服务器处理，那么当请求量超过调度服务器的最大负载时，调度服务器的吞吐率降低会直接降低集群的整体性能。<br>制约扩展</li><li>当后端服务器也无法满足巨大的吞吐量时，就需要增加后端服务器的数量，可没办法无限量地增加，因为会受到调度服务器的最大吞吐量的制约。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Nginx是啥&quot;&gt;&lt;a href=&quot;#Nginx是啥&quot; class=&quot;headerlink&quot; title=&quot;Nginx是啥&quot;&gt;&lt;/a&gt;Nginx是啥&lt;/h3&gt;&lt;p&gt;Nginx是一个使用c语言开发的高性能http服务器以及反向代理服务器。Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。&lt;br&gt;
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Ngnix</title>
    <link href="http://yoursite.com/2018/07/19/Ngnix/"/>
    <id>http://yoursite.com/2018/07/19/Ngnix/</id>
    <published>2018-07-19T04:25:14.000Z</published>
    <updated>2020-05-27T03:49:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Nginx是啥"><a href="#Nginx是啥" class="headerlink" title="Nginx是啥"></a>Nginx是啥</h3><p>Nginx是一个使用c语言开发的高性能http服务器以及反向代理服务器。Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。<br><a id="more"></a></p><h3 id="Nginx可以干什么"><a href="#Nginx可以干什么" class="headerlink" title="Nginx可以干什么"></a>Nginx可以干什么</h3><p>网站资源服务器，反向代理负载均衡。</p><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的，此时大家可能都会用一个操作FQ进行访问，FQ的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！</p><p>上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>多个客户端给服务器发送的请求，Nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx扮演的就是一个反向代理角色，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息！</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>首先明确两个概念：</p><ul><li>负载量：客户端发送的、Nginx反向代理服务器接收到的请求数量。</li><li>均衡规则：请求数量按照一定的规则分配到不同服务器处理的规则。<br>故将服务器接收到的请求按照规则分发的过程，称为负载均衡。<h4 id="HTTP重定向实现"><a href="#HTTP重定向实现" class="headerlink" title="HTTP重定向实现"></a>HTTP重定向实现</h4>当用户发起http请求时，请求先被集群调度者捕获，调度者根据不同的调度算法分配服务器IP，并将其放入response的location字段，status返回302，然后浏览器拿到响应消息后，解析Location字段，并向url发起请求，然后指定的服务器处理该用户的请求，最后将结果返回给用户。<br></li></ul><p>在使用HTTP重定向来实现服务器集群负载均衡的过程中，需要一台服务器作为请求调度者。用户的一项操作需要发起两次HTTP请求，一次向调度服务器发送请求，获取后端服务器的IP，第二次向后端服务器发送请求，获取处理结果。<br></p><p>调度服务器收到用户的请求后，究竟选择哪台后端服务器处理请求，这由调度服务器所使用的调度策略决定。<br></p><ul><li><p>随机分配策略 :当调度服务器收到用户请求后，可以随机决定使用哪台后端服务器，然后将该服务器的IP封装在HTTP响应消息的Location属性中，返回给浏览器即可。</p></li><li><p>轮询策略(RR):调度服务器需要维护一个值，用于记录上次分配的后端服务器的IP。那么当新的请求到来时，调度者将请求依次分配给下一台服务器。</p></li></ul><p>由于轮询策略需要调度者维护一个值用于记录上次分配的服务器IP，因此需要额外的开销；此外，由于这个值属于互斥资源，那么当多个请求同时到来时，为了避免线程的安全问题，因此需要锁定互斥资源，从而降低了性能。而随机分配策略不需要维护额外的值，也就不存在线程安全问题，因此性能比轮询要高。<br></p><h5 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h5><p>采用HTTP重定向来实现服务器集群的负载均衡实现起来较为容易，逻辑比较简单，但缺点也较为明显。<br></p><p>在HTTP重定向方法中，调度服务器只在客户端第一次向网站发起请求的时候起作用。当调度服务器向浏览器返回响应信息后，客户端此后的操作都基于新的URL进行的(也就是后端服务器)，此后浏览器就不会与调度服务器产生关系，进而会产生如下几个问题：<br></p><p>由于不同用户的访问时间、访问页面深度有所不同，从而每个用户对各自的后端服务器所造成的压力也不同。而调度服务器在调度时，无法知道当前用户将会对服务器造成多大的压力，因此这种方式无法实现真正意义上的负载均衡，只不过是把请求次数平均分配给每台服务器罢了。<br></p><p>若分配给该用户的后端服务器出现故障，并且如果页面被浏览器缓存，那么当用户再次访问网站时，请求都会发给出现故障的服务器，从而导致访问失败。<br></p><h4 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h4><p>DNS服务器有一个天然的优势，如果一个域名指向了多个IP地址，那么每次进行域名解析时，DNS只要选一个IP返回给用户，就能够实现服务器集群的负载均衡。</p><h5 id="具体做法"><a href="#具体做法" class="headerlink" title="具体做法"></a>具体做法</h5><p>首先需要将我们的域名指向多个后端服务器(将一个域名解析到多个IP上)，再设置一下调度策略，那么我们的准备工作就完成了，接下来的负载均衡就完全由DNS服务器来实现。</p><p>当用户向我们的域名发起请求时，DNS服务器会自动地根据我们事先设定好的调度策略选一个合适的IP返回给用户，用户再向该IP发起请求。</p><h5 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h5><p>一般DNS提供商会提供一些调度策略供我们选择，如随机分配、轮询、根据请求者的地域分配离他最近的服务器。</p><h5 id="优缺点分析-1"><a href="#优缺点分析-1" class="headerlink" title="优缺点分析"></a>优缺点分析</h5><p>DNS负载均衡最大的优点就是配置简单。服务器集群的调度工作完全由DNS服务器承担，那么我们就可以把精力放在后端服务器上，保证他们的稳定性与吞吐量。而且完全不用担心DNS服务器的性能，即便是使用了轮询策略，它的吞吐率依然卓越。<br>此外，DNS负载均衡具有较强了扩展性，你完全可以为一个域名解析较多的IP，而且不用担心性能问题。<br><br><br>但是，由于把集群调度权交给了DNS服务器，从而我们没办法随心所欲地控制调度者，没办法定制调度策略。<br><br><br>DNS服务器也没办法了解每台服务器的负载情况，因此没办法实现真正意义上的负载均衡。它和HTTP重定向一样，只不过把所有请求平均分配给后端服务器罢了。<br><br><br>此外，当我们发现某一台后端服务器发生故障时，即使我们立即将该服务器从域名解析中去除，但由于DNS服务器会有缓存，该IP仍然会在DNS中保留一段时间，那么就会导致一部分用户无法正常访问网站。这是一个致命的问题！好在这个问题可以用动态DNS来解决。<br><br><br>动态DNS能够让我们通过程序动态修改DNS服务器中的域名解析。从而当我们的监控程序发现某台服务器挂了之后，能立即通知DNS将其删掉。<br><br></p><h4 id="反向代理负载均衡"><a href="#反向代理负载均衡" class="headerlink" title="反向代理负载均衡"></a>反向代理负载均衡</h4><p>反向代理服务器是一个位于实际服务器之前的服务器，所有向我们网站发来的请求都首先要经过反向代理服务器，服务器根据用户的请求要么直接将结果返回给用户，要么将请求交给后端服务器处理，再返回给用户。<br><br><br>之前我们介绍了用反向代理服务器实现静态页面和常用的动态页面的缓存。接下来我们介绍反向代理服务器更常用的功能——实现负载均衡。<br><br><br>我们知道，所有发送给我们网站的请求都首先经过反向代理服务器。那么，反向代理服务器就可以充当服务器集群的调度者，它可以根据当前后端服务器的负载情况，将请求转发给一台合适的服务器，并将处理结果返回给用户。<br><br></p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>隐藏后端服务器。</li><li>与HTTP重定向相比，反向代理能够隐藏后端服务器，所有浏览器都不会与后端服务器直接交互，从而能够确保调度者的控制权，提升集群的整体性能。<br>故障转移</li><li>与DNS负载均衡相比，反向代理能够更快速地移除故障结点。当监控程序发现某一后端服务器出现故障时，能够及时通知反向代理服务器，并立即将其删除。<br>合理分配任务</li><li><p>HTTP重定向和DNS负载均衡都无法实现真正意义上的负载均衡，也就是调度服务器无法根据后端服务器的实际负载情况分配任务。但反向代理服务器支持手动设定每台后端服务器的权重。我们可以根据服务器的配置设置不同的权重，权重的不同会导致被调度者选中的概率的不同。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5></li><li><p>调度者压力过大</p></li><li>由于所有的请求都先由反向代理服务器处理，那么当请求量超过调度服务器的最大负载时，调度服务器的吞吐率降低会直接降低集群的整体性能。<br>制约扩展</li><li>当后端服务器也无法满足巨大的吞吐量时，就需要增加后端服务器的数量，可没办法无限量地增加，因为会受到调度服务器的最大吞吐量的制约。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Nginx是啥&quot;&gt;&lt;a href=&quot;#Nginx是啥&quot; class=&quot;headerlink&quot; title=&quot;Nginx是啥&quot;&gt;&lt;/a&gt;Nginx是啥&lt;/h3&gt;&lt;p&gt;Nginx是一个使用c语言开发的高性能http服务器以及反向代理服务器。Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。&lt;br&gt;
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
